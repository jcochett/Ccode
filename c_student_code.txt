#include <stdio.h>

int add_numbers(int x, int y);

int main(void)
{
	int i = 0;
	int num = 0;
	int returnValue = 0;

	for(i = 0; i < 10; i++)
	{
		returnValue = add_numbers(num, i);
		printf("%d\n", returnValue);
	}

	return 0;
}

int add_numbers(int x, int y)
{
	return (x + y);
}
#include <stdio.h>

int main(void)
{
	/*
	float num1 = 1.0;
	float num2 = 1.0;
	float result = 0;
	*/
	double num1 = 1.0;
	double num2 = 1.0;
	double result = 0;
	int counter = 0;

	
	while (num1 + num2 != num1)
	{
		++counter;
		num2 = num2 / 10.0;
	}
	printf("%2d digits accuracy in calculations\n", counter);

	num2 = 1.0;
	counter = 0;

	while (1)
	{
		result = num1 + num2;
		if (result == num1)
		{
			break;
		}
		++counter;
		num2 = num2 / 10.0;
	}
	printf("%2d digits accuracy in storage\n", counter);

	getchar();
	return 0;
}
#include <stdio.h>

// void printArray(_____, int arrayDimension);

int main(void)
{
	int computerScienceCourses[] = {1003, 1023, 1033, 1063, 1073};
	float studentGPAs[] = { 2.7, 3.1, 2.9, 4, 3.9, 2.89, 3.55 };
	char cardinalDirections[4] = {0};
	char catchPhrase[10] = {76, 101, 103, 101, 110};
	int i = 0;

	printf("\nThese are the Computer Science Course numbers:\n");
	for (i = 0; i < 5; i++)
	{
		printf("Course #%d is %d.\n", i + 1, computerScienceCourses[i]);
	}

	printf("\nThese are the student GPAs:\n");
	for (i = 0; i < 7; i++)
	{
		printf("GPA #%d is %f.\n", i + 1, studentGPAs[i]);
	}

	printf("\nThese are the cardinal directions:\n");
	for (i = 0; i < 4; i++)
	{
		printf("Cardinal direction #%d is %c.\n", i + 1, cardinalDirections[i]);
	}
	
	printf("\nThis is the catch phrase:\n");
	for (i = 0; i < 10; i++)
	{
		printf("%c", catchPhrase[i]);
	}
	printf("...\n");

	printf("%s...\n", catchPhrase);

	getchar();
}#include <stdio.h>

// void printArray(_____, int arrayDimension);

int main(void)
{
	int computerScienceCourses[] = {1003, 1023, 1033, 1063, 1073};
	float studentGPAs[] = { 2.7, 3.1, 2.9, 4, 3.9, 2.89, 3.55 };
	char cardinalDirections[4] = {0};
//	char catchPhrase[10] = {76, 101, 103, 101, 110};
	char catchPhrase[10] = { 76, 101, 103, 101, 110, 46, 46, 46, 46 };
	int testArray[5] = {100};
	int i = 0;

	int myCourse = computerScienceCourses[1]; // Sets myCourse to 1023
	studentGPAs[1 + 2] = 3.91; // Sets index 3 to value 3.9
	i = 1;
	cardinalDirections[0] = 78;
	cardinalDirections[i] = 83;
	cardinalDirections[i + i] = 'E';
	cardinalDirections[i + 2] = 'W';

	printf("\nThese are the Computer Science Course numbers:\n");
	for (i = 0; i < 5; i++)
	{
		printf("Course #%d is %d.\n", i + 1, computerScienceCourses[i]);
	}

	printf("\nThese are the student GPAs:\n");
	for (i = 0; i < 7; i++)
	{
		printf("GPA #%d is %f.\n", i + 1, studentGPAs[i]);
	}

	printf("\nThese are the cardinal directions:\n");
	for (i = 0; i < 4; i++)
	{
		printf("Cardinal direction #%d is %c.\n", i + 1, cardinalDirections[i]);
	}
	
	catchPhrase[5] = 100;
	printf("\nThis is the catch phrase:\n");
	for (i = 0; i < 10; i++)
	{
		printf("%c", catchPhrase[i]);
	}
	printf("...\n");

	printf("%s...\n", catchPhrase);

	printf("\nDone.\n");
	getchar();
}#include <stdio.h>

int main(void)
{
	////////////////////////////////////////////////////////////////////////
	// Declare and initialize the following arrays:
	// Data Type	Name			Dimension	Initialize to:
	// ---------------------------------------------------------------------
	// int			myIntArray		10			100 (every index)
	// float		myFloatArray	5			1 - 5
	// char			myCharArray		256			0
	////////////////////////////////////////////////////////////////////////
	int myIntArray[10] = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 }; // Option #1
//	int myIntArray[] = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 }; // Option #2

	float myFloatArray[5] = { 1, 2, 3, 4, 5 }; // Option #1
//	float myFloatArray[] = { 1, 2, 3, 4, 5 }; // Option #2

	char myCharArray[256] = { 0 }; // Most efficient option

	////////////////////////////////////////////////////////////////////////
	// Print the 3rd element of each array
	////////////////////////////////////////////////////////////////////////
	printf("The third element of my int array is:  %d\n", myIntArray[2]);
	printf("The third element of my float array is:  %f\n", myFloatArray[2]);
	printf("The third element of my char array is:  %c\n", myCharArray[2]);

	////////////////////////////////////////////////////////////////////////
	// Perform the following manipulations on your arrays:
	// Array Name
	// ---------------------------------------------------------------------
	// myIntArray		Set all elements to x if y = index # and x = (y + 1) * 10
	// myFloatArray		Set all elements to x if y = value of the index and x = y * 1.1
	// myCharArray		Fill in the beginning elements with your last name starting with index 0
	////////////////////////////////////////////////////////////////////////
	// Option #1 - Static assignment
	myIntArray[0] = 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[1] = 20; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[2] = 30; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[3] = 40; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[4] = 50; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[5] = 60; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[6] = 70; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[7] = 80; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[8] = 90; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[9] = 100; // Value is set to x where x = (y + 1) * 10 if y = index #
	// Option #2 - Calculated assignment
	/*
	myIntArray[0] = (0 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[1] = (1 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[2] = (2 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[3] = (3 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[4] = (4 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[5] = (5 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[6] = (6 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[7] = (7 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[8] = (8 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	myIntArray[9] = (9 + 1) * 10; // Value is set to x where x = (y + 1) * 10 if y = index #
	*/
	// Option #3 - For loop
	int i = 0; // Used to iterate through a for loop
	for (i = 0; i < 10; i++) // Executes the following code using i with values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
	{
		myIntArray[i] = (i + 1) * 10; // Variable i represents the current index
	}

	// Option #1 - Static assignment
	myFloatArray[0] = 1 * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[1] = 2 * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[2] = 3 * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[3] = 4 * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[4] = 5 * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	// Option #2 - Calculated assignment
	/*
	myFloatArray[0] = myFloatArray[0] * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[1] = myFloatArray[1] * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[2] = myFloatArray[2] * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[3] = myFloatArray[3] * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	myFloatArray[4] = myFloatArray[4] * 1.1; // Value is set to x where x = y * 1.1 if y = current index value
	*/
	// Option #3 - For loop
	/*
	int i = 0; // Used to iterate through a for loop
	for (i = 0; i < 5; i++) // Executes the following code using i with values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
	{
		myFloatArray[i] = myFloatArray[i] * 1.1; // Variable i represents the current index
	}
	*/

	// Most efficient method
	myCharArray[0] = 72;	// H
	myCharArray[1] = 97;	// a
	myCharArray[2] = 114;	// r
	myCharArray[3] = 107;	// k
	myCharArray[4] = 108;	// l
	myCharArray[5] = 101;	// e
	myCharArray[6] = 114;	// r
	myCharArray[7] = 111;	// o
	myCharArray[8] = 97;	// a
	myCharArray[9] = 100;	// d

	printf("\n");
	printf("The third element of my modified int array is:  %d\n", myIntArray[2]);
	printf("The third element of my modified float array is:  %f\n", myFloatArray[2]);
	printf("The third element of my modified char array is:  %c\n", myCharArray[2]);
//	printf("My last name is %s\n", myCharArray);
	getchar();

	return 0;
}#include <stdio.h>

int main(void)
{
	int everyonesAges[8] = { 0 };
	everyonesAges[0] = 39;
	everyonesAges[1] = 42;
	everyonesAges[2] = 42;
	everyonesAges[3] = 42;
	everyonesAges[4] = 42;
	everyonesAges[5] = 42;
	everyonesAges[6] = 42;
	everyonesAges[7] = 42;

	int i = 0;
	for (i = 0; i < 8; i++)
	{
		printf("everyoneAge[%d] = %d\n", i, everyonesAges[i]);
	}

	// Option #1 - Element by element
//	char favoriteSaying[] = { 10, 'B', 'a', 'z', 'i', 'n', 'g', 'a', '!', 10, 0};
	// Option #2 - String method
	char favoriteSaying[] = { "\nBazinga!\n"};
	printf("My favorite saying is: %s\n", favoriteSaying);

	getchar();
	return 0;
}#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	/*
	int num1 = 0;
	int num2 = 0;
	
	printf("Input two number separated by a space:  ");
	scanf("%d,%d", &num1, &num2);

	printf("Your numbers were %d and %d.\n", num1, num2);
	*/

	/*
	float GPA = 0.0;
	printf("Enter your GPA:  ");
	scanf("%3f", &GPA);
	printf("Your GPA is:  %f \n", GPA);
	*/

	/*
	double reading = 0.0;
	printf("Enter a reading:  ");
	scanf("%lf", &reading);
	printf("Your reading was:  %f", reading);
	*/

	/*
	char noun1[11] = { 0 };
	char noun2[11] = { 0 };
	printf("Type the following:  ");
	printf("My _____ likes _____\n");
	_flushall();
	scanf("My %10s likes %10s", noun1, noun2);
	
	if (noun1[0] == 0 || noun2[0] == 0)
	{
		printf("You goofed.");
	}
	else
	{
		printf("I can't believe that your %s likes %s!\n", noun1, noun2);
	}
	*/
	
	/*
	double doubleNum = 0.0;
	printf("Enter a number preceded by an asterisk (*)...\nFor example:  *1.23\n");
	_flushall();
	scanf("*%lf*", &doubleNum);
	printf("You entered:  %f", doubleNum);
	*/
//	_flushall();

	/*
	char input = 0;
	printf("Input a character.\n");
	_flushall();
	scanf("%[abcd]c", &input);
	printf("Your string was:  %c \n", input);
	*/

	/*
	char leetString[20] = { 0 };
	char binaryString[65] = { 0 };
	printf("Input a string only using traditional 1337 characters:  ");
	scanf("%19[1234567890]s", leetString);
	printf("Your 1337 57rin6 was:  %s \n", leetString);
	_flushall(); // Necessary or previously scanned \n is still on the input stream
	printf("Input a binary number as a string:  ");
	scanf("%64[01]s", binaryString);
	printf("Your binary string was:  %s", binaryString);
	*/

	/*
	char novelGadsby[256] = { 0 };
	printf("Construct a saying that fully omits any 'e'.\n");
	_flushall();
	scanf("%255[^e\n]s", novelGadsby);
	printf("You input this without using an 'e'.\n%s\n", novelGadsby);
	*/

	/*
	char alphabetLetter = 0;
	printf("Input one of the letters of the alphabet:  ");
//	scanf("%[a-zA-Z]c", &alphabetLetter); // Only accepts upper & lower case letters
	scanf("%[A-z]c", &alphabetLetter); // Only accepts chars of decimal value 65-122
	printf("Your alphabet letter was:  %c", alphabetLetter);
	*/

	/*
	char inputBuffer[256] = { 0 };
	printf("Enter a string but don't use any capital letters. \n");
	_flushall();
//	printf("Number of open input and output streams:  %d \n", _flushall());
	scanf("%255[^A-Z\n]s", inputBuffer); // Stops reading at first capital letter
	printf("Your lower case string was:  \n%s", inputBuffer);
	*/

	/*
	int month = 0; int day = 0; int year = 0;
	printf("Input today's date, using numbers, in the following format:\nm-d-yyyy\n");
	_flushall();
	scanf("%d-%d-%d", &month, &day, &year);
	printf("Today's date is %02d/%02d/%04d \n", month, day, year);
	*/

	/*
	// Performance Lab x.1.e-5
	char firstName[20] = { 0 };
	char middleName[20] = { 0 };
	char lastName[20] = { 0 };
	printf("Enter your first, middle, and last name separated by spaces:  \n");
	_flushall();
	scanf("%19s\t%19s\t%19s", firstName, middleName, lastName);
	printf("Your name is: \n\t%s\n\t%s\n\t%s\n", firstName, middleName, lastName);
	*/

	/*
	// Performance Lab x.1.e-5
	int hours = 0;
	int minutes = 0;
	int seconds = 0;
	printf("Enter the current time as h:m:s:  ");
	scanf("%d:%d:%d", &hours, &minutes, &seconds);
	printf("The current time is %02d hours, %02d minutes, and %02d seconds. \n", hours, minutes, seconds);
	*/

	// /*
	printf("Size of int:  %d\n", sizeof(int));
	int leftOperand = 0;
	int rightOperand = 0;
	printf("RUDIMENTARY CALCULATOR\nEnter two numbers, separated by a *, and I will multiply them. \n");
	_flushall();
	scanf("%d*%d", &leftOperand, &rightOperand);
	printf("The result of %d multiplied by %d is %d \n", leftOperand, rightOperand, leftOperand * rightOperand);
	// */


	return 0;
}
#include <stdio.h>

int main(void)
{
	int userInput = 0; // Stores user input

	printf("\nEnter a character:  ");
//	userInput = getchar();
	userInput = getc(stdin);

	printf("Your character was:  ");
//	putchar(userInput + 1);
//	putc(userInput + 1, stdout);
	putc(userInput - 1, stdout);
	//	putchar(userInput);

	return 0;
}
#include <stdio.h>

int main(void)
{
	int i = 0; // Iterator
	char c = 0;
//	char inputBuffer[256];// = { 0 };
	char inputBuffer[10];
	printf("The size of your buffer is %d.\n", sizeof(inputBuffer)); // DEBUGGING
	printf("What is your favorite phrase?\n");

	while ((c = getchar()) != '\n' && c != EOF && i < sizeof(inputBuffer))
	{
		/*
		if (i < sizeof(inputBuffer))
		{
			inputBuffer[i++] = c;
		}
		*/
		inputBuffer[i++] = c;
	}
	inputBuffer[sizeof(inputBuffer)-1] = 0;
	printf("Your favorite prhase is:  \n%s\n", inputBuffer);

	getchar();
	return 0;
}
#include <stdio.h>

int main(void)
{
	char inputCharacter = 0;
	printf("Enter a character:  ");
	inputCharacter = getchar();
	printf("Your character was %c.\n", inputCharacter);

//	getchar(); // Useless because the previous carriage return is not flushed.  We're not being fancy here.
	return 0;
}
#include <stdio.h>

int main(void)
{
	float someNum = 12.3456;

	printf("%f \n", 1.2);
	printf("%+8.4f \n", -1.798);
	printf("% 7.2f \n", 0.987654321);
	printf("%-6.1f is your number\n", 13.37);
	printf("Your number is %05.2f \n", 1.2345);
	printf("%s \n", "Hello world!\0");
	printf("%9.5s \n", "Hello world!\0");
	printf("%016.11s \n", "Hello world!\0");

	getchar();
	return 0;
}
#include <stdio.h>

int main(void)
{
	float someNum = 12.3456;

	printf("Default field width:------>  %f \n", someNum);
	printf("No field width:----------->  %0f \n", someNum);
	printf("Field width of two:------->  %2f \n", someNum);
	printf("Field width of four:------>  %4f \n", someNum);
	printf("Field width of eight:----->  %8f \n", someNum);
	printf("Field width of sixteen:--->  %16f \n", someNum);
	printf("Field width of twenty five:  %25f \n", someNum);

	getchar();
	return 0;
}
#include <stdio.h>

int main(void)
{
	float someNum = 12.3456;

	printf("Normal:  %f \n", someNum);
	printf("Normal:  %f \n", someNum * -1.0);
	printf("Plus:    %+f \n", someNum);
	printf("Plus:    %+f \n", someNum * -1.0);
	printf("Space:   % f \n", someNum);
	printf("Space:   % f \n", someNum * -1.0);
	printf("Dash:    %-f \n", someNum);
	printf("Dash:    %-f \n", someNum * -1.0);
	printf("Zeros:   %0f \n", someNum);
	printf("Zeros:   %016f \n", someNum);
//	printf("Pound:   %#f \n", someNum);

	getchar();
	return 0;
}#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
	int hour = 0;
	int minute = 0;
	int seconds = 0;

//	scanf("%d%*c%d%*c%d", &hour, &minute, &seconds);
	scanf("%d-%d-%d", &hour, &minute, &seconds);


	printf("The current time is %02d:%02d:%02d.", hour, minute, seconds);

	getchar();
	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	
	int theAnswer = 0;
	float pi = 0;
	double posSqrtTwo = 0;
	char nickName[20] = { 0 };
	char answerNum1 = 0;

	fprintf(stdout,"What is the answer is to life, the universe and everything?  ");
	scanf("%d", &theAnswer);

	_flushall();

	fprintf(stdout,"What do you think pi is?  ");
	scanf("%f", &pi);
	
	_flushall();

	fprintf(stdout,"What do you think 2^(1/2) is?  ");
	scanf("%lf", &posSqrtTwo);
	
	_flushall();

	fprintf(stdout,"What is your nickname?  ");
	//	scanf("%s", nickName);
	//	scanf_s("%s", nickName, _countof(nickName));
	scanf("%19s", nickName);
	
	_flushall();

	fprintf(stdout,"What is the answer to number 1?\nA, B, C, or D?  ");
	scanf("%c", &answerNum1);
	
	_flushall();

	fprintf(stdout,"The answer is to life, the universe and everything is:  %d \n", theAnswer);
	fprintf(stdout,"You think pi is:  %f \n", pi);
	fprintf(stdout,"You this 2^(1/2) is:  %f \n", posSqrtTwo);
	fprintf(stdout,"Your nickname is:  %s \n", nickName);
	fprintf(stdout,"Your answer to question number 1 is:  %c", answerNum1);

	//	getchar();
	return 0;
}
#include <stdio.h>

int main(void)
{
	float someNum = 12.3456; // Variable used as comparison
	
	printf("No precision:  %f \n", someNum);
	printf("No decimal places:  %.0f \n", someNum);
	printf("Two decimal places:  %.2f \n", someNum);
	printf("Four decimal places:  %.3f \n", someNum);
	printf("Six decimal places:  %.6f \n", someNum);
	printf("Twenty decimal places:  %.20f \n", someNum);
	
	getchar();
	return 0;
}#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
/*
	int theAnswer = 0;
	float pi = 0;
	double posSqrtTwo = 0;
*/
	char nickName[20] = { 0 };
//	char answerNum1 = 0;

/*
	printf("What is the answer is to life, the universe and everything?  ");
	scanf("%d", &theAnswer);

	printf("What do you think pi is?  ");
	scanf("%f", &pi);

	printf("What do you think 2^(1/2) is?  ");
	scanf("%lf", &posSqrtTwo);
*/
	printf("What is your nickname?  ");
//	scanf("%s", nickName);
//	scanf_s("%s", nickName, _countof(nickName));
	scanf("%19s", nickName);
/*
	printf("What is the answer to number 1?\nA, B, C, or D?  ");
	scanf("%c", &answerNum1);
*/
//	printf("The answer is to life, the universe and everything is:  %d \n", theAnswer);
//	printf("You think pi is:  %f \n", pi);
//	printf("You this 2^(1/2) is:  %f \n", posSqrtTwo);
	printf("Your nickname is:  %s \n", nickName);
//	printf("Your answer to question number 1 is:  %c", answerNum1);

//	getchar();
	return 0;
}
#include <stdio.h>
#include <string.h>

void printString(const char *str);

int main(void)
{
	char instructorName[5] = { 'H', 'a', 'r', 'k', '\0' };
//	char instructorName[5] = { 'H', 'a', 'r', 'k', NULL }; // Don't use NULL, NULL is meant for pointers
//	char instructorName[] = { 'H', 'a', 'r', 'k' }; // This array is not null-terminated
	char inputBuffer[256] = { 0 };
	char studentLastName[32] = {89, 111, 117, 0};
	char studentFirstName[32];
	studentFirstName[31] = 0;

	printf("The string instructorName is %d characters long.\n", strlen(instructorName));
	printString(instructorName);
	printf("The string inputBuffer is %d characters long.\n", strlen(inputBuffer));
	printString(inputBuffer);
	printf("The string studentFirstName is %d characters long.\n", strlen(studentFirstName));
	printString(studentFirstName);
	printf("The string studentLastName is %d characters long.\n", strlen(studentLastName));
	printString(studentLastName);

	getchar();
	return 0;
}

void printString(const char *str)
{
	if (str)
	{
		int i = 0; // Iterator
		printf("\n");
		for (i = 0; i < strlen(str); i++)
		{
			printf("%c", str[i]);
		}
		printf("\n");
	}
	return;
}#include <stdio.h>

int main(void)
{
	char myFavoriteWord[9] = { 0 };

	myFavoriteWord[0] = 66;
	myFavoriteWord[1] = 97;
	myFavoriteWord[2] = 122;
	myFavoriteWord[3] = 105;
	myFavoriteWord[4] = 110;
	myFavoriteWord[5] = 103;
	myFavoriteWord[6] = 97;
	myFavoriteWord[7] = 33;
	myFavoriteWord[8] = 0;

	printf("My string is '%s'.\n", myFavoriteWord);

	getchar();
	return 0;
}#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	char string1[10];
	char string2[10];

	printf("Enter string 1:  ");
	scanf("%s", string1);

	printf("Enter string 2:  ");
	scanf("%9s", string2);

	printf("String 1 is %s \n", string1);
	printf("String 2 is %s \n", string2);

//	getchar();
	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#define BUFF_SIZE 16

int main(void)
{
	char smallBuffer[BUFF_SIZE] = { 0 };

	printf("Enter a string:  ");
	gets(smallBuffer);

	printf("Your string was:  ");
	puts(smallBuffer);

	getchar();
	return 0;
}#include <stdio.h>

int main(void)
{
	char myString[] = { "Hello world!" };
//	char myString[] = { "Hello world!\0" }; // This will set a redundant null character
//	char myString[] = {'H', 'e', 'l', 'l', 'o'}; // This will cause a buffer overflow

	printf("Your string is:         %s \n", myString);
	printf("Just enough precision:  %.12s \n", myString);
	printf("No punctuation:         %.11s \n", myString);
	printf("First word is:          %.5s \n", myString);
	printf("Nothing:                %.0s \n", myString);
	printf("Too much:               %.1000s\tTHE END\n", myString);

	getchar();
	return 0;
}#include <stdio.h>

int main(void)
{
	char myString[] = { "Hello world!" };
	//	char myString[] = { "Hello world!\0" }; // This will set a redundant null character
	//	char myString[] = {'H', 'e', 'l', 'l', 'o'}; // This will cause a buffer overflow

	printf("Your string is:--------->  %s \n", myString);
	printf("Minimum width zero:----->  %0s \n", myString);
	printf("Minimum width four:----->  %4s \n", myString);
	printf("Minimum width eight:---->  %8s \n", myString);
	printf("Minimum width sixteen:-->  %16s \n", myString);
	printf("Minimum width twenty six:  %26s \n", myString);

	getchar();
	return 0;
}#include <stdio.h>

int main(void)
{
	/* INITIALIZATION */
	int x = 5;
	int y = 3;
	printf("x = %d \ny = %d\n", x, y);


	/* INCREMENT */

	printf("x++ \t%d\n", x++);
	printf("++y \t%d\n", ++y);
	printf("++x \t%d\n", ++x);


	/* RESET VARIABLES */
	int x = 5;
	int y = 3;
	printf("x = %d \ny = %d\n", x, y);


	/* DECREMENT */


	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	int a = 2; // Dividend
	int n = 1; // Divisor

	printf("Enter two integers separated by a %%. \n(e.g. 5%%3) \n");
	_flushall();
	scanf("%d%%%d", &a, &n);
//	printf("a = %d \nn = %d \n", a, n); // DEBUGGING

	printf("%d %% %d = %d \n", a, n, a%n);
	printf("Mathematically:  %d \n", a - (n * (a / n))); // Manual calculation

	return 0;
}
#include <stdio.h>

int main(void)
{
	int x = 7;
	int y = 4;
	float z = 0;
	printf("x = %d \ny = %d \n\n", x, y);

	printf("x * y = %d \n", 7 * 4);
	z = x / y;
	printf("x / y = %f \n", z);
	printf("x / y = %f \n", (x / y));
	printf("x %% y = %d \n", 7 % 4);
	printf("y + x = %d \n", 4 + 7);
	printf("y - x = %d \n", 4 - 7);
	printf("-y = %d \n", -(y));
	printf("++x = %d \n", ++x); x = 7; // Resets the variable
	printf("y++ = %d \n", y++); y = 4; // Resets the variable
	printf("x-- = %d \n", x--); x = 7; // Resets the variable
	printf("--y = %d \n", --y); y = 4; // Resets the variable
	printf("1 + 2 * (3 + y) + 5 = %d", 1 + 2 * (3 + y) + 5); // BONUS

	return 0;
}
#include <stdio.h>

int main(void)
{
	int x = 5;
	int y = 3;

	printf("x = %d\ny = %d \n", x, y);
	printf("x * y = %d \n", x * y);
	printf("x / y = %d \n", x / y);
	printf("x %% y = %d \n", x % y);
	printf("x + y = %d \n", x + y);
	printf("x - y = %d \n", x - y);
	printf("+x = %d \n", +x);
	printf("-x = %d \n", -x);
	printf("++x = %d (and remains %d) \n", ++x, x);
	printf("y++ = %d (and then becomes %d) \n", y++, y);

	x = 5; y = 3; // Resets the variable

	printf("--y = %d (and remains %d) \n", --y, y);
	printf("x-- = %d (and then becomes %d) \n", x--, x);

	return 0;
}#include <stdio.h>

int main(void)
{
	int x = 5;
	int y = 3;

	// Establish baseline problem
	printf("\n***ISSUE***\n");
	printf("x / y = %d \n", x / y); // Integer arithmetic with variable operands
	printf("5 / 3 = %d \n", 5 / 3); // Integer arithmetic with constant operands

	// Showcast solutions
	printf("\n***RIGHT***\n");
	printf("5.0 / y = %f \n", 5.0 / y); // Manually express one integer as a decimal
	printf("x / 3.0 = %f \n", x / 3.0); // Manually express one integer as a decimal
	printf("5.0 / 3.0 = %f \n", 5.0 / 3.0); // Manually express both integers as decimals
	printf("(float)5 / 3 = %f \n", (float)5 / 3); // Type cast one constant integer as a float
	printf("5 / (float)3 = %f \n", 5 / (float)3); // Type cast one constant integer as a float
	printf("(float)5 / (float)3 = %f \n", (float)5 / (float)3); // Type cast two constant integers as floats
	printf("(float)x / y = %f \n", (float)x / y); // Type cast one integer variable as a float
	printf("x / (float)y = %f \n", x / (float)y); // Type cast one integer variable as a float
	printf("(float)x / (float)y = %f \n", (float)x / (float)y); // Type cast two integer variables as floats
	
	// Showcast intuitive solutions that don't work
	printf("\n***WRONG***\n");
	printf("x / y (formatted as a float) = %f \n", x / y); 
	/* Forcing conversion using printf's %f does not work.
		The result in of type int forced to be interpretted as a float. */
	printf("(float)(x / y) = %f \n", (float)(x / y));
	/* Type casting the entire expression merely type casts the result
		of that expression.  In this cast (5 / 3) returns 1.  At this
		point, 1 is then type cast as a float. */
	
	return 0;
}#include <stdio.h>

int main(void)
{
	int x = 10;
	int y = 2;

	printf("x = %d \ny = %d \n\n", x, y);

	printf("x *= y is %d \n", x *= y);		// 20
	x = 10; y = 2; // Resets variables
	printf("x /= y is %d \n", x /= y);		// 5
	x = 10; y = 2; // Resets variables
	printf("x %%= y is %d \n", x %= y);		// 0
	x = 10; y = 2; // Resets variables
	printf("x += y is %d \n", x += y);		// 12
	x = 10; y = 2; // Resets variables
	printf("x -= y is %d \n", x -= y);		// 8
	x = 10; y = 2; // Resets variables
	printf("x += ++y is %d \n", x += ++y);	// 13
	x = 10; y = 2; // Resets variables
	printf("x += y++ is %d \n", x += y++);	// 12
	x = 10; y = 2; // Resets variables
	printf("x -= --y is %d \n", x -= --y);	// 9
	x = 10; y = 2; // Resets variables
	printf("x -= y-- is %d \n", x -= y--);	// 8
	x = 10; y = 2; // Resets variables

	return 0;
}
#include <stdio.h>

int main(void)
{
	int x = 9;
	int y = 3;

	printf("0.  x *= y is %d \n", x *= y);
	x = 9; y = 3; // Resets the variables
	printf("1.  x /= y is %d \n", x /= y);
	x = 9; y = 3; // Resets the variables
	printf("2.  x %%= y is %d \n", x %= y);
	x = 9; y = 3; // Resets the variables
	printf("3.  x += y is %d \n", x += y);
	x = 9; y = 3; // Resets the variables
	printf("4.  x -= y is %d \n", x -= y);
	x = 9; y = 3; // Resets the variables
	printf("5.  x *= ++y is %d \n", x *= ++y);
	x = 9; y = 3; // Resets the variables
	printf("6.  x /= y-- is %d \n", x /= y--);
	x = 9; y = 3; // Resets the variables
	printf("7.  x %%= --x is %d \n", x %= --x);
	x = 9; y = 3; // Resets the variables
	printf("8.  x += --y is %d \n", x += --y);
	x = 9; y = 3; // Resets the variables
	printf("9.  x -= y++ is %d \n", x -= y++);
	x = 9; y = 3; // Resets the variables
	printf("BONUS  (y %%= y) || (x /= x--) is %d \n", (y %= y) || (x /= x--));

	x = 9; y = 3; // Resets the variables
//	printf("x /= x-- is %d \n", x /= x--); // DEBUGGING


	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <math.h>

int main(void)
{
	/* Initialize variables here */
	
	/* Input values and assign to variables here*/

	if (/* Add logial combination of relational expressions here*/)
	{
		/* Place arithmetic hypotenuse calculation here */
		/* Print the hypotenuse here */
	}
	
	return 0;
}
#include <stdio.h>

int main(void)
{
	int p = 0;
	int q = 9;
	int r = 1;

	printf("p = %d \nq = %d \nr = %d \n\n", p, q, r);

	printf("1 && 0 is %d \n", 1 && 0);
	printf("1 || 0 is %d \n", 1 || 0);
	printf("!1 is %d \n", !1);
	printf("p && q is %d \n", p && q);
	printf("p || q is %d \n", p || q);
	printf("!p is %d \n", !p);
	printf("q && r is %d \n", q && r);
	printf("q || r is %d \n", q || r);
	printf("!q is %d \n", !q);

	return 0;
}
#include <stdio.h>

int main(void)
{
	int x = 5;
	int y = 3;

	printf("x = %d \ny = %d \n", x, y);
	printf(" x < y:  %d \n", x < y);
	printf("x <= y:  %d \n", x <= y);
	printf(" x > y:  %d \n", x > y);
	printf("x >= y:  %d \n", x >= y);
	printf("x == y:  %d \n", x == y);
	printf("x != y:  %d \n", x != y);

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	float output1 = 1.23456;
	float output2 = 1.23456;
	float output3 = 1.23456;
	float output4 = 1.23456;

	output1 += 0.05 + 0.05 + 0.05;
	output2 += 0.45 / 3;
	output3 += 0.075 * 2;
	output4 += 0.05 + 0.05 * 2;

	printf("Float #1 is %f,\n float #2 is %f,\n float #3 is %f,\n and float #4 is %f. \n", output1, output2, output3, output4);

	if (output1 == output2 && output2 == output3 && output3 == output4)
	{
		printf("They're the same.\n");
	}
	else
	{
		printf("They're different.\n");
	}

	return 0;
}
#include <stdio.h>

int main(void)
{
	int x = 2;
	int y = 6;

	printf("x = %d \ny = %d \n\n", x, y);

	printf("y < x is %d \n", y < x);
	printf("y <= x is %d \n", y <= x);
	printf("y > x is %d \n", y > x);
	printf("y >= x is %d \n", y >= x);
	printf("y == x is %d \n", y == x);
	printf("y != x is %d \n", y != x);
	printf("y < x is %d \n", y < x);
	printf("y < x is %d \n", y < x);
	printf("y < x is %d \n", y < x);
	printf("y < x is %d \n", y < x);
	printf("x != y != 3 >= x is %d \n", x != y != 3 >= x);

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
//	float input = 0;
	float output1 = 0;
	float output2 = 0;

	/*
	printf("Input a float:  ");
	scanf("%f", &output1);
	printf("Input the same float:  ");
	scanf("%f", &output2);
	*/
//	output1 = input;
//	output2 = input;

	output1 = 10.0 / 6;
	output2 = 5.0 / 3;

	if (output1 == output2)
	{
		printf("They're the same.\n");
	}
	else
	{
		printf("They're different.\n");
	}

	return 0;
}
#include <stdio.h>
#include <limits.h>

int main(void)
{
	unsigned int number = UINT_MAX;
	int i = 0;
	unsigned int newNumber = 0;
	unsigned int numberArray[] = {UINT_MAX, UINT_MAX, UINT_MAX, UINT_MAX};
	unsigned int tempValue = 0;

	int arrayDimension = sizeof(numberArray) / sizeof(unsigned int);

	for (i = 0; i < arrayDimension; i++)
	{
		//tempValue = numberArray[i] << i;
		numberArray[i] = numberArray[i] << i;
		printf("Shifted array value:  %u \n", numberArray[i]);
	}

	/*
	for (i = 0; i < (sizeof(number)*8); i++)
	{
		newNumber = number << i;
		printf("Number %u bit shifted left %d positions is %u \n", number, i, newNumber);
	}
	*/

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <limits.h>

int main(void)
{
	unsigned int x = 0;
	unsigned int y = UINT_MAX;

	printf("Input two integers:  ");
	scanf("%d %d", &x, &y);

	printf("Integer #1 was %d and integer #2 was %d at %d bytes. \n", x, y, sizeof(unsigned int));
	printf("x & y = %d \n", x & y);
	printf("x | y = %d \n", x | y);
	printf("x ^ y = %d \n", x ^ y);
	printf("~x = %d \n", (unsigned short) ~3);
	printf("~y = %d \n", (unsigned short) ~6);
	printf("x << y = %d \n", x << y);
	printf("x >> y = %d \n", x >> y);

	printf("y >> 1 = %d \n", y >> 1); // TESTING
	printf("y << 1 = %d \n", y << 1); // TESTING

	/* Unsigned Short */
	unsigned short z = 0;
	printf("Unsigned short #1 was %d at %d bytes. \n", z, sizeof(unsigned short));
	printf("~z = %d \n", ~z);
	printf("z = ~z = %d \n", z = ~z);
//	printf("--z = %d \n", --z);

	unsigned short aa = 59301;
	printf("Unsigned short #2 was %d at %d bytes. \n", aa, sizeof(unsigned short));
	aa = ~aa;
	printf("~aa = %d \n", aa);

	return 0;
}
#include <stdio.h>

int main(void)
{
	signed short x = -17;
	signed short currentValue = 0;
	int i = 0;
	printf("x = %d \n", x);

	for (i = 0; i <= 16; i++)
	{
		currentValue = x >> i;
		printf("x >> %d = %d \n", i, currentValue);
	}

	return 0;
}
//////////////////////////////////////////////////////////////////////
///////////////////// PERFORMANCE LAB I.1.g-3 ////////////////////////
///////////////// Brute force an obfuscated string ///////////////////
//////////////////////////////////////////////////////////////////////
// C:\Temp\Obfuscated?.txt contains an obfuscated string
//     ? represents the fact that multiple files exist, (1 - 14)
//     Modify the "#define File?" line below to access different files
//     The ? number equates to the Obfuscated?.txt file that is opened
// The original string was XOR'd against a four (4) bit mask stored in
//     an unsigned char
// Shell code has been provided that already:
//     Safely read the file contents into a char array
//     Loops through each element of the char array
// Fill in the shell code, as documented, to brute force this
//     obfuscated string
// There are sections of this shell code that contain a comment block
//     specifying remaining code requirements.  Replace the comment
//     block with the code required.
// Visually scan the results for a human-readable string
//////////////////////////////////////////////////////////////////////

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#define BUFF_SIZE 256
#define MAX_MASKS 14
#define File1

int main(void)
{
	unsigned char cypherText[BUFF_SIZE] = { 0 }; // Stores the obfuscated text from the C:\Temp file
	unsigned char clearText[BUFF_SIZE] = { 0 }; // Stores the XOR'd cypherText 
	unsigned char xorMask = 0; // Stores the mask used to XOR the cypher text read from the file
	unsigned char inputChar = 255; // Temporarily stores file input character by character on its way to the cypher text array
	unsigned int i = 0; // Used to iterate through a loop
	unsigned int j = 0; // Used to iterate through a loop
	FILE * obfuscatedFile; // File pointer used to store the memory address of the opened Obfuscated?.txt file
#ifdef File1
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated1.txt", "r"); // Opens Obfuscated1.txt as read-only.  "#define File1" to access this file.
#endif
#ifdef File2
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated2.txt", "r"); // Opens Obfuscated2.txt as read-only.  "#define File2" to access this file.
#endif
#ifdef File3
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated3.txt", "r"); // Opens Obfuscated3.txt as read-only.  "#define File3" to access this file.
#endif
#ifdef File4
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated4.txt", "r"); // Opens Obfuscated4.txt as read-only.  "#define File4" to access this file.
#endif
#ifdef File5
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated5.txt", "r"); // Opens Obfuscated5.txt as read-only.  "#define File5" to access this file.
#endif
#ifdef File6
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated6.txt", "r"); // Opens Obfuscated6.txt as read-only.  "#define File6" to access this file.
#endif
#ifdef File7
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated7.txt", "r"); // Opens Obfuscated7.txt as read-only.  "#define File7" to access this file.
#endif
#ifdef File8
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated8.txt", "r"); // Opens Obfuscated8.txt as read-only.  "#define File8" to access this file.
#endif
#ifdef File9
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated9.txt", "r"); // Opens Obfuscated9.txt as read-only.  "#define File9" to access this file.
#endif
#ifdef File10
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated10.txt", "r"); // Opens Obfuscated10.txt as read-only.  "#define File10" to access this file.
#endif
#ifdef File11
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated11.txt", "r"); // Opens Obfuscated11.txt as read-only.  "#define File11" to access this file.
#endif
#ifdef File12
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated12.txt", "r"); // Opens Obfuscated12.txt as read-only.  "#define File12" to access this file.
#endif
#ifdef File13
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated13.txt", "r"); // Opens Obfuscated13.txt as read-only.  "#define File13" to access this file.
#endif
#ifdef File14
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated14.txt", "r"); // Opens Obfuscated14.txt as read-only.  "#define File14" to access this file.
#endif

	/* Verify the file is open */
	if (obfuscatedFile) // File pointer is NOT NULL
	{
		/* Stops at newlines (10), line feeds (13), End of File (EOF), empty characters (inputChar), and verifies there's room at the end for a newline and NUL termination */
		while (inputChar != 10 && inputChar != 13 && inputChar != EOF && inputChar && i < (BUFF_SIZE - 1))
		{
			inputChar = fgetc(obfuscatedFile); // Reads one character from the open file into inputChar
			cypherText[i] = inputChar; // Assigns inputChar into an element of the cypher text array
			i++; // Increments the counter used to iterate through the array
		}
		cypherText[BUFF_SIZE - 1] = '\0'; // Manually null terminates the string... for safety
	}
	else // File pointer is NULL
	{
		fprintf(stderr, "Error:  Unable to input file! \n"); // Prints and error statement
		return -1; // Ends main() and returns a value of -1 to indicate an error
	}

	/* Iterate all possible	XOR mask values for each cypher text array */
	for (xorMask = 1; xorMask <= MAX_MASKS; xorMask++) // Iterates through xorMask (1, 2, 3, ... MAX_MASKS).  (see "#define MAX_MASKS")
	{
		for (j = 0; j < strlen(cypherText); j++) // Iterates through all elements of the cypherText array
		{
			if (cypherText[j] != 0 && cypherText[j] != 10 && cypherText[j] != 13) // Skips XOR'ing NULL, newline, and line feed characters...
			{
				/**************************************************************
				Write a statement, or block of code, here that:
				    A. Performs a Bitwise XOR between the unsigned char 
					variable named "xorMask" and index "j" of the unsigned char
					array named "cypherText"
					B. Assign the result from the Bitwise XOR into index "j" of
					the unsigned char array named "clearText"
					C. Remove, or comment, the printf statement on the line
					below.  It was only intended as a placeholder for the
					statement, or block of code, you must write here.
				**************************************************************/
				printf("****\nReplace this statement with a Bitwise XOR\n****"); // ...and XORs all the rest against xorMASK, storing the result in the clearText array
			}
			else
			{
				/**************************************************************
				Write a statement, or block of code, here that:
				A. Assigns index "j" of the unsigned char array named
				"cypherText" into index "j" of the unsigned char array named 
				"clearText"
				NOTE:  No XOR is necessary here because we want to preserve
				any NULL, newline, or line feed characters.
				**************************************************************/
				printf("****\nReplace this statement with an assignment statement\n****");
			}
		}
		printf("\nMask #%d produced the string: \n\t%s", xorMask, clearText); // This line is printed once for each of the XOR masks attempted on the cypher text
	}

	/* Print the Cleartext */
//	puts(clearText1); // DEBUGGING
	/* Print the Cyphertext */
//	puts(cypherText); // DEBUGGING
	/* Close the open file */
	fclose(obfuscatedFile); // Closes the open file

	return 0;
}
#include <time.h>
#include <stdlib.h>

/*
 * Function: blackjack_init()
 *  initialize the random card generator the first time give_me_a_card() is called
 *
 * Programmer: SGT Lombardo
 *
 * Notes: We were having trouble initializing the rand() call multiple times.
 *	To ensure we only call srand() once, we implement a guard condition;
 *	blackjack_init() will only run srand() the first time.
 *  _blackjack_init is 0 if rand has not been initialized, 1 if not
 */
int _blackjack_init = 0;
void blackjack_init()
{
	if(!_blackjack_init)
	{
		srand(clock());
		_blackjack_init = 1;
	}
}

int give_me_a_card()
{
//	srand(time(NULL));					// Randomization attempt #1
//	time_t t;							// Randomization attempt #2
//	srand((unsigned)time(&t));			// Randomization attempt #2
//  Sleep(1);							// Randomization attempt #3
//	srand(clock());						// Randomization attempt #3

	//initialize the random number generator
	blackjack_init();

	int availableCards[13] = { 11,2,3,4,5,6,7,8,9,10,10,10,10 };
	int randomCard = availableCards[(rand() % 13)];
	return randomCard;
//	return 2; // DEBUGGING
}
#include <stdio.h>
#include "C:\Users\hark\Documents\Visual Studio 2013\Projects\x2a Control Flow\x2a Control Flow\blackjack.h"

int main(void)
{
	int blackjackTotal = give_me_a_card();
	int newCard = give_me_a_card();
	if (newCard == 11 && (newCard + blackjackTotal) > 21)
	{
		blackjackTotal += 1;
	}
	else
	{
		blackjackTotal += newCard;
	}

	printf("Your hand is at:  %d \n", blackjackTotal);

	while (blackjackTotal < 17)
	{
		printf("You hit.  ");
		newCard = give_me_a_card();
		if (newCard == 11 && (newCard + blackjackTotal) > 21)
		{
			blackjackTotal += 1;
		}
		else
		{
			blackjackTotal += newCard;
		}
		printf("Your new total is:  %d. \n", blackjackTotal);
	}
	if (blackjackTotal > 21)
	{
		printf("\n*************\n* YOU BUST! *\n*************\n");
	}

	return 0;
}
#include <stdio.h>
#include <ctype.h>

#define LOOP_EXAMPLE_3

int main(void)
{
	char userInput = 0;
	int letterCount[26] = { 0 };
	int i = 0;

	puts("Type a sentence and press enter.");

#ifdef LOOP_EXAMPLE_1
	do
	{
		userInput = getchar();
		userInput = toupper(userInput);

		if (userInput >= 65 && userInput <= 90)
		{
			letterCount[userInput - 65] += 1;
		}
	} while (userInput != '\n');
#endif

#ifdef LOOP_EXAMPLE_2
	do
	{
		userInput = toupper(getchar());

		if (userInput >= 65 && userInput <= 90)
		{
			letterCount[userInput - 65] += 1;
		}
	} while (userInput != '\n');
#endif

#ifdef LOOP_EXAMPLE_3
	do
	{
		if (userInput >= 65 && userInput <= 90)
		{
			letterCount[userInput - 65]++;
		}
	} while ((userInput = toupper(getchar())) != '\n');
#endif

	for (i = 0; i < 26; i++)
	{
		printf("%c:\t%d\n", i + 65, letterCount[i]);
	}

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// CAPSTONE LAB I.3.A-1 ///////////////////////////////////////////
////////////////////////////////////////////////// "Advanced String Theory" /////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The requirement for this lab is to define all of the EnglishFunctions.h functions as declared.
// The comment blocks for each function should clearly indicate what the requirements are for the function.
// There are a variety of appropriate solutions for many of these functions.
// Unit Test Code v1.c has been written to test all of the functions both individually and as a whole.
// This header definition file represents stub code that the students must define to complete this lab.
// Completion is indicated by passing all 311 tests.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
* FUNCTION:   int is_it_alphabet(signed char inputChar);
*
* ARGUMENTS:  inputChar is a single signed character that represents a single character
*                 that is tested as an alphabet letter.
*
* RETURNS:	  1 if inputChar is an alphabet character
*             0 if inputChar is not an alphabet character
*
* NOTES:      This function should not care if inputChar is uppercase or lowercase
*             The return value represents a boolean response without using a 'bool' data type
*             The letters a through z and A through Z represent "alphabet letters" for
*                 the purposes of this assignment.
*/
int is_it_alphabet(signed char inputChar)
{
	/* INSERT CODE HERE */

	return 90; // You may want to modify this return statement
}


/*
* FUNCTION:   int remove_non_letters(char * sentenceString);
*
* ARGUMENTS:  senteceString is expected to be a pointer to a null-terminated string
*
* RETURNS:	  Number of characters that were removed
*             -1 if senteceString is NULL
*
* NOTES:      The execution of this function must utilize is_it_alphabet() to determine
*                 whether or not a given char is an alphabet letter or not.
*             In addition to removing non-alphabet letters, this function will also remove any
*                 "blank space".
*             Most importantly, sentenceString will be null-terminated before the function returns
*/
int remove_non_letters(char * sentenceString)
{
	/* INSERT CODE HERE */

	return 90; // You may want to modify this return statement
}


/*
* FUNCTION:   int reverse_string(char * inputString, char * outputBuff, int inputPosition);
*
* ARGUMENTS:  inputString is expected to be a pointer to a null-terminated string
*             outputBuff is expected to be a pointer to a char array which will store the reversed string from inputString
*             inputPosition is the element of inputString that reverse_string() should reverse
*
* RETURNS:	  Number of characters that were reversed
*             -1 if either inputString or outputBuff is NULL
*             -2 if inputPosition is unrealistic
*                 Examples:
*                     inputPosition is negative
*                     inputPosition is out of the array's scope
*
* NOTES:      This function is recursive and, skipping over input validation, follows this algorithm:
*                 1. Reverse inputString[inputPosition] into outputBuff[]
*                 2. Call reverse_string() to reverse the next inputString[] position
*                 3. Count and return the total number of characters that were reversed from inputString[]
*                        into outputBuff[]
*             outputBuff is treated as the same length as inputString.  If outputBuff is longer, it
*                 will still be treated the same length as inputString.  Ideally, outputBuff and inputString
*                 are the exact same length.
*             Most importantly, outputBuff will be null-terminated before the function returns
*/
int reverse_string(char * inputString, char * outputBuff, int inputPosition)
{
	/* INSERT CODE HERE */

	return 90; // You may want to modify this return statement
}


/*
* FUNCTION:   int clear_a_buffer(char * fullBuff, int buffSize);
*
* ARGUMENTS:  fullBuff is expected to be a pointer to a char array
*             buffSize represents the dimension of fullBuff[]
*
* RETURNS:	  0 on success
*             -1 if fullBuff is NULL
*             -2 if buffSize is unrealistic
*                 Examples:
*                     buffSize is zero
*                     buffSize is negative
*
* NOTES:      This function 'zeroizes' all of the elements of fullBuff[buffSize]
*             fullBuff does not necessarily need to be a null-terminated string since the array's
*                 dimension is passed in as an argument (for safety)
*/
int clear_a_buffer(char * fullBuff, int buffSize)
{
	/* INSERT CODE HERE */

	return 90; // You may want to modify this return statement
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// CAPSTONE LAB I.3.A-1 ///////////////////////////////////////////
////////////////////////////////////////////////// "Advanced String Theory" /////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The requirement for this lab is to define all of the EnglishFunctions.h functions as declared.
// The comment blocks for each function should clearly indicate what the requirements are for the function.
// There are a variety of appropriate solutions for many of the EnglishFunctions.h functions.
// Unit Test Code v1.c has been written to test all of the functions both individually and as a whole, depending
//     on the #defines you uncomment (see pre-processing directives below).
// This header definition file represents stub code that the students must define to complete this lab.
// Completion is indicated by passing all 311 tests.
// No changes should be made to Unit Test Code v1.c either than to comment and/or uncomment #defined tests (see
//     pre-processing directives below).
// Changing the BUFF_SIZE, for the sake of testing, is also appropriate.
// While the EnglishFunctions.h functions can be used as stand-alone functions, and are tested as such, 
//     Unit Test Code v1.c also executes them together to reduce a null-terminated string into it's alphabet letters
//     and then to reverse those letters.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include "EnglishFunctions.h"

/*
 * This pre-processing directive determines whether the program will
 *     run tests and/or prompt the user for input depending on
 *     what #define statements are uncommented.
 */
#define AUTO_ALPHABET_CHECK // Runs tests on is_it_alphabet()
#define AUTO_REMOVE_CHARS // Runs tests on remove_non_letters()
#define AUTO_REVERSE_STRING // Runs tests on reverse_string()
#define AUTO_CLEAR_BUFFER // Runs tests on clear_a_buffer()
#define AUTO_FULL_PROGRAM // Runs tests on the entire program as a whole, incorporating all functions
//#define MANUAL_FULL_PROGRAM // Allows the programmer to manually provide input to test the response of the program as a whole
/*
 * Uncomment multiple #defines to multiple tests in a single run
 */

#define BUFF_SIZE 512

char sourceString[BUFF_SIZE] = { 0 };
char destinationBuff[BUFF_SIZE] = { 0 };

int main(void)
{
	/* Variables used by multiple testing sections */
	int i = 0;						// Iterating variable

	int totalUnitTestsPassed = 0;	// Counts the number of tests that have passed
	int totalUnitTestsRun = 0;		// Counts the number of tests that have been run, pass or fail
	int tempReturnValue = 0;		// Temporary holder for function return values
	int tempCount = 0;				// Temproary counter

#ifdef AUTO_ALPHABET_CHECK

	/*
	 *  This array represents the expected return value from is_it_alphabet()
	 *  This unit test will pass all available signed char values
	 *  The elements of of expectedAutoAlphabetCheckReturnValues[] correspond to the 255 available values in signed chars
	 *  The elements are shifted 127 so that the first element represents char value -127
	 *  The values of each element represents the expected return value for that input
	 *  expectedAutoAlphabetCheckReturnValues[i] == is_it_alphabet(i)
	 */
	int expectedAutoAlphabetCheckReturnValues[127 + 128] = { 0 }; // Zeroize an array with enough indices to represent the range of values for a signed char
	for (i = (127 + 65); i <= (127 + 90); i++) // Char values representing A - Z...
	{
		expectedAutoAlphabetCheckReturnValues[i] = 1; // ...should return TRUE from is_it_alphabet()
	}
	for (i = (127 + 97); i <= (127 + 122); i++) // Char values representing a - z...
	{
		expectedAutoAlphabetCheckReturnValues[i] = 1; // ...should return TRUE from is_it_alphabet()
	}
	
	int autoAlphabetCheckTestsPassed = 0; // Stores the number of tests is_it_alphabet() has passed
	int autoAlphabetCheckTestsRun = 0; // Stores the number of tests is_it_alphabet() has run through

	printf("\n************************\n");
	printf("TESTING is_it_alphabet()\n");
	printf("************************\n");

	for (i = -127; i <= 127; i++) // Loops through all available values of a signed char
	{
		autoAlphabetCheckTestsRun++; // Keeps track of how many is_it_alphabet() tests have been run
		totalUnitTestsRun++; // Keeps track of how many total tests have been run

		if (is_it_alphabet((signed char)i) == expectedAutoAlphabetCheckReturnValues[i + 127]) // If the is_it_alphabet() return value matches the expected return value...
		{
			autoAlphabetCheckTestsPassed++; // ...record the fact that a is_it_alphabet() test has passed and...
			totalUnitTestsPassed++; // ...record the fact that one of the overall tests has been passed.
		}
	}

	printf("%d tests were run on is_it_alphabet() \n%d tests were passed.\n", autoAlphabetCheckTestsRun, autoAlphabetCheckTestsPassed);
#endif

#ifdef AUTO_REMOVE_CHARS

	/* SAMPLE INPUT */
	char autoRemoveCharString1[BUFF_SIZE] = { "NoSpaces" };							// No non-letters
	char autoRemoveCharString2[BUFF_SIZE] = { "Normal spaces" };					// One non-letter
	char autoRemoveCharString3[BUFF_SIZE] = { "This is a normal sentence." };		// A sentence
	char autoRemoveCharString4[BUFF_SIZE] = { "!@#$%^&*()_+" };						// All non-letters
	char autoRemoveCharString5[BUFF_SIZE] = { "=-+                    +-=" };		// Mostly spaces
	char autoRemoveCharString6[BUFF_SIZE] = { "Password: P@$$w0rd!" };				// Everything combined				
	char * autoRemoveCharString7 = NULL;												// NULL pointer
	char autoRemoveCharString8[BUFF_SIZE] = { "Hidden string? This is hidden!" };	// String hidden behind a manual nul terminator
	autoRemoveCharString8[14] = 0;													// Manual nul terminator

	char * autoRemoveCharStrings[] = { autoRemoveCharString1, autoRemoveCharString2, autoRemoveCharString3, autoRemoveCharString4, autoRemoveCharString5, autoRemoveCharString6, autoRemoveCharString7, autoRemoveCharString8 };


	/* EXPECTED RESULTS */
	char autoRemoveCharStringResult1[BUFF_SIZE] = { "NoSpaces" };						// No non-letters
	char autoRemoveCharStringResult2[BUFF_SIZE] = { "Normalspaces" };					// One non-letter
	char autoRemoveCharStringResult3[BUFF_SIZE] = { "Thisisanormalsentence" };			// A sentence
	char autoRemoveCharStringResult4[BUFF_SIZE] = { "" };								// All non-letters
	char autoRemoveCharStringResult5[BUFF_SIZE] = { "" };								// Mostly spaces
	char autoRemoveCharStringResult6[BUFF_SIZE] = { "PasswordPwrd" };					// Everything combined				
	char * autoRemoveCharStringResult7 = NULL;											// NULL pointer
	char autoRemoveCharStringResult8[BUFF_SIZE] = { "Hiddenstring" };					// String hidden behind a manual nul terminator
	
	char * autoRemoveCharStringResults[] = { autoRemoveCharStringResult1, autoRemoveCharStringResult2, autoRemoveCharStringResult3, autoRemoveCharStringResult4, autoRemoveCharStringResult5, autoRemoveCharStringResult6, autoRemoveCharStringResult7, autoRemoveCharStringResult8 };


	/* EXPECTED RETURN VALUES */
	tempReturnValue = 0;
	int autoRemoveCharReturnValues[] = { 0, 1, 5, 12, 26, 7, -1, 2 };					// Parallel array of expected return values

	int autoRemoveCharsTestsPassed = 0;
	int autoRemoveCharsTestsRun = 0;

	printf("\n****************************\n");
	printf("TESTING remove_non_letters()\n");
	printf("****************************\n");

	for (i = 0; i < (sizeof(autoRemoveCharStrings) / sizeof(autoRemoveCharStrings[0])); i++)
	{
		printf("TEST #%d:\n", i + 1);
		printf("\tInput String:\t");
		if (autoRemoveCharStrings[i])
		{
			puts(autoRemoveCharStrings[i]);
		}
		else
		{
			printf("NULL\n");
		}

		printf("\tReturn Value:\t");
		autoRemoveCharsTestsRun++;
		totalUnitTestsRun++;
		if (remove_non_letters(autoRemoveCharStrings[i]) == autoRemoveCharReturnValues[i])
		{
			printf("PASS\n");
			autoRemoveCharsTestsPassed++;
			totalUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		printf("\tOutput String:\t");
		autoRemoveCharsTestsRun++;
		totalUnitTestsRun++;
		if (autoRemoveCharStrings[i])
		{
			puts(autoRemoveCharStrings[i]);
		}
		else
		{
			printf("NULL\n");
		}
		printf("\tString Test:\t");
		if (autoRemoveCharStrings[i] && autoRemoveCharStringResults[i])
		{
			tempReturnValue = strncmp(autoRemoveCharStrings[i], autoRemoveCharStringResults[i], BUFF_SIZE);
		}
		else
		{
			tempReturnValue = 0;
		}
		if (tempReturnValue)
		{
			printf("FAIL\n");
		}
		else
		{
			printf("PASS\n");
			autoRemoveCharsTestsPassed++;
			totalUnitTestsPassed++;
		}
	}

	printf("%d tests were run on remove_non_letters() \n%d tests were passed.\n", autoRemoveCharsTestsRun, autoRemoveCharsTestsPassed);

#endif

#ifdef AUTO_REVERSE_STRING

	/* SAMPLE INPUT */
	const char autoReverseStringTest1[BUFF_SIZE] = { "This is a test string." };
	const char autoReverseStringTest2[BUFF_SIZE] = { "Test." };
	const char autoReverseStringTest3[BUFF_SIZE] = { "1" };
	const char autoReverseStringTest4[BUFF_SIZE] = { "!@#$%^&*()_+-=" };
	const char autoReverseStringTest5[BUFF_SIZE] = { 0 };
	const char autoReverseStringTest6[BUFF_SIZE] = { "I.3. I declare a thumb war!" };
	const char * autoReverseStringTest7 = NULL;
	char autoReverseStringTest8[BUFF_SIZE] = { "Real string? Hidden string!" };
	autoReverseStringTest8[12] = 0;
	const char autoReverseStringTest9[BUFF_SIZE] = { "Nothing" };
	const char autoReverseStringTest10[BUFF_SIZE] = { "a" };

	const char * autoReverseStringTestArray[] = { autoReverseStringTest1, autoReverseStringTest2, autoReverseStringTest3, autoReverseStringTest4, autoReverseStringTest5, autoReverseStringTest6, autoReverseStringTest7, autoReverseStringTest8, autoReverseStringTest9, autoReverseStringTest10 };

	/* ARRAY ELEMENT INPUT */
	const int autoReverseStringPositions[] = { 0, 0, 1, 2, 0, 5, 5, 0, -1, 0 };
	
	/* EXPECTED RETURN VALUES */
	const int autoReverseStringReturnValues[] = { 22, 5, -2, 12, -2, 22, -1, 12, -2, 1 };

	/* EXPECTED OUTPUT */
	const char autoReverseStringResult1[BUFF_SIZE] = { ".gnirts tset a si sihT" };
	const char autoReverseStringResult2[BUFF_SIZE] = { ".tseT" };
	const char autoReverseStringResult3[BUFF_SIZE] = { "1" };
	const char autoReverseStringResult4[BUFF_SIZE] = { "=-+_)(*&^%$#" };
	const char autoReverseStringResult5[BUFF_SIZE] = { 0 };
	const char autoReverseStringResult6[BUFF_SIZE] = { "!raw bmuht a eralced I" };
	const char * autoReverseStringResult7 = NULL;
	char autoReverseStringResult8[BUFF_SIZE] = { "?gnirts laeR" };
	const char autoReverseStringResult9[BUFF_SIZE] = { "Nothing" }; 
	const char autoReverseStringResult10[BUFF_SIZE] = { "a" };

	const char * autoReverseStringResultArray[] = { autoReverseStringResult1, autoReverseStringResult2, autoReverseStringResult3, autoReverseStringResult4, autoReverseStringResult5, autoReverseStringResult6, autoReverseStringResult7, autoReverseStringResult8, autoReverseStringResult9, autoReverseStringResult10 };

	int autoReverseStringTestsPassed = 0;
	int autoReverseStringTestsRun = 0;
	tempReturnValue = 0;

	printf("\n***********************\n");
	printf("TESTING STRING REVERSAL\n");
	printf("***********************\n");

	for (i = 0; i < (sizeof(autoReverseStringTestArray) / sizeof(autoReverseStringTestArray[0])); i++)
	{
		printf("TEST #%d\n", i + 1);

		/* Testing remove_non_letters() return value */

		printf("\tInput String:\t\t\t");

		autoReverseStringTestsRun++;
		totalUnitTestsRun++;

		if (autoReverseStringTestArray[i])
		{
			puts(autoReverseStringTestArray[i]);
			strcpy(sourceString, autoReverseStringTestArray[i]);
			tempReturnValue = reverse_string(sourceString, destinationBuff, autoReverseStringPositions[i]);
		}
		else
		{
			printf("NULL\n");
			*sourceString = NULL;
			tempReturnValue = reverse_string(NULL, NULL, 0);
		}

		printf("\tStarting at index: \t\t%d \n", autoReverseStringPositions[i]);

		printf("\tReverse String Return Value:\t");
		if (tempReturnValue == autoReverseStringReturnValues[i])
		{
			printf("PASS\n");
			autoReverseStringTestsPassed++;
			totalUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		autoReverseStringTestsRun++;
		totalUnitTestsRun++;
		printf("\tOutput String:\t\t\t");

		if (autoReverseStringResultArray[i] && destinationBuff)
		{
			puts(destinationBuff);
			tempReturnValue = strcmp(autoReverseStringResultArray[i], destinationBuff);
		}
		else
		{
			printf("NULL\n");
		}
		memset(destinationBuff, 0, sizeof(char) * (BUFF_SIZE - 1));
		
		printf("\tString Result:\t\t\t");
		if (!tempReturnValue)
		{
			printf("PASS\n");
			autoReverseStringTestsPassed++;
			totalUnitTestsPassed++;
		}
		else if (autoReverseStringReturnValues[i] < 0)
		{
			printf("SKIPPED\n");
			autoReverseStringTestsRun--;
			totalUnitTestsRun--;
		}
		else
		{
			printf("FAIL\n");
		}
	}

	printf("%d tests were run on reverse_string(). \n%d tests were passed.\n", autoReverseStringTestsRun, autoReverseStringTestsPassed);

#endif

#ifdef AUTO_CLEAR_BUFFER

#define DIFF_BUFF_SIZE 1337

	char differentSizedBuffer[DIFF_BUFF_SIZE] = { 0 };
	int autoClearBufferTestsPassed = 0;
	int autoClearBufferTestsRun = 0;
	char tempChar = ~0 ;

	for (i = 0; i < DIFF_BUFF_SIZE; i++)
	{
		differentSizedBuffer[i] = '!'; // Fill the end of the destinationBuff with gunk
	}

	printf("\n************************\n");
	printf("TESTING clear_a_buffer()\n");
	printf("************************\n");

	printf("TEST #1 (Larger Buffer):\n");
	printf("\tReturn Value:\t");
	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	tempReturnValue = clear_a_buffer(differentSizedBuffer, DIFF_BUFF_SIZE);
	
	if (tempReturnValue)
	{
		printf("FAIL\n");
	}
	else
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}

	printf("\tBuffer Status:\t");
	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	/*
	*  <disclaimer> The following code *should* be extracted into a function with prototype...
	*  int check_a_buffer(char * targetBuff, int buffSize); // Returns the number of non-null chars found
	*  This code was *not* extracted in an attempt to avoid performing the students work for them
	*/
	tempCount = 0;
	for (i = 0; i < DIFF_BUFF_SIZE; i++)
	{
		if (differentSizedBuffer[i] & tempChar)
		{
			tempCount++;
		}
	}
	/* </disclaimer> */

	if (tempCount)
	{
		printf("FAIL\n");
	}
	else
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}

	printf("TEST #2 (Normal Buffer):\n");
	printf("\tReturn Value:\t");

	/* Fill destinationBuff[] according to its size */
	if (BUFF_SIZE >= 8)
	{
		for (i = 0; i < (BUFF_SIZE - 8); i += 7)
		{
			destinationBuff[i] = '9';
			destinationBuff[i + 1] = '0';
			destinationBuff[i + 2] = ' ';
			destinationBuff[i + 3] = 'I';
			destinationBuff[i + 4] = 'O';
			destinationBuff[i + 5] = 'S';
			destinationBuff[i + 6] = ' ';
			destinationBuff[i + 7] = 0;
		}
		destinationBuff[BUFF_SIZE - 1] = 0; // Manual null terminator (for safety)
	}
	else if (BUFF_SIZE >= 2)
	{
		destinationBuff[0] = '?';
		destinationBuff[1] = 0;
	}
	else
	{
		destinationBuff[0] = 0; // The destinationBuff must only have one element so it's set to 0 (for safety)
	}

	/* Clear destinationBuff[] */
	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	tempReturnValue = clear_a_buffer(destinationBuff, BUFF_SIZE);

	/* Check clear_a_buffer()'s return value */
	if (tempReturnValue)
	{
		printf("FAIL\n");
	}
	else
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}

	printf("\tBuffer Status:\t");
	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	/*
	*  <disclaimer> The following code *should* be extracted into a function with prototype...
	*  int check_a_buffer(char * targetBuff, int buffSize); // Returns the number of non-null chars found
	*  This code was *not* extracted in an attempt to avoid performing the students work for them
	*/
	tempCount = 0;
	for (i = 0; i < BUFF_SIZE; i++)
	{
		if (destinationBuff[i] & tempChar)
		{
			tempCount++;
		}
	}
	/* </disclaimer> */
	
	/* Test the status of destinationBuff[] */
	if (tempCount)
	{
		printf("FAIL\n");
	}
	else
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}
	tempReturnValue = clear_a_buffer(destinationBuff, BUFF_SIZE);


	/*
	 *  <disclaimer> The following code *should* be extracted into a function with prototype...
	 *  int check_a_buffer(char * targetBuff, int buffSize); // Returns the number of non-null chars found
	 *  This code was *not* extracted in an attempt to avoid performing the students work for them
	 */
	tempCount = 0;
	for (i = 0; i < BUFF_SIZE; i++)
	{
		if (destinationBuff[i] & tempChar)
		{
			tempCount++;
		}
	}
	/* </disclaimer> */

	printf("TEST #3 (Abnormal Buffer Size of 0):\n");
	printf("\tReturn Value:\t");

	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	tempReturnValue = clear_a_buffer(destinationBuff, 0);

	if (-2 == tempReturnValue)
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}
	else
	{
		printf("FAIL (expected -2 but received %d)\n", tempReturnValue);
	}
	tempReturnValue = 0;

	printf("\tBuffer Status:\tSKIPPED\n");


	printf("TEST #4 (Very Abnormal Buffer Size of -999):\n");
	printf("\tReturn Value:\t");

	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	tempReturnValue = clear_a_buffer(destinationBuff, -999);

	if (-2 == tempReturnValue)
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}
	else
	{
		printf("FAIL (expected -2 but received %d)\n", tempReturnValue);
	}
	tempReturnValue = 0;

	printf("\tBuffer Status:\tSKIPPED\n");

	printf("TEST #5 (NULL Pointer):\n");
	printf("\tReturn Value:\t");

	autoClearBufferTestsRun++;
	totalUnitTestsRun++;
	tempReturnValue = clear_a_buffer(NULL, BUFF_SIZE);

	if (-1 == tempReturnValue)
	{
		printf("PASS\n");
		autoClearBufferTestsPassed++;
		totalUnitTestsPassed++;
	}
	else
	{
		printf("FAIL (expected -1 but received %d)\n", tempReturnValue);
	}
	tempReturnValue = 0;

	printf("\tBuffer Status:\tSKIPPED\n");

	printf("%d tests were run on clear_a_buffer(). \n%d tests were passed.\n", autoClearBufferTestsRun, autoClearBufferTestsPassed);

#endif

#ifdef AUTO_FULL_PROGRAM

	const char autoFullProgramTest1[BUFF_SIZE] = { "This is a test string." };
	const char autoFullProgramTest2[BUFF_SIZE] = { "Test." };
	const char autoFullProgramTest3[BUFF_SIZE] = { "1" };
	const char autoFullProgramTest4[BUFF_SIZE] = { "!@#$%^&*()_+-=" };
	const char autoFullProgramTest5[BUFF_SIZE] = { "0" };
	const char autoFullProgramTest6[BUFF_SIZE] = { "I.3. I declare a thumb war!" };
	const char * autoFullProgramTest7 = NULL;
	char autoFullProgramTest8[BUFF_SIZE] = { "Real string? Hidden string!" };
	autoFullProgramTest8[12] = 0;

	const char * autoFullProgramTestArray[] = { autoFullProgramTest1, autoFullProgramTest2, autoFullProgramTest3, autoFullProgramTest4, autoFullProgramTest5, autoFullProgramTest6, autoFullProgramTest7, autoFullProgramTest8 };

	const int autoFullProgramRemoveNonLetterReturnValues[] = { 5, 1, 1, 14, 1, 9, -1, 2 };
	const int autoFullProgramClearBufferReturnValues[] = { 0, 0, 0, 0, 0, 0, -1, 0 };

	const char autoFullProgramResult1[BUFF_SIZE] = { "gnirtstsetasisihT" };
	const char autoFullProgramResult2[BUFF_SIZE] = { "tseT" };
	const char autoFullProgramResult3[BUFF_SIZE] = { 0 };
	const char autoFullProgramResult4[BUFF_SIZE] = { 0 };
	const char autoFullProgramResult5[BUFF_SIZE] = { 0 };
	const char autoFullProgramResult6[BUFF_SIZE] = { "rawbmuhtaeralcedI" };
	const char * autoFullProgramResult7 = NULL;
	char autoFullProgramResult8[BUFF_SIZE] = { "gnirtslaeR" };
	
	const char * autoFullProgramResultArray[] = { autoFullProgramResult1, autoFullProgramResult2, autoFullProgramResult3, autoFullProgramResult4, autoFullProgramResult5, autoFullProgramResult6, autoFullProgramResult7, autoFullProgramResult8 };
	
	int autoFullProgramTestsPassed = 0;
	int autoFullProgramTestsRun = 0;
//	int tempReturnValue = 0;

	printf("\n*************************\n");
	printf("TESTING ALL FUNCTIONALITY\n");
	printf("*************************\n");

	for (i = 0; i < (sizeof(autoFullProgramTestArray) / sizeof(autoFullProgramTestArray[0])); i++)
	{
		printf("TEST #%d\n", i + 1);
		
		/* Testing remove_non_letters() return value */
		
		printf("\tInput String:\t\t\t\t");
		
		autoFullProgramTestsRun++;
		totalUnitTestsRun++;

		if (autoFullProgramTestArray[i])
		{
			puts(autoFullProgramTestArray[i]);
			strcpy(sourceString, autoFullProgramTestArray[i]);
			tempReturnValue = remove_non_letters(sourceString);
		}
		else
		{
			printf("NULL\n");
			*sourceString = NULL;
			tempReturnValue = remove_non_letters(NULL);
		}
		
		printf("\tRemove Non-Letters Return Value:\t");
		if (tempReturnValue == autoFullProgramRemoveNonLetterReturnValues[i])
		{
			printf("PASS\n");
			autoFullProgramTestsPassed++;
			totalUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		/* Testing clear_a_buffer() return values */
		/* NOTE:  Not yet testing the -2 return value */
		printf("\tClear A Buffer Return Value:\t\t");
		autoFullProgramTestsRun++;
		totalUnitTestsRun++;
		if (autoFullProgramTestArray[i])
		{
			tempReturnValue = clear_a_buffer(destinationBuff, BUFF_SIZE);
		}
		else
		{
			tempReturnValue = clear_a_buffer(NULL, BUFF_SIZE);
		}

		if (tempReturnValue == autoFullProgramClearBufferReturnValues[i])
		{
			printf("PASS\n");
			autoFullProgramTestsPassed++;
			totalUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		/* Testing reverse_string return value */
		tempReturnValue = reverse_string(sourceString, destinationBuff, 0);
		printf("\tOutput String:\t\t\t\t");
		puts(destinationBuff);
	}

	


	printf("%d tests were run on the entire header. \n%d tests were passed.\n", autoFullProgramTestsRun, autoFullProgramTestsPassed);

#endif

#ifdef MANUAL_FULL_PROGRAM

	
	int originalStringLength = 0;
	int numCharsRemoved = 0;
	int buffClearReturnValue = 0;
	int numCharsReversed = 0;
	int sourceStringLen = 0;
	int testStringPosition = 0;
	char testBuff[BUFF_SIZE] = { 0 };
	int compareResultToExpectedOutput = 0;

	printf("\n\nEnter a string.  Any newline characters will be removed. \nThis program will attempt to invoke the EnglishFunction header functions to: \n");
	printf("\t1. Remove any non-alphabet characters (in place) \n\t2. Clear the destination buffer (for safety) \n");
	printf("\t3. Reverse the alphabet characters into the destination buffer. \n\n");
	
	fgets(sourceString, BUFF_SIZE, stdin);
	for (i = 0; i < BUFF_SIZE; i++)
	{
		if (10 == sourceString[i])
		{
			sourceString[i] = 0;
			break;
		}
	}

	printf("\n**********************************\n");
	printf("MANUALLY TESTING ALL FUNCTIONALITY\n");
	printf("**********************************\n");

	printf("Original string: \t\t\t%s\n", sourceString);
	numCharsRemoved = remove_non_letters(sourceString);
	printf("Number of characters removed: \t\t%d\n", numCharsRemoved);
	buffClearReturnValue = clear_a_buffer(destinationBuff, BUFF_SIZE);
	tempCount = 0;
	for (i = 0; i < BUFF_SIZE; i++)
	{
		if (destinationBuff[i] != 0)
		{
			tempCount++;
		}
	}
	printf("Destination buffer cleared? \n\tReturn Value:\t%d \n\tReality:\t", tempReturnValue);
	if (0 == buffClearReturnValue && 0 == tempCount)
	{
		printf("Yes\n"); 
	}
	else
	{
		printf("NO\n");
	}

	numCharsReversed = reverse_string(sourceString, destinationBuff, 0);
	
	printf("Number of characters reversed: \n\tReturn Value:\t%d \n\tReality:\t%d\n", numCharsReversed, strlen(destinationBuff));

	printf("Modified string:\t\t\t%s\n", destinationBuff);

	sourceStringLen = strlen(sourceString);
	testStringPosition = sourceStringLen - 1;
	
	for (i = 0; i < sourceStringLen; i++)
	{
		testBuff[testStringPosition] = sourceString[i];
		testStringPosition--;
	}
	compareResultToExpectedOutput = strcmp(destinationBuff, testBuff);

	printf("String properly reversed?\t\t");
	if (compareResultToExpectedOutput)
	{
		printf("NO\n");
	}
	else
	{
		printf("Yes\n");
	}

#endif

	if (totalUnitTestsRun > 0)
	{
		printf("\n\nA total of %d automatic tests were run on EnglishFunctions.h \n%d tests passed.\n", totalUnitTestsRun, totalUnitTestsPassed);
	}
	else
	{
#ifndef MANUAL_FULL_PROGRAM
		printf("\nDid you forget to uncomment at least one of the #define'd tests?\n");
#endif
	}

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// DEMONSTRATION LAB I.3.A-1 /////////////////////////////
///////////////////////////////////// "Newline Records" //////////////////////////////////
///////////////////////////////////// Student Shell Code /////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// Do not modify main()
// Write the code body for the following function prototype:
//     int remove_newline(char * buffer);
// This function takes a pointer to a null-terminated string as a parameter
// This function must replace all newline characters with spaces
// The return value should represent the number of newline characters that were changed
//     with the following exceptions:
//         Return ERR_NULL_POINTER if the pointer to the string (buffer) is NULL
//         Return ERR_NONE_FOUND if no newlines are found
// Do not process a NULL string pointer (buffer)
//////////////////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <string.h>
#define ERR_NULL_POINTER -1		// Error:  Pointer passed was NULL
#define ERR_NONE_FOUND 0		// Error:  Didn't find any newlines


int remove_newline(char * buffer);

int main(void)
{
	/* FUNCTION INPUT ARRAYS */
	char beforeString1[] = { "If debugging is the process of removing software bugs, then programming must be the process of putting them in.  -Edsger Dijkstra" }; // No newlines
	char beforeString2[] = { "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.\n-Martin Golding" }; // One newline
	char beforeString3[] = { "Debugging is twice as hard as writing the code in the first place.\nTherefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.\n-Brian W. Kernighan" }; // Two newlines
	char beforeString4[] = { "C makes it easy to shoot yourself in the foot;\nC++ makes it harder, but when you do,\nit blows away your whole leg.\n-Bjarne Stroustrup\n" }; // Four newlines
	char beforeString5[] = { "Talk\nis\ncheap.\nShow\nme\nthe\ncode.\n-Linus\nTorvalds\n" }; // Multiple newlines
	char * beforeString6 = NULL; // NULL Pointer
	char * beforeStringArray[] = { beforeString1, beforeString2, beforeString3, beforeString4, beforeString5, beforeString6 };

	/* FUNCTION OUTPUT COMPARISON */
	char afterString1[] = { "If debugging is the process of removing software bugs, then programming must be the process of putting them in.  -Edsger Dijkstra" }; // No newlines
	char afterString2[] = { "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. -Martin Golding" }; // One newline
	char afterString3[] = { "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it. -Brian W. Kernighan" }; // Two newlines
	char afterString4[] = { "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do, it blows away your whole leg. -Bjarne Stroustrup " }; // Four newlines
	char afterString5[] = { "Talk is cheap. Show me the code. -Linus Torvalds " }; // Multiple newlines
	char * afterString6 = NULL;
	char * afterStringArray[] = { afterString1, afterString2, afterString3, afterString4, afterString5, afterString6 };

	/* STRCMP FUNCTION EXPECTED RESULTS */
	int expectedFunctionResults[] = { ERR_NONE_FOUND, 1, 2, 4, 9, ERR_NULL_POINTER }; // Parallel array which holds expected return values of remove_newline() for given input

	int i = 0; // Iterating variable
	int tempResults = 0; // Temporarily holds function results until comparison can be done

	/* TEST RUNS */
	for (i = 0; i < sizeof(beforeStringArray) / sizeof(*beforeStringArray); i++)
	{
		/* Test Run Header */
		printf("\nTEST #%d \n", i + 1);
		printf("__________________________________________________\n");

		/* Simultaneously modifies the strings and temporarily stores the return value */
		tempResults = remove_newline(beforeStringArray[i]);

		/* Verifies the return value of remove_newline() */
		printf("\tReturn Results:  ");
		if (expectedFunctionResults[i] == tempResults)
		{
			printf("\tPASS\n");
		}
		else
		{
			printf("\tFAIL\n");
		}

		/* Verifies remove_newline() performed adequately */
		printf("\tComparison Results:  ", tempResults);
		if (beforeStringArray[i]) // strcmp() doesn't like NULL pointers
		{
			/* Temporarily stores the retun value of strcmp() */
			tempResults = strcmp(beforeStringArray[i], afterStringArray[i]);
			if (!tempResults) // strcmp() returns 0 if the two strings match
			{
				printf("\tPASS\n"); // 0
			}
			else
			{
				printf("\tFAIL\n"); // 1
			}
		}
		else
		{
			printf("\tNo string present.\n"); // strcmp() doesn't like NULL pointers.  No comparison necessary.
		}
	}

	return 0;
}

/*
 * FUNCTION:   int remove_newline(char * buffer)
 *
 * ARGUMENTS:  buffer is a pointer to a null-terminated string
 *             The string is passed by reference and modified in place
 *
 * RETURNS:	   Number of newline characters that were replaced
 *             ERR_NULL_POINTER if buffer == NULL
 *             ERR_NONE_FOUND if no newlines are found
 *
 * NOTES:      This function replaces all newlines with spaces
 */
int remove_newline(char * buffer)
{

	/* INSERT CODE HERE */

}
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// DEMONSTRATION LAB I.3.A-2 ///////////////////////////////
/////////////////////////////////////// Variable Scope ////////////////////////////////////
///////////////////////////////// "I'm thinking of a number..." ///////////////////////////
////////////////////////////////////// Student Shell Code /////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// The objective of this lab is to take user input (a "magic number") and to write a
//     function that will "randomize" numbers until it "guesses" the "magic number".
//     The function should not choose "randomized" numbers as "guesses" if those "guesses"
//     have already been used.  A macro named MAX_GUESS is used to establish the range
//     of "magic numbers" (1 to MAX_GUESS).  Main() and the function will not directly
//     communicate the "guesses".  Instead, they'll use the global uint8_t array to 
//     determine if the function has guessed the "magic number".  The function will update
//     the global array with "guesses" and main() will watch the global array to determine
//     if the "magic number" has been guessed.
//
// main() should:
//     1. Take input
//     2. Verify that input falls between 1 and MAX_GUESS (inclusive)
//     3. Watch the global array to see if the "magic number" has been guessed
//     4. Loop the function until the "magic number" has been guessed in the array
//     5. Print the total number of randomizations the function performed once the "magic
//         number is guessed
//
// guess_a_number() should:
//     1. Randomize a number between 1 and MAX_SIZE
//     2. Increment the variable storing the total number of randomizations
//     3. Check the global array to see if that number has already been "guessed"
//         3.a. If it's been guessed already, go back to Step #1
//         3.b. If it hasn't been guessed, modify the global array to indicate
//             it's been guessed.
//     4. Return the number of times the function has "randomized" a number
//         NOTE:  "Randomizing" a number is different than "guessing" a number because
//             some "randomized" numbers have already been "guessed"
///////////////////////////////////////////////////////////////////////////////////////////

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <windows.h>
#include <stdint.h>
/* The following MACRO determines the available range of "magic numbers" and, subsequently, the "guesses" */
#define MAX_GUESS 100 // Available numbers range from 1 to MAX_GUESS

/* Declare a global uint8_t array with a dimension equal to (MAX_GUESS + 1) and initialize it to zero (0) */

uint8_t guess_a_number(void); // Function prototype

int main(void)
{

	/* INSERT CODE HERE */

	return 0;
}

/*
* FUNCTION:   uint8_t guess_a_number(void)
*
* ARGUMENTS:  This function takes no parameters although it *should* update the previous_guesses global array
*
* RETURNS:	  Total number of "randomizations" 
*             NOTE:  One "randomization" is one function call to rand() while one "guess" is one update to
*                 previous_guesses[]
*
* NOTES:      This function randomizes numbers from 1 to MAX_SIZE.
*             Each randomized number is checked against the previous_guesses global array.
*             If the value had already been guessed, the function will randomize another number
*             If the value had not already been guessed, this function will update the global array
*/
uint8_t guess_a_number(void)
{

	/* INSERT CODE HERE */

}
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// DEMONSTRATION LAB I.3.A-3 ///////////////////////////////
//////////////////////////////////////// Header Files /////////////////////////////////////
////////////////////////////////////// "String Theory" ////////////////////////////////////
////////////////////////////////////// Instructor Solution ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// The objective of this lab is to declare and define a header "MyStringHeader.h"
// MyStringHeader should include a function of prototype:
// int print_the_count(char * inputString, int strLen);
// The requirements for the prototype are included below in the function documentation box
// The students definition of the prototype will be tested by instructor-written
//     test code (see: Unit Test Code 1.c)
// When students are done declaring and defining the header, they are to add
//     "Unit Test Code 1.c" to their project and debug.
// Unit Test Code 1.c utilizes macros to run some, all, or none of the available
//     unit tests.  Comment out the Unit Test Code 1.c macros to manage which tests
//     are run. 
///////////////////////////////////////////////////////////////////////////////////////////

#ifndef ERR_NULL_POINTER
#define ERR_NULL_POINTER -1
#else 
#undef ERR_NULL_POINTER
#define ERR_NULL_POINTER -1
#endif

#ifndef ERR_INVALID_LENGTH
#define ERR_INVALID_LENGTH -2
#else 
#undef ERR_INVALID_LENGTH
#define ERR_INVALID_LENGTH -2
#endif

/*
 * FUNCTION:   int print_the_count(char * inputString, int strLen)
 *
 * ARGUMENTS:  inputString is a pointer to a character array (see: string) and is *NOT* 
 *                 guaranteed to be NULL terminated.  This is why the length of the 
 *                 string is also passed as an argument.
 *             strLen is the length of the inputString.  strLen is required as a safety
 *                 measure since inputString is not guaranteed to be null-terminated.
 *                 strLen does not need to be long enough to include any null character,
 *                 even if there was one.
 *
 * RETURNS:    # of alphabet letters found in inputString
 *             ERR_NULL_POINTER is inputString is NULL
 *             ERR_INVALID_LENGTH is strLen is unreasonable (zero or less)
 *
 * NOTES:      Not only does this function return the total number of alphabet letters
 *                 that were counted, it should also print a table of letters from the
 *                 string with their count.  Do not print any letters that were not
 *                 found in inputString.
 *             The "case" of the letter (upper or lower) should not matter for the count.
 *                 There are different ways to ignore the case of a char.  It is up
 *                 to the student to determine the method.
 */
int print_the_count(char * inputString, int strLen)
{
	int theCount = 0; // Running count of upper case letters
	int i = 0; // Incrementing variable
	char oneCharacter = 0; // Temp storage to change each string character to an upper case character one by one
	/*
	 *  An array to store the by-letter-count of upper case letters
	 *  Each element represents the count of an upper case letter
	 *  Index 0 represents the letter A
	 *  IndeI.25 represents the letter Z
	 */
	int countTheLetters[26] = { 0 }; 

	if (!inputString) // Checks for NULL pointer
	{
		return ERR_NULL_POINTER;
	}
	else if (strLen <= 0) // Checks for unrealistic input
	{
		return ERR_INVALID_LENGTH;
	}
	else
	{
		/* 
		 *  COUNT THE STRING'S ALPHABET LETTERS
		 */ 
		for (i = 0; i < strLen; i++)
		{
			oneCharacter = toupper(inputString[i]); // Changes the string to upper case characters
			if (oneCharacter >= 65 && oneCharacter <= 90) // If the character matches A-Z...
			{
				countTheLetters[oneCharacter - 65]++;	// ...Add one to the count of this particular upper case letter...
				theCount++;								// ...and increment the running count of upper case letters
			}
		}

		/* 
		 *  PRINT THE ALPHABET CHART 
		 */
		// Table title
		printf("************\n");
		printf("LETTER COUNT\n");
		printf("************\n");
		for (i = 65; i <= 90; i++) // Check the decimal value of each upper case letter
		{
			if (countTheLetters[i - 65] > 0) // If the value is greater than zero...
			{
				printf("%c\t%d\n", i, countTheLetters[i - 65]); // ...print a table entry for this letter
			}
		}
	}

	return theCount; // Return the running count of upper case letters
}

/*
 *  NOTE:
 *  This code was incomplete at the time it was transferred from the development laptop
 *  to it's storage location on the NIPRNET.  Some code was added without the aid of an IDE.
 *  The conditional preprocessor wrappers for the two error condition macro constants
 *  (see: ERR_NULL_POINTER and ERR_INVALID_LENGTH) were added after the fact.  The docmentation
 *  box was also missing.  The final edits were made in Noteapd.
 */
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// DEMONSTRATION LAB I.3.A-2 ///////////////////////////////
/////////////////////////////////////// Variable Scope ////////////////////////////////////
///////////////////////////////// "I'm thinking of a number..." ///////////////////////////
////////////////////////////////////// Student Shell Code /////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// The objective of this lab is to take user input (a "magic number") and to write a
//     function that will "randomize" numbers until it "guesses" the "magic number".
//     The function should not choose "randomized" numbers as "guesses" if those "guesses"
//     have already been used.  A macro named MAX_GUESS is used to establish the range
//     of "magic numbers" (1 to MAX_GUESS).  Main() and the function will not directly
//     communicate the "guesses".  Instead, they'll use the global uint8_t array to 
//     determine if the function has guessed the "magic number".  The function will update
//     the global array with "guesses" and main() will watch the global array to determine
//     if the "magic number" has been guessed.
//
// main() should:
//     1. Take input
//     2. Verify that input falls between 1 and MAX_GUESS (inclusive)
//     3. Watch the global array to see if the "magic number" has been guessed
//     4. Loop the function until the "magic number" has been guessed in the array
//     5. Print the total number of randomizations the function performed once the "magic
//         number is guessed
//
// guess_a_number() should:
//     1. Randomize a number between 1 and MAX_SIZE
//     2. Increment the variable storing the total number of randomizations
//     3. Check the global array to see if that number has already been "guessed"
//         3.a. If it's been guessed already, go back to Step #1
//         3.b. If it hasn't been guessed, modify the global array to indicate
//             it's been guessed.
//     4. Return the number of times the function has "randomized" a number
//         NOTE:  "Randomizing" a number is different than "guessing" a number because
//             some "randomized" numbers have already been "guessed"
///////////////////////////////////////////////////////////////////////////////////////////

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <windows.h>
#include <stdint.h>
/* The following MACRO determines the available range of "magic numbers" and, subsequently, the "guesses" */
#define MAX_GUESS 100 // Available numbers range from 1 to MAX_GUESS

/* Declare a global uint8_t array with a dimension equal to (MAX_GUESS + 1) and initialize it to zero (0) */

uint8_t guess_a_number(void); // Function prototype

int main(void)
{

	/* INSERT CODE HERE */

	return 0;
}

/*
* FUNCTION:   uint8_t guess_a_number(void)
*
* ARGUMENTS:  This function takes no parameters although it *should* update the previous_guesses global array
*
* RETURNS:	  Total number of "randomizations" 
*             NOTE:  One "randomization" is one function call to rand() while one "guess" is one update to
*                 previous_guesses[]
*
* NOTES:      This function randomizes numbers from 1 to MAX_SIZE.
*             Each randomized number is checked against the previous_guesses global array.
*             If the value had already been guessed, the function will randomize another number
*             If the value had not already been guessed, this function will update the global array
*/
uint8_t guess_a_number(void)
{

	/* INSERT CODE HERE */

}
#include <stdio.h>
#include <string.h>
#include "MyStringHeader.h"

int main(void)
{
	int i = 0;
	int tempStrLen = 0;
	int tempReturnValue = 0;
	int totalUnitTestsRun = 0;
	int numUnitTestsPassed = 0;
	char testString1[] = { "This is a test string." }; // NULL terminated string
	char testString2[15] = { 'N', 'o', 't', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', '!' }; // Not null-terminated
	char testString3[] = { "!@#$%^&*()" }; // No alphabet letters in the string
	char testString4 = NULL; // NULL pointer
	char testString5[] = { "This is a normal string the but main() will pass zero as a string length." }; // Good string but passed with zero length
	char testString6[] = { "This is a normal string but main() will pass an invalid string length." }; // Good string but passed with invalid length
	char * testStringArray[] = {testString1, testString2, testString3, testString4, testString5, testString6};
	int testStringLength[] = { strlen(testString1), 15, strlen(testString3), 999, 0, -999 };
	int testStringReturnValues[] = {17, 13, 0, -1, -2, -2};
	int testReturnValueStorage[6] = { 0 };

	for (i = 0; i < (sizeof(testStringArray) / sizeof(testStringArray[0])); i++)
	{
		/* Unit test header */
		printf("UNIT TEST #%d STRING:\n\t", i + 1);
		/* Print the test string */
		if (1 == i)
		{
			printf("Passing a non null-terminated string.\n");
		}
		else if (3 == i)
		{
			printf("Passing a NULL pointer.\n");
		}
		else
		{
			puts(testStringArray[i]);
		}
		/* Pass the unit test data to print_the_count() */
		//tempReturnValue = print_the_count(testStringArray[i], testStringLength[i]);
		testReturnValueStorage[i] = print_the_count(testStringArray[i], testStringLength[i]);
		totalUnitTestsRun++;

		if (testReturnValueStorage[i] == testStringReturnValues[i])
		{
			printf("\tPASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("\tFAIL\n");
		}
	}
	printf("\n*******************************\n");
	printf("This program ran %d unit tests.\n", totalUnitTestsRun);
	printf("Your header passed %d unit tests.\n", numUnitTestsPassed);
	printf("*******************************\n");

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	int i = 0;
	int numberFibonacciNumbers = 0;
	int fibNumMinus2 = 0;
	int fibNumMinus1 = 1;
	int currentFibNum = 0;

	printf("How many Fibonacci numbers would you like to print? \n");
	_flushall();
	scanf("%d", &numberFibonacciNumbers);

	printf("******************\n");
	printf("FIBONACCI SEQUENCE\n");
	printf("******************\n");
	printf("%d\n%d\n", fibNumMinus2, fibNumMinus1);

	for (i = 0; i < numberFibonacciNumbers; i++)
	{
		currentFibNum = fibNumMinus1 + fibNumMinus2;
		printf("%d\n", currentFibNum);
		fibNumMinus2 = fibNumMinus1;
		fibNumMinus1 = currentFibNum;
	}

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int fibonacci_number(int sequenceNumber);

int main(void)
{
	int i = 0;
	int numberFibonacciNumbers = 0;
	int currentFibNum = 0;

	printf("How many Fibonacci numbers would you like to print? \n");
	_flushall();
	scanf("%d", &numberFibonacciNumbers);

	printf("******************\n");
	printf("FIBONACCI SEQUENCE\n");
	printf("******************\n");
	for (i = 0; i < numberFibonacciNumbers; i++)
	{
		currentFibNum = fibonacci_number(i);
		printf("%d\n", currentFibNum);
	}

	return 0;
}

int fibonacci_number(int sequenceNumber)
{
	int returnValue;

	if (sequenceNumber < 0)
	{
		returnValue = -1;
	}
	else if (0 == sequenceNumber)
	{
		returnValue = 0;
	}
	else if (1 == sequenceNumber)
	{
		returnValue = 1;
	}
	else
	{
		returnValue = fibonacci_number(sequenceNumber - 1) + fibonacci_number(sequenceNumber - 2);
	}

	return returnValue;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include "my-math-functions.h"

int main(void)
{
	int firstNum = 0;
	int secondNum = 0;
	printf("Is _ larger than _?\n");
	_flushall();
	scanf("Is %d larger than %d?", &firstNum, &secondNum);
	
	if (is_larger(firstNum, secondNum))
	{
		printf("%d was larger\n", firstNum);
	}
	else
	{
		printf("%d was larger\n", secondNum);
	}

	if (is_odd(firstNum))
	{
		printf("%d is odd\n", firstNum);
	}
	else
	{
		printf("%d is even\n", firstNum);
	}

	return 0;
}
#define MY_HEADER_YES 1
#define MY_HEADER_NO 0

extern int is_larger(int a, int b) // Is a larger than b?
{
	if (a > b)
	{
		return MY_HEADER_YES;
	}
	else
	{
		return MY_HEADER_NO;
	}
}

extern int is_odd(int num) // Is num odd?
{
	if (num & 1)
	{
		return MY_HEADER_YES;
	}
	else
	{
		return MY_HEADER_NO;
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PERFORMANCE LAB I.3.A-1 //////////////////////////////
////////////////////////////////// "Healthy Substiutions" ////////////////////////////////
///////////////////////////////////// Student Stub Code //////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// Do not modify main()
// Write the code body for the following function prototype:
//     int replace_character (char * string, const char findThisChar, const char replaceItWithThis);
// This function takes the following parameters:
//     A pointer to a null-terminated string as a parameter (string)
//     A constant character to find in the afore mentioned string (findThisChar)
//     A constant character to replace the afore mentioned 'search' character (replaceItWithThis)
// This function must replace all occurences of "findThisChar" with "replaceItWithThis"
// The return value should represent the number of characters that were changed
//     with the following exceptions:
//         Return ERR_NONE_FOUND if no newlines are found
//         Return ERR_NULL_POINTER if the pointer to the string (string) is NULL
//         Return ERR_FIND_EQUALS_REPLACE if "findThisChar" is equal to "replaceItWithThis"
//         Return ERR_NON_PRINTABLE_CHARACTER if "findThisChar" or "replaceItWithThis"
//             is a non-printable character
// Do not process a NULL string pointer (string)
//////////////////////////////////////////////////////////////////////////////////////////

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>

/* 
 * This pre-processing directive determines whether the program will
 *     run unit tests and/or prompt the user for input depending on
 *     what #define statements are uncommented.
 * #define AUTO // Runs unit test
 * #define MANUAL // Asks user for input
 * Uncomment out both #defines to first execute unit testing and then take user input
 */
#define AUTO
//#define MANUAL

#define NUMBER_OF_TESTS 12 // There are currently 12 unit tests.  More may be added by increasing this value and adding more cases.
#define ERR_NONE_FOUND 0 // Return value if no occurences of "findThisChar" are found
#define ERR_NULL_POINTER -1 // Return value if string is NULL
#define ERR_FIND_EQUALS_REPLACE -2 // Return value if "findThisChar" is the same as "replaceItWithThis"
#define ERR_NON_PRINTABLE_CHARACTER -3 // Return value if "findThisChar" or "replaceItWithThis" are non-printable characters


int replace_character(char * string, const char findThisChar, const char replaceItWithThis);

int main(void)
{
	/* VARIABLE INITIALIZATION */
	int i = 0; // Iterating variable
	char findChar = 0; // Local variable to store the search character
	char replaceChar = 0; // Local variable to store the replacement character

	/* The AUTO code block allows runs established unit tests to give students formal, standardized feedback on their code. */
#ifdef AUTO
	char testString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
	const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
	int tempResult = 999; // Temporarily holds the return value of replace_character to compare it to expected 'static' value per unit test
	int numberOfErrors = 0; // Counts the total number of FAILed unit tests
	printf("PERFORMING TESTING\n");

	for (i = 1; i <= NUMBER_OF_TESTS; i++)
	{
		strncpy(testString, originalTestString, strlen(testString)); // Resets testString by copying original version into it
		switch (i) // Cases represent the various unit tests.  Numbers equate to test arrays.
		{
			case (1):
				printf("\nTest #1 - Make one lowercase letter replacement\n");
				findChar = 'a';
				replaceChar = 'b';
				char test1[] = { "testSTRING-bbcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (1 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test1);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (2) :
				printf("\nTest #2 - Make one uppercase letter replacement\n");
				findChar = 'X';
				replaceChar = 'Y';
				char test2[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWYYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (1 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test2);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (3) :
				printf("\nTest #3 - Make two lowercase letter replacements\n");
				findChar = 's';
				replaceChar = 'n';
				char test3[] = { "tentSTRING-abcdefghijklmnopqrntuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (2 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test3);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (4) :
				printf("\nTest #4 - Make two uppercase letter replacements\n");
				findChar = 'T';
				replaceChar = 'P';
				char test4[] = { "testSPRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSPUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (2 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test4);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (5) :
				printf("\nTest #5 - Make one non-alphabet replacement\n");
				findChar = '[';
				replaceChar = '{';
				char test5[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-={]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (1 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test5);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (6) :
				printf("\nTest #6 - Make two non-alphabet replacements\n");
				findChar = '-';
				replaceChar = '_';
				char test6[] = { "testSTRING_abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890_=[]',./!@#$%^&*()_+{}:<>?\n" };
				//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (2 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test6);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (7) :
				printf("\nTest #7 - Testing a NULL pointer\n");
				findChar = '-';
				replaceChar = '_';
				char * test7 = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(NULL, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (ERR_NULL_POINTER == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				//tempResult = strcmp(testString, test7); // test7 is NULL
				printf("\tReplacement:\tNot executed.\n");
/*				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
*/
				break;

			case (8) :
				printf("\nTest #8 - Search character matches replace character\n");
				findChar = '-';
				replaceChar = '-';
				char test8[] = { "testSTRING_abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890_=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (ERR_FIND_EQUALS_REPLACE == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test8);
				printf("\tReplacement:\tNot tested.\n");
/*				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
*/
				break;

			case (9) :
				printf("\nTest #9 - Search character not found\n");
				findChar = '\\';
				replaceChar = 'n';
				char test9[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (ERR_NONE_FOUND == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test9);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (10) :
				printf("\nTest #10 - Search for a non-printable character\n");
				findChar = 10;
				replaceChar = 'n';
				char test10[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (ERR_NON_PRINTABLE_CHARACTER == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test10);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (11) :
				printf("\nTest #11 - Replace a non-printable character\n");
				findChar = 't';
				replaceChar = 11;
				char test11[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (ERR_NON_PRINTABLE_CHARACTER == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test11);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			case (12) :
				printf("\nTest #12 - Replace a non-printable character with\nanother non-printable character\n");
				findChar = 10;
				replaceChar = 12;
				char test12[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };
//				const char originalTestString[] = { "testSTRING-abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUVWXYZI.3.567890-=[]',./!@#$%^&*()_+{}:<>?\n" };

				/* TESTING */
				/* Return Value Testing */
				tempResult = replace_character(testString, findChar, replaceChar);
				printf("\tReturn Value:\t");
				if (ERR_NON_PRINTABLE_CHARACTER == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}

				/* Algorithm Testing */
				tempResult = strcmp(testString, test12);
				printf("\tReplacement:\t");
				if (0 == tempResult)
				{
					printf("PASS\n");
				}
				else
				{
					printf("FAIL\n");
					numberOfErrors++;
				}
				break;

			default:
				printf("You tried to run %d tests but there aren't %d of tests yet. \n", i, NUMBER_OF_TESTS);
				break;
		}
	}
	if (1 == numberOfErrors)
	{
		printf("You had %d error", numberOfErrors);
	}
	else
	{
		printf("You had %d errors", numberOfErrors);
	}
	
#endif

	/* The MANUAL code block allows students to manually interact with their functions. */
#ifdef MANUAL
	char badString1[] = { "Off we go into the wild blue vonder..." }; // One error
	char badString2[] = { "I speqqed something wrong in this sentence." }; // Two errors
	char badString3[] = { "Zwo strings walk into a bar.\nZhe first string says, \"I'll have a beer.#MV*()>SDk+!^&@P&]JEA&#65535\"\nZhe second string says, \"Sorry.  He's not null-terminated.\"\n" }; // Three errors
	char badString4[] = { "How much Food could a Foodchuck chuck if a woodchuck could chuck Food?" }; // Some errors
	char badString5[] = { "What do you do if there's nothing wrong with a sentence?" }; // No errors
	char * badString6 = NULL;
	char * badStringArray[] = { badString1, badString2, badString3, badString4, badString5, badString6 };
	int functionResult = 999;
	size_t numberOfManualStrings = sizeof(badStringArray) / sizeof(*badStringArray); // Stores the number of strings in the badArray string array

	for (i = 0; i < numberOfManualStrings; i++)
	{
		printf("\nString #%d (of %d):\n%s\n", i + 1, numberOfManualStrings, badStringArray[i]); // Preface each manual string
		printf("What character do you want to replace?  "); // Prompt for findThisChar
		_flushall();
		findChar = getchar();
		printf("What character do you want to replace it with?  "); // Prompt for replaceItWithThis
		_flushall();
		replaceChar = getchar();
		functionResult = replace_character(badStringArray[i], findChar, replaceChar); // Runs replace_character() and stores the result
		printf("String #%d is now:\n%s\n", i + 1, badStringArray[i]); // Prints the modified string
		printf("Your function returned %d \n", functionResult); // Shows student the return value of replace_character()
	}
#endif

	return 0;
}

/*
* FUNCTION:   int replace_character(char * string, const char findThisChar, const char replaceItWithThis)
*
* ARGUMENTS:  string is a pointer to a null-terminated string.  The string is passed by reference and modified in place.
*             findThisChar is the character to 'search' for
*             replaceItWithThis is the character to 'replace' the 'search' character with
*
* RETURNS:	  Number of characters that were replaced
*             ERR_NONE_FOUND if no occurrences of "findThisChar" are found
*             ERR_NULL_POINTER if string == NULL
*             ERR_FIND_EQUALS_REPLACE if "findThisChar" is equal to "replaceItWithThis"
*             ERR_NON_PRINTABLE_CHARACTER if "findThisChar" or "replaceItWithThis" are non-printable characters
*
* NOTES:      This function replaces all occurrences of "findThisChar" with "replaceItWithThis" in "string"
*/
int replace_character(char * string, const char findThisChar, const char replaceItWithThis)
{
	/* INSERT CODE HERE */

	return 90; // You'll want to modify the return statement for this function
}
//////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PERFORMANCE LAB I.3.A-2 //////////////////////////////
////////////////////////////////////// "Alphabet Soup" ///////////////////////////////////
///////////////////////////////////// Student Stub Code //////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// WARNING:  Do not modify main()
// PURPOSE:
//     Take input (e.g., stdin) and count the alphabet letters from the input
//     Stop taking input on Ctrl-D (char breakCharacter = 17;)
//     Each function utilizes a global array (see: alphabetCount[])
//     Each function's return values will provide integrity checks
// REASON:
//     main() should not change
//     main() requires given execution and specific return values
//     The only modification outside of main() should be the function definitions
//         and commenting/uncommenting the various unit test macros
//     Programmers often must code within previously established frameworks
// TESTING:
//     main() includes built-in testing
//     The type of test(s) to be run are determined by the #define lines
//     Each function has its own test
//     The overall program has its own test
//     There is also a manual input test to aid the student by providing interaction
//     The Structured_Input.txt file must be in C:\Temp
//     temp.txt is another file utilized in C:\Temp but main() will create the file
//         if temp.txt isn't already there.  It is merely for temporary use.
// GLOBAL ARRAY:
//     Initialized outside main()
//     Accessed directly by all of the program's functions
//     Dimension fo 26 (one index per alphabet letter)
//     Value in each index contains the current count of that letter
//     0 represents A, 1 represents B, 2 represents C, etc.
//     The count for "a" (and "A" since the count is case-insensitive) is stored in
//         alphabetCount[0].  The rest of the letters follow the index numbers
//         in alphabetic order.
// NOTE:
//     The overall structure of this program is complicated.  The student is not
//         required to see the forest (the entire program) while programming a 
//         tree (one function).  If the students follow the given criteria for
//         each of the functions, all should be well.  The unit tests are built
//         for iterative testing.  This means they can define a single function
//         and then run tests on that function by itself (by commenting out all
//         of the other tests, of course)
//////////////////////////////////////////////////////////////////////////////////////////

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdint.h>


/*
* This pre-processing directive determines whether the program will
*     run unit tests and/or prompt the user for input depending on
*     what #define statements are uncommented.
#define AUTO_COUNT_INPUT // Runs unit tests on int count_input(FILE * inputStream)
#define AUTO_CLEAR_ARRAY // Runs unit tests on clear_global_array(int currentAlphaCount)
#define AUTO_PRINT_COUNT // Runs unit tests on print_alphabet_count(int printTheCount)
#define AUTO_FULL_PROGRAM // Runs unit tests on the entire program as a whole, incorporating all functions
#define MANUAL // Allows the programmer to manually provide input to test the response of the program as a whole
* Uncomment out multiple #defines to multiple tests in a single run
*/
#define AUTO_COUNT_INPUT
//#define AUTO_CLEAR_ARRAY
//#define AUTO_PRINT_COUNT
//#define AUTO_FULL_PROGRAM
//#define MANUAL

#define ERR_NULL_POINTER -1 // Return value if string is NULL
#define ERR_COUNT_MISMATCH -2 // Return value if the alphabet letter count doesn't equal the global array
#define SMALL_TEST_FILE_LOCATION "C:\\Temp\\temp.txt" // Used for individual unit tests
#define LARGE_TEST_FILE_LOCATION "C:\\Temp\\Structured_Input.txt" // Used for full unit test
#define TEST_BUFF_SIZE 512 // Standardized buffer size to aid in looping

int alphabetCount[26] = { 0 }; // Global array that holds the current count of alphabet letters

int count_input(FILE * inputStream); // Returns character input and updates alphabetCount[] with number of letters
int clear_global_array(int currentAlphaCount); // Returns a boolean result of currentAlphaCount compared to what was found in alphabetCount[]; Empties alphabetCount[]
int print_alpabet_count(int printTheCount); // Returns sum of all values in alphabetCount[]; printTheCount is a boolean argument to print alphabetCount[] results to stdout


int main(void)
{
	long int totalChars = 0; // Holds the total number of characters, letters or otherwise, that have been counted
	long int totalAlphaChars = 0; // Holds the total number of alphabet letters that have been counted
	int i = 0; // Incrementing variable
	int j = 0; // Incrememnting variable
	int numUnitTestsRun = 0; // Holds the number of unit tests that have been run
	int numUnitTestsPassed = 0; // Holds the number of unit tests that have passed

	/*
	* This unit test will send sample input into your count_input() function
	* It passes this input by utilizing crafted char arrays (e.g, testString1, testString2)
	* Each char array is coupled with a similarly numbered parallel int array (e.g., testAlphabetCount1, testAlphabetCount2)
	*     which represents the expected status of the global alphabetCount[] array when the count is complete.
	* The expected return value for each char array is stored in a parallet int array (autoCountInputStringAnswers)
	* The char arrays are stored in a char * array (autoCountInputStringArray)
	* The parallel int arrays are stored in an int * array (testAlphabetCount)
	* The char arrays are printed to a FILE * (autoCountInputTestFile) to be passed as a parameter to count_input()
	* Not only is the return value for each function call verified, the post-function status of the global array
	*     is also verified against the parallel int array.
	*/
#ifdef AUTO_COUNT_INPUT
	/* Define Test 1 */
	char testString1[TEST_BUFF_SIZE] = { "a B c D?" }; // Appropriately sized string properly marked
	testString1[8] = 17;
	testString1[9] = 0;
	int testAlphabetCount1[26] = { 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	/* Define Test 2 */
	char testString2[TEST_BUFF_SIZE] = { "1 @ 3 $ thumb War!" }; // Large string with empty space improperly marked
	testString2[TEST_BUFF_SIZE - 2] = 17;
	testString2[TEST_BUFF_SIZE - 1] = 0;
	int testAlphabetCount2[26] = { 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0 };

	/* Define Test 3*/
	char testString3[TEST_BUFF_SIZE] = { "32 Non-printable characters" }; // String that contains non-printable characters, empty space, and is improperly marked

	for (i = 31; i >= 0; i--)
	{
		if (17 == i)
		{
			continue; // Skip char 17 since we don't want to end prematurely
		}
		testString3[TEST_BUFF_SIZE - i - 3] = i;
	}

	testString3[TEST_BUFF_SIZE - 2] = 17;
	testString3[TEST_BUFF_SIZE - 1] = 0;
	int testAlphabetCount3[26] = { 3, 1, 2, 0, 2, 0, 0, 1, 1, 0, 0, 1, 0, 3, 1, 1, 0, 3, 1, 2, 0, 0, 0, 0, 0, 0 };

	/* Define Test 4 */
	char testString4[TEST_BUFF_SIZE] = { "Properly marked non-printable characters: " }; // String that contains non-printable characters and no empty space

	for (i = 43; i < (43 + 18); i++)
	{
		testString4[i] = i - 42;
	}
	int testAlphabetCount4[26] = { 4, 1, 2, 1, 4, 0, 0, 1, 1, 0, 1, 2, 1, 3, 2, 3, 0, 6, 1, 2, 0, 0, 0, 0, 1, 0 };

	/* Define Parallel Arrays */
	char * autoCountInputStringArray[] = { testString1, testString2, testString3, testString4 };
	int autoCountInputStringAnswers[] = { 9, 511, 483, 60 };
	int * testAlphabetCount[] = { testAlphabetCount1, testAlphabetCount2, testAlphabetCount3, testAlphabetCount4 };

	FILE * autoCountInputTestFile = NULL; // File pointer
	autoCountInputTestFile = fopen(SMALL_TEST_FILE_LOCATION, "w+");

	if (autoCountInputTestFile) // Verify file pointer is not NULL
	{
		printf("\n***********************************\n");
		printf("RUNNING UNIT TESTS ON count_input()\n");
		printf("***********************************\n\n");
		for (i = 0; i < sizeof(autoCountInputStringArray) / sizeof(autoCountInputStringArray[0]); i++)
		{
			//			fputs(autoCountInputStringArray[i], autoCountInputTestFile); // Isn't copying all characters because it's stopping at NULL instead of continuing to Ctrl-Q
			for (j = 0; j < TEST_BUFF_SIZE; j++)
			{
				fputc(autoCountInputStringArray[i][j], autoCountInputTestFile); // Places the current testString into the test file character by character
			}

			/* AUTO_COUNT_INPUT Unit Test Execution 1 - 4 */
			printf("Test %d:\n\t", i + 1);
			printf("Return Value\t");
			numUnitTestsRun++;
			if (autoCountInputStringAnswers[i] == count_input(autoCountInputTestFile))
			{
				printf("PASS\n");
				numUnitTestsPassed++;
			}
			else
			{
				printf("FAIL\n");
				printf("\tThe unit test was expecting %d \n", autoCountInputStringAnswers[i]);
			}
			printf("\tGlobal Array\t");
			numUnitTestsRun++;
			int failedCheck = 0;
			for (j = 0; j < 26; j++)
			{
				if (testAlphabetCount[i][j] != alphabetCount[j])
				{
					printf("FAIL\n");
					failedCheck = 1;
					break;
				}
			}
			if (!failedCheck)
			{
				printf("PASS\n");
				numUnitTestsPassed++;
			}
			memset(alphabetCount, 0, 26 * sizeof(int));
			freopen(SMALL_TEST_FILE_LOCATION, "w+", autoCountInputTestFile); // Reopen the file, emptying it
			if (!autoCountInputTestFile)
			{
				printf("Error reopening file.\n");
				break;
			}
		}
		/* AUTO_COUNT_INPUT Unit Test Execution 5 */
		printf("Test 5:\n\tReturn Value\t"); // Manual unit test to verify response to NULL pointer input
		numUnitTestsRun++;
		if (ERR_NULL_POINTER == count_input(NULL))
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
			printf("\tFunction did not return the proper value for a NULL pointer.\n");
		}
		printf("\tGlobal Array\t");
		numUnitTestsRun++;
		int failedCheck = 0;
		for (j = 0; j < 26; j++)
		{
			if (alphabetCount[j])
			{
				printf("FAIL\n");
				failedCheck = 1;
				break;
			}
		}
		if (!failedCheck)
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
		if (autoCountInputTestFile)
		{
			fclose(autoCountInputTestFile);
		}
	}

#endif

	/*
	* This unit test will call your clear_global_array() function to clear different values in the alphabetCount global array
	* It sets non-zero values to the alphabetCount global array and calls the clear_global_array() function to clear it
	* These tests are able to compare pre-determined results to the function's return value and performance
	* For each test, it tests the function's return value first
	* Then it verifies that all of alphabetCount[]'s elements have been set to zero (0)
	* A properly functioning clear_global_array() is a pre-requisite to passing all of the print_alphabet_count()
	*     unit tests since print_alphabet_count() is required to call clear_global_array().
	*/
#ifdef AUTO_CLEAR_ARRAY

	printf("\n******************************************\n");
	printf("RUNNING UNIT TESTS ON clear_global_array()\n");
	printf("******************************************\n\n");

	for (i = 1; i <= 5; i++)
	{
		printf("Test %d: \n\t", i);

		for (j = 0; j < 26; j++)
		{
			alphabetCount[j] = i;
		}

		printf("Return Value\t");
		numUnitTestsRun++;

		if (clear_global_array(i * 26))
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		printf("\tReset Array\t");
		numUnitTestsRun++;

		int failedCheck = 0; // Boolean variable used to determine if alphabetCount failed its verification check
		for (j = 0; j < 26; j++)
		{
			if (alphabetCount[j])
			{
				failedCheck = 1;
				memset(alphabetCount, 0, 26 * sizeof(int));
				break;
			}
		}
		if (failedCheck)
		{
			printf("FAIL\n");
		}
		else
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
	}

#endif

	/*
	* This unit test will make adjustments to the alphabetCount[] global array and test print_alphabet_count()'s
	*     ability to invoke clear_global_array() to zeroize the values stored within alphabetCount[]
	* It sets non-zero values to the alphabetCount global array and verifies print_alphabet_count()'s ability
	*     to return the sum of all the values.
	* Then it verifies that all of alphabetCount[]'s elements have been set to zero (0)
	* A properly functioning clear_global_array() is a pre-requisite to passing all of the print_alphabet_count()
	*     unit tests since print_alphabet_count() is required to call clear_global_array().
	* These unit tests are very similar to the clear_global_array() unit tests.
	*/
#ifdef AUTO_PRINT_COUNT

	printf("\n********************************************\n");
	printf("RUNNING UNIT TESTS ON print_alphabet_count()\n");
	printf("********************************************\n\n");

	for (i = 1; i <= 5; i++)
	{
		printf("Test %d: \n\t", i);

		for (j = 0; j < 26; j++)
		{
			alphabetCount[j] = i;
		}

		printf("Return Value\t");
		numUnitTestsRun++;

		if (print_alpabet_count(0) == (i * 26))
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		printf("\tReset Array\t");
		numUnitTestsRun++;

		int failedCheck = 0; // Boolean variable used to determine if alphabetCount failed its verification check
		for (j = 0; j < 26; j++)
		{
			if (alphabetCount[j])
			{
				failedCheck = 1;
				memset(alphabetCount, 0, 26 * sizeof(int));
				break;
			}
		}
		if (failedCheck)
		{
			printf("FAIL\n");
		}
		else
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
	}
	memset(alphabetCount, 0, 26 * sizeof(int));
	printf("Test 6: Empty array\n\tReturn Value\t");
	numUnitTestsRun++;
	if (0 == print_alpabet_count(0))
	{
		printf("PASS\n");
		numUnitTestsPassed++;
	}
	else
	{
		printf("FAIL\n");
	}


#endif


	/* This unit test will test the entire program at once. It accomplishes by using a pre-written
	*     that will need to be staged in LARGE_TEST_FILE_LOCATION as #defined at the beginning.
	* This unit test should be able to detect and resolve any changes that have been made to the existing
	*     file.  This should alleviate any concerns as to the integrity of the unit test since it is
	*     using an external file to pass test data to this program.
	*/
#ifdef AUTO_FULL_PROGRAM

#define BUFF_SIZE 512
	FILE * preStagedInput = NULL; // File pointer
	preStagedInput = fopen(LARGE_TEST_FILE_LOCATION, "r"); // Open the file that contains the test input for read-only
	if (preStagedInput) // Verify the file opened
	{
		printf("\n************************************\n");
		printf("RUNNING UNIT TESTS ON THE ENTIRE LAB\n");
		printf("************************************\n\n");
		printf("CHECKING FILE INTEGRITY\n\t");
		char copyBuffer[BUFF_SIZE] = { 0 }; // Holds the information that will be read from the test input file
		/* Holds original copy of what the test input file should look like */
		char verificationBuffer[BUFF_SIZE] = { "This file was created to aid a unit test for Performance Lab I.3.a-2, Variable Scope \"Alphabet Soup\".\n\nThe print function should give this output:\n\nYou've input a total of 364 characters.\nA: 18\nB: 4\nC: 7\nD: 4\nE: 17\nF: 7\nG: 2\nH: 7\nI: 12\nJ: 1\nK: 1\nL: 9\nM: 2\nN: 8\nO: 15\nP: 9\nQ: 1\nR: 10\nS: 10\nT: 23\nU: 11\nV: 5\nW: 2\nX: 2\nY: 3\nZ: 1\nYou've input a total of 191 letters.\n" };
		verificationBuffer[363] = 17; // Manually set the 'escape character' (Ctrl-Q) since I can't type it
		char tempChar = 0;

		/* Copy the contents of the file into copyBuffer[] */
		i = 0; // Incrementing variable is zeroized because it is used elsewhere
		while (tempChar != 17) // Stop copying when you reach decimal value 17 (Ctrl-Q)
		{
			tempChar = getc(preStagedInput); // Read one character from the test input file
			copyBuffer[i] = tempChar; // Put that character into the copyBuffer
			i++; // Advance to the next element
			if ((BUFF_SIZE - 1) == i) // Reached the end of the copy buffer
			{
				copyBuffer[i] = 0; // Manually ensure string is null terminated... for safety
				break; // Will cause the while loop to end
			}
		}
		copyBuffer[BUFF_SIZE - 1] = 0; // Manually null terminate the string... for safety
		verificationBuffer[BUFF_SIZE - 1] = 0; // Manually null terminate the string... for safety

		if (!(strcmp(copyBuffer, verificationBuffer))) // strcmp() will compare two strings
		{
			printf("The file has not been changed.\n");
		}
		else // ...test input file and original copy are not identical!
		{
			printf("We have a problem!\n\tThe file appears to have been changed.\n\tFixing file...\n");
			rewind(preStagedInput); // Rewinds the file pointer to the beginning of the file
			freopen(LARGE_TEST_FILE_LOCATION, "w", preStagedInput); // Closes and reopens the file in write mode
			if (preStagedInput) // Verifies the reopen functioned on the file pointer
			{
				for (i = 0; i < BUFF_SIZE; i++) // Iterates through original copy
				{
					if (0 == verificationBuffer[i]) // Stops writing to the file when it encounters a null character from the original copy
					{
						break;
					}
					putc(verificationBuffer[i], preStagedInput); // Places the original version of the file into the test input file character by character
				}
				rewind(preStagedInput); // Rewinds the file pointer
				freopen(LARGE_TEST_FILE_LOCATION, "r", preStagedInput); // Reopens the test input file in read-only mode... again
			}

			if (preStagedInput) // Verifies the read-only reopen was successful
			{
				printf("\tThe file contents have been replaced.\n");
			}
			else // ...otherwise something went wrong
			{
				printf("\tReopening the file to fix the contents did not work.\n");
				return -1;
			}
		}

		/* Full Test #1 */
		printf("TEST 1\tCounting total characters:  \n\t");
		totalChars = count_input(preStagedInput);
		printf("Return Value\t");
		numUnitTestsRun++;
		if (364 == totalChars)
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}
		printf("\tGlobal Array\t");
		numUnitTestsRun++;
		int testAlphabetCountFull[26] = { 18, 4, 7, 4, 17, 7, 2, 7, 13, 1, 1, 9, 2, 8, 15, 9, 1, 10, 10, 23, 11, 5, 2, 1, 3, 1 };
		int failedCheck = 0; // Boolean variable used to determine if alphabetCount failed its verification check
		for (j = 0; j < 26; j++)
		{
			if (alphabetCount[j] != testAlphabetCountFull[j])
			{
				failedCheck = 1;
				memset(alphabetCount, 0, 26 * sizeof(int));
				break;
			}
		}
		if (failedCheck)
		{
			printf("FAIL\n");
		}
		else
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}

		/* Full Test #2 */
		totalAlphaChars = print_alpabet_count(0);
		printf("TEST 2\tCounting alphabet letters:  \n\t");
		printf("Return Value\t");
		numUnitTestsRun++;
		if (191 == totalAlphaChars)
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("FAIL\n");
		}

		printf("\tGlobal Array\t");
		numUnitTestsRun++;
		failedCheck = 0; // Reseting boolean variable used to determine if alphabetCount failed its verification check
		for (j = 0; j < 26; j++)
		{
			if (alphabetCount[j])
			{
				failedCheck = 1;
				memset(alphabetCount, 0, 26 * sizeof(int));
				break;
			}
		}
		if (failedCheck)
		{
			printf("FAIL\n");
		}
		else
		{
			printf("PASS\n");
			numUnitTestsPassed++;
		}
	}
	else
	{
		printf("\n\nThere has been an error opening the test input file\n");
	}

	if (preStagedInput)
	{
		fclose(preStagedInput);
	}
#endif


#ifdef MANUAL
	printf("This program will count the number of characters and letters you input.\nWhen you are done with your input, input Ctrl-Q and press Enter.\n\n");
	totalChars = count_input(stdin);
	_flushall();
	printf("You've input a total of %d characters.\n", totalChars);
	totalAlphaChars = print_alpabet_count(1);
	printf("You've input a total of %d letters.\n", totalAlphaChars);
#endif

	if (numUnitTestsRun)
	{
		printf("\n\nYou've run %d unit tests and passed %d of them. \n", numUnitTestsRun, numUnitTestsPassed);
	}
	return 0;
}

/*
* FUNCTION:   int count_input(FILE * inputStream)
*
* ARGUMENTS:  inputStream is a file pointer.  The stream is passed by reference.
*             By taking a stream as a parameter, this function can process input from stdin (manual input) or
*                 file pointers (automatic input) for the purpose of unit testing.
*
* RETURNS:	  The number of characters, alphabet letters or not, that were input.
*             For example:
*                 Input:  abc^Q			Return:  4			Explanation:  ^Q (AKA Ctrl-Q, 17) counts as character input
*                 Input:  90IOS^Q		Return:  6			Explanation:  ^Q (AKA Ctrl-Q, 17) counts as character input
*                 Input:  something\n
*                         ^Q			Return:  11			Explanation:  Pressing enter before ^Q (AKA Ctrl-Q, 17) registers as \n input and should be counted
*                 Input:  ^Q			Return:  1			Explanation:  Even without input, ^Q (AKA Ctrl-Q, 17) counts as character input
*             Return ERR_NULL_POINTER if inputStream is NULL
*
* NOTES:      Not only does this function return the total number of characters that were read from the stream "inputStream",
*                 this function should also update the character count in the global char array alphabetCount[].
*             First, uppercase 'A' is technically a different value than a lowercase 'a'.  To avoid this issue, change
*                 the case of all input to uppercase or lowercase (your discretion).
*                     Option #1 - The C library contains functions that will change the case of input.  Research and utilize this library function if you wish.
*                     Option #2 - Changing the case of a letter is a relatively easy algorithm when you consider the decimal value for char values.
*                         Feel free to write your own algorithm and/or function to change the case of your input if you wish.
*                     NOTE:  Regardless of the option you choose, there are only 26 elements in the global array so you'll have to count capitals
*                         and lowercase input in the same index.
*             Second, each element in alphabetCount[] counts the number of occurences for a letter of the alphabet.  Element 0 represents A and
*                 element 25 represents Z.  This means the value at element 0 represents the total number of As that have been counted.
*                 The value at element 7, as another example, represents the number of Hs that have been read.  Another example is that the value of
*                 alphabetCount[10] represents the number of letter Ks that have been counted.  Increment the approrpiate alphabetCount element based on
*                 the alphabet letter that has been counted.
*             Third, stop taking input upon receiving decimal value 17 (AKA Ctrl-Q).  Decimal value 17 may be replicated by manually inputting Ctrl-Q as input.
*                 The character input of 17 (AKA Ctrl-Q) should count towards the overall character input and should not be ignored.
*             Fourth, ensure you check if inputStream is NULL.  If inputStream is NULL, return ERR_NULL_POINTER.
*             Fifth, stop looping through stream input if you input an EOF.  EOF stands for End of File.  EOF is #defined to represent the end of a file.
*/
int count_input(FILE * inputStream)
{
	if (inputStream) // If inputStream is not NULL...
	{
		rewind(inputStream); // Moves the file pointer to the beginning of the file.  This is necessary for reading one file multiple times.

		/* INSERT CODE HERE */

		return 90;  // Modify this return statement
	}

	return 90;  // Modify this return statement
}

/*
* FUNCTION:   int clear_global_array(int currentAlphaCount)
*
* ARGUMENTS:  currentAlphaCount represents the expected sum of the alphabetCount[] global array.  This function
*                 should perform it's own count of alphabetCount[] as it clears the array to verify no illegal
*                 modifications have taken place.
*
* RETURNS:	  1 if currentAlphaCount matches the sum performed by clear_global_array() 
			  ERR_COUNT_MISMATCH if currentAlphaCount doesn’t match the sum clear_global_array() came up with

*
* NOTES:      First, this function sums in order to return, the total number of alphabet letters that were counted in alphabetCount[]
*             Second, this function should also 'zeroize' all the elements of this array
*/
int clear_global_array(int currentAlphaCount)
{
	/* INSERT CODE HERE */

	return 90;  // Modify this return statement
}

/*
* FUNCTION:   int print_alpabet_count(int printTheCount)
*
* ARGUMENTS:  printTheCount is utilized as a binary flag.  If printTheCount is on (AKA non-zero), then print_alphabet_count()
*                 should print the character count to stdout.  If printTheCount == 0, then print_alphabet_count() shouldn't
*                 actually print anything to stdout.  The return value should be unchanged by the value passed into printTheCount.
*
* RETURNS:	  The sum of all values contained in all elements of alphabetCount[]
*                 This sum should represent the total number of alphabet letters [a-z, A-Z] that were stored in alphabetCount[]
*
* NOTES:      First, this function sums and returns the total number of alphabet letters that were counted in alphabetCount[]
*             Second, this function should also print the per-letter count to stdout if printTheCount is a non-zero value.
*             Third, this function should invoke clear_global_array() once the total number of alphabet letters have been summed
*                 and the per-letter count has been printed (if required by printTheCount).  clear_global_array() is defined
*                 later but should zeroize the global array.  If clear_global_array() returns ERR_COUNT_MISMATCH, print an error.
*/
int print_alpabet_count(int printTheCount)
{
	/* INSERT CODE HERE */

	return 90;  // Modify this return statement
}


///////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// PERFORMANCE LAB I.3.A-3 ////////////////////////////////
//////////////////////////////////////// Header Files /////////////////////////////////////
////////////////////////////////////// "String Theory" ////////////////////////////////////
////////////////////////////////////// Student Stub Code //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// The objective of this lab is to declare and define a header "MyStringHeader.h"
// MyStringHeader should include a function of prototype:
// int print_the_count(char * inputString, int strLen);
// The requirements for the prototype are included below in the function documentation box
// The students definition of the prototype will be tested by instructor-written
//     test code (see: Unit Test Code 1.c)
// When students are done declaring and defining the header, they are to add
//     "Unit Test Code 1.c" to their project and debug.
// Unit Test Code 1.c utilizes macros to run some, all, or none of the available
//     unit tests.  Comment out the Unit Test Code 1.c macros to manage which tests
//     are run. 
///////////////////////////////////////////////////////////////////////////////////////////

#ifndef ERR_NULL_POINTER
#define ERR_NULL_POINTER -1
#else 
#undef ERR_NULL_POINTER
#define ERR_NULL_POINTER -1
#endif

#ifndef ERR_INVALID_LENGTH
#define ERR_INVALID_LENGTH -2
#else 
#undef ERR_INVALID_LENGTH
#define ERR_INVALID_LENGTH -2
#endif

/*
 * FUNCTION:   int print_the_count(char * inputString, int strLen)
 *
 * ARGUMENTS:  inputString is a pointer to a character array (see: string) and is *NOT* 
 *                 guaranteed to be NULL terminated.  This is why the length of the 
 *                 string is also passed as an argument.
 *             strLen is the length of the inputString.  strLen is required as a safety
 *                 measure since inputString is not guaranteed to be null-terminated.
 *                 strLen does not need to be long enough to include any null character,
 *                 even if there was one.
 *
 * RETURNS:    # of alphabet letters found in inputString
 *             ERR_NULL_POINTER is inputString is NULL
 *             ERR_INVALID_LENGTH is strLen is unreasonable (zero or less)
 *
 * NOTES:      Not only does this function return the total number of alphabet letters
 *                 that were counted, it should also print a table of letters from the
 *                 string with their count.  Do not print any letters that were not
 *                 found in inputString.
 *             The "case" of the letter (upper or lower) should not matter for the count.
 *                 There are different ways to ignore the case of a char.  It is up
 *                 to the student to determine the method.
 */
int print_the_count(char * inputString, int strLen)
{
	/* INSERT CODE HERE */

	return 90; // You should modify this return statement
}

/*
 *  NOTE:
 *  This code was incomplete at the time it was transferred from the development laptop
 *  to it's storage location on the NIPRNET.  Some code was added without the aid of an IDE.
 *  The conditional preprocessor wrappers for the two error condition macro constants
 *  (see: ERR_NULL_POINTER and ERR_INVALID_LENGTH) were added after the fact.  The docmentation
 *  box was also missing.  The final edits were made in Noteapd.
 */
#include <stdio.h>
#include <string.h>
#include "MyStringHeader.h"

int main(void)
{
	int i = 0;
	int tempStrLen = 0;
	int tempReturnValue = 0;
	int totalUnitTestsRun = 0;
	int numUnitTestsPassed = 0;
	char testString1[] = { "This is a test string." }; // NULL terminated string
	char testString2[15] = { 'N', 'o', 't', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', '!' }; // Not null-terminated
	char testString3[] = { "!@#$%^&*()" }; // No alphabet letters in the string
	char testString4 = NULL; // NULL pointer
	char testString5[] = { "This is a normal string the but main() will pass zero as a string length." }; // Good string but passed with zero length
	char testString6[] = { "This is a normal string but main() will pass an invalid string length." }; // Good string but passed with invalid length
	char * testStringArray[] = { testString1, testString2, testString3, testString4, testString5, testString6 };
	int testStringLength[] = { strlen(testString1), 15, strlen(testString3), 999, 0, -999 };
	int testStringReturnValues[] = { 0, 0, 0, -1, -2, -2 };

	for (i = 0; i < (sizeof(testStringArray) / sizeof(testStringArray[0])); i++)
	{
		/* Unit test header */
		printf("UNIT TEST #%d STRING:\n\t", i + 1);
		/* Print the test string */
		if (1 == i)
		{
			printf("Passing a non null-terminated string.\n");
		}
		else if (3 == i)
		{
			printf("Passing a NULL pointer.\n");
		}
		else
		{
			puts(testStringArray[i]);
		}
		/* Pass the unit test data to print_the_count() */
		tempReturnValue = reverse_it(testStringArray[i], testStringLength[i]);
		totalUnitTestsRun++;

		if (tempReturnValue == testStringReturnValues[i])
		{
			printf("\tPASS\n");
			numUnitTestsPassed++;
		}
		else
		{
			printf("\tFAIL\n");
		}
	}
	printf("\n********************************\n");
	printf("This program ran %d unit tests.\n", totalUnitTestsRun);
	printf("Your header passed %d unit tests.\n", numUnitTestsPassed);
	printf("********************************\n");

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// PERFORMANCE LAB 1.3.a-4 ////////////////////////////////////////////////
/////////////////////////////////////////////////// Recursion ////////////////////////////////////////////////////////
///////////////////////////////////////////// "Shadow Sequence Number" /////////////////////////////////////////////// 
//////////////////////////////////////////////// Student Shell Code //////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This performance lab requirement is admittedly a contrived exercise.
// Admittedly, there aren't many easy problems to solve that call for recursion.
// Most of the easy-to-solve recursion problems are frequently used in academia and are already highly documented
//     on the Interwebs.
// This requirement is very similar to Fibonacci Sequence problem (Demonstration Lab 1.3.a-4) but was slightly
//     modified so the students couldn't just "Google" a solution.
// This lab may be relatively simple to accomplish but it was intentionally chosen.  Recursion can be a difficult
//     enough concept to grasp without having to apply it to an overly complicated problem.
// Do not forget that a recursive solution must have an ending point and make the problem simpler.
// NOTE:  The limit of MAXIMUM_SEQ_NUM (2300) sequence numbers was chosen for safety.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define MAXIMUM_SEQ_NUM (2300)
#define ERROR_VALUE (105)
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

/*
 * This pre-processing directive determines whether the program will
 *     run unit tests and/or prompt the user for input depending on
 *     what #define statements are uncommented.
#define MANUAL_TEST // Allows the programmer to manually provide input to test the response of the program as a whole
#define AUTO_TEST // Runs unit tests on unsigned long shadow_sequence_number(int placeNumber)
 * Uncomment out multiple #defines to multiple tests in a single run
 */
#define MANUAL_TEST
//#define AUTO_TEST

unsigned long shadow_sequence_number(int placeNumber);

int main(void)
{
	unsigned long tempValue = 0;
	unsigned long myTempValue = 0;
	int i = 0;
	int j = 0;

#ifdef MANUAL_TEST
	int howManyToCalculate = 0;
	tempValue = 0;

	printf("How many numbers would you like to calculate?\n");
	_flushall();
	scanf("%d", &howManyToCalculate);
	putchar(10);

	for (i = 1; i <= howManyToCalculate; i++)
	{
		tempValue = shadow_sequence_number(i);
		printf("%d:\t%lu \n", i, tempValue);
	}
#endif

#ifdef AUTO_TEST

#define BUFF_SIZE 24
	tempValue = 0;
	int numberOfTestsRun = 0;
	int numberOfTestsPassed = 0;
	int placeNumbers[BUFF_SIZE] = { -31337, ((MAXIMUM_SEQ_NUM + 1) * -1), (MAXIMUM_SEQ_NUM * -1), -1337, -100, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 100, 1337, MAXIMUM_SEQ_NUM, (MAXIMUM_SEQ_NUM + 1), 31337 };
	unsigned long returnValues[BUFF_SIZE] = { ERROR_VALUE, ERROR_VALUE, ERROR_VALUE, ERROR_VALUE, ERROR_VALUE, ERROR_VALUE, 9, 0, 9, 25, 50, 86, 135, 199, 280, 380, 501, 645, 814, 338345, 797553920, 4058312045, ERROR_VALUE, ERROR_VALUE };

	for (i = 0; i < BUFF_SIZE; i++)
	{
		tempValue = shadow_sequence_number(placeNumbers[i]);
		numberOfTestsRun++;
		if (tempValue == returnValues[i])
		{
			numberOfTestsPassed++;
		}
	}

	printf("\n\nNumber of tests run:\t%d\n", numberOfTestsRun);
	printf("Number of tests passed:\t%d\n", numberOfTestsPassed);
#endif

	return 0;
}

/*
 * FUNCTION:   unsigned long shadow_sequence_number(int placeNumber)
 *
 * ARGUMENTS:  placeNumber represents the individual "Shadow Sequence" position number to calculate
 *
 * RETURNS:	   The value of of the "Shadow Sequence" number at position "placeNumber" [see: S(placeNumber)].
 *			   The "Shadow Sequence" is calculated utlizing the following algorithm:
 *                 S(n) = S(n-1) + (n * n) where "n" represents a given position and S(n) represents the value at
 *                     position "n".  S(1) is always equal to 9.  S(2) is always equal to 0.  The algorithm begins
 *                     calculating at S(3).  (see NOTES: for details)  
 *             ERROR_VALUE (105) if placeNumber is unrealistic or dangerous
 *
 * NOTES:      This function should only be returning a single sequence number from the "Shadow Sequence".
 *             This function should *not* be calculating multiple sequence numbers during a single function call.
 *             Nor should this function be printing any sequence numbers.
 *             However, this function will need to call itself recursively to calculate all of the previous sequence
 *                 numbers in order to calculate the sequence number at position "placeNumber".
 *             Any requirements to calcualte or print multiple numbers in the "Shadow Sequence" should be
 *                 accomplished by the calling function [e.g., main()]
 *             The data type of long was chosen as the return value to increase the available output.
 *             The keyword unsigned was chosen to further maximize the available output since this algorithm
 *                 should not be producing any negative numbers.
 *			   The "Shadow Sequence" is calculated utlizing the following algorithm:
 *                 S(n) = S(n-1) + (n * n) where "n" represents a given position and S(n) represents the value at
 *                     position "n".  S(1) is always equal to 9.  S(2) is always equal to 0.  The algorithm begins
 *                     calculating at S(3).  For example, here are some sample calculations of S(n)
 *                     S(1) = 9.
 *                     S(2) = 0.
 *                     S(3) = S(2) + (3 * 3) ---> S(3) = (0)  + (9) ---> S(3) = 9.
 *                     S(4) = S(3) + (4 * 4) ---> S(4) = (9)  + (16) --> S(4) = 25.
 *                     S(5) = S(4) + (5 * 5) ---> S(5) = (25) + (25) --> S(5) = 50.
 *
 *             The first few "Shadow Sequence" numbers are as follows:
 *                 S(1)		S(2)	S(3)	S(4)	S(5)	S(6)	S(7)	S(8)	S(9)	S(10)
 *                 9		0		9		25		50		86		135		199		280		380
 */
unsigned long shadow_sequence_number(int placeNumber)
{
	/* INSERT CODE HERE */

	return 90; // Modify this return statement
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	int countNum = 0;
	int i = 0;

	printf("Countdown from ");
	_flushall();
	scanf("%d", &countNum);

	for (i = countNum; i > 0; i--)
	{
		printf("%d\n", i);
	}
	printf("BLAST OFF!");

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

void count_down(int startNum);

int main(void)
{
	int countNum = 0;

	printf("Countdown from ");
	_flushall();
	scanf("%d", &countNum);

	count_down(countNum);

	return 0;
}

void count_down(int startNum)
{
	if (startNum > 0)
	{
		printf("%d\n", startNum);
		count_down(startNum - 1);
	}
	else
	{
		printf("BLAST OFF!\n");
	}

	return;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	unsigned int factorialNumber = 0;
	unsigned int factorialResult = 1;
	unsigned int i = 0;

	printf("What number would you like to find a factorial for?\n");
	_flushall();
	scanf("%u", &factorialNumber);

	for (i = 2; i <= factorialNumber; i++)
	{
		factorialResult *= i;
	}
	printf("The results is:  %u\n", factorialResult);

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int factor_this(int factThis);

int main(void)
{
	unsigned int factorialNumber = 0;
//	unsigned int factorialResult = 1;
	unsigned int i = 0;

	printf("What number would you like to find a factorial for?\n");
	_flushall();
	scanf("%u", &factorialNumber);

	printf("The result is:  %u\n", factor_this(factorialNumber));

	return 0;
}

int factor_this(int factThis)
{
	int answer = 1;
	
	if (factThis > 1)
	{
		answer = factThis * factor_this(factThis - 1);
	}
	
	return answer;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	int numNatNum = 0;
	int i = 0;
	int sumNatNum = 0;
	printf("How many natural numbers do you want to add?  ");
	_flushall();
	scanf("%d", &numNatNum);

	for (i = 1; i <= numNatNum; i++)
	{
		sumNatNum += i;
	}

	printf("The total is: %d\n", sumNatNum);

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int sum_nat_nums(int howMany);

int main(void)
{
	int numNatNum = 0;
	int sumNatNum = 0;
	printf("How many natural numbers do you want to add?  ");
	_flushall();
	scanf("%d", &numNatNum);

	sumNatNum = sum_nat_nums(numNatNum);

	printf("The total is: %d\n", sumNatNum);

	return 0;
}

sum_nat_nums(int howMany)
{
	int answer = 1;

	if (howMany > 1)
	{
		answer = howMany + sum_nat_nums(howMany - 1);
	}

	return answer;
}
#include <stdio.h>

char scope[] = { "Global\n" };

int main(void)
{
	int i = 0;
	printf("%s", scope);

	char scope[] = { "Main\n" };
	printf("\t%s", scope);

	for (i = 0; i < 3; i++)
	{
		char scope[] = { "For\n" };
		printf("\t\t%s", scope);
	}
	
	printf("\t%s", scope);

	return 0;
}
#include <stdio.h>

int main(void)
{
	int i = 0;

	int normVar = 1;
	static int statVar = 1;

	for (i = 0; i < 10; i++)
	{
		printf("Norm = %-2d\t", normVar);
		printf("Stat = %-2d\n", statVar);

		normVar++;
		statVar++;
	}

	return 0;
}
#include <stdio.h>

int main(void)
{
	int i = 0;

	for (i = 0; i < 10; i++)
	{
		int normVar = 1;
		static int statVar = 1;

		printf("Norm = %-2d\t", normVar);
		printf("Stat = %-2d\n", statVar);

		normVar++;
		statVar++;
	}

	return 0;
}
#include <stdio.h>

int main(void)
{
	int i = 0;

	for (i = 0; i < 10; i++)
	{
		int normVar = 1;
		static int statVar = 1;

		printf("Norm = %-2d\t", normVar);
		printf("Stat = %-2d\n", statVar);

		normVar++;
		statVar++;
	}
	printf("Norm = %-2d\t", normVar);
	printf("Stat = %-2d\n", statVar);

	return 0;
}
#include <stdio.h>

int something, somethingElse;

int is_positive(int input);

int main(void)
{
	int something = 0;
	int somethingElse = 1;

	printf("False == %d \n", something);
	printf("True == %d \n", somethingElse);

	return 0;
}

int is_positive(int input)
{
	if (input >= 0)
	{
		return something;
	}
	else
	{
		return somethingElse;
	}
}
#include <stdio.h>

#define DEBUG
#ifdef DEBUG
#define DEBUG_INT(x) printf(#x " is %d", x)
#endif /* DEBUG */

int main(void)
{
	int someNum = 42;

#ifdef DEBUG
		DEBUG_INT(someNum);
#endif /* DEBUG */

	return 0;
}
#include <stdio.h>

#ifdef _DEBUG
#define DEBUG_INT(x) printf(#x " is %d", x)
#endif /* _DEBUG */

int main(void)
{
	int someNum = 42;

#ifdef _DEBUG
		DEBUG_INT(someNum);
#endif /* _DEBUG */

	return 0;
}
#include <stdio.h>

#ifdef _DEBUG
#define DEBUG_INT(x) printf(#x " is %d", x)
#else
#define DEBUG_INT(y) ;
#endif /* _DEBUG */

int main(void)
{
	int someNum = 42;

	DEBUG_INT(someNum);

	return 0;
}
#ifdef NULL
#undef NULL
#endif

#define NULL ((void *)0)

int main(void)
{
	char * stringPointer = NULL;

	return 0;
}
#define WRAP(x) #x

#ifdef __unix__
#define WRAPPER WRAP(__unix__)
#elif _WIN32
#	ifdef _WIN64
#		define WRAPPER WRAP(_WIN64)
#	else
#		define WRAPPER WRAP(_WIN32)
#	endif
#elif __linux__
#define WRAPPER WRAP(__linux__)
#elif __APPLE__
#define WRAPPER WRAP(__APPLE__)
#else
//#error "Unknown compiler"
#endif

int main(void)
{
	puts(WRAPPER);

	return 0;
}
#include <stdio.h>
//#define BAD_CONSTANT

#ifdef BAD_CONSTANT
#define UNIT 90COS
#endif

#ifndef BAD_CONSTANT
#define UNIT "90COS"
#endif

int main(void)
{
#ifdef BAD_CONSTANT
	char squadron[] = { "UNIT" };
#endif

#ifndef BAD_CONSTANT
	char squadron[] = { UNIT };
#endif

	puts(squadron);

	return 0;
}
#include <stdio.h>
//#define PARTIAL_SUB

#define COUNT 1

int main(void)
{
#ifdef PARTIAL_SUB 
	printf("LAUNCH# %d\n"\
, COUNTCOUNT);
#endif
#ifndef PARTIAL_SUB
	printf("LAUNCH# %d\n"\
		, (COUNT * 10) + (COUNT));
#endif
	printf("%d\n", COUNT * 3); 
	printf("%d\n", COUNT + COUNT); 
	printf("%d\n", COUNT);
	
	return 0;
}
#include <stdio.h>
//#define BAD_MACRO

#ifdef BAD_MACRO
#define TIMES(a,b) a * b
#endif

#ifndef BAD_MACRO
#define TIMES(a,b) ((a) * (b))
#endif

int main(void)
{
	printf("%d\n", (45 + 45) * 2);
	int quotient = TIMES(45 + 45, 2);
	printf("%d\n", quotient);

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <stdio.h>

//#define BAD_STATEMENTS

#ifdef BAD_STATEMENTS
#define DIE puts("Fatal Error"); exit(EXIT_FAILURE);
#endif

#ifndef BAD_STATEMENTS
#define DIE {puts("Fatal Error"); exit(EXIT_FAILURE);}
#endif

int main(void)
{
	int x = 3;

	if (0 == x)
		DIE;
	
	printf("%.5f", 10.0 / x);

	return 0;
}
#include <stdio.h>

//#define BAD_TYPE

#ifdef BAD_TYPE
#define NUM 68.8
#else
//#define NUM (float)68.8
const float NUM = 68.8;
#endif

int main(void)
{
	float x = NUM;

	int numSize = sizeof(NUM);
	int xSize = sizeof(x);

	double y = NUM;

	int ySize = sizeof(y);

	if (numSize != xSize)
	{
		printf("Float is not equal to NUM");
		return -1;
	}

	if (numSize != ySize)
	{
		printf("Double is not equal to NUM");
//		return -2;
	}
	
	return 0;
	// Replicate the example code from the slides
}
#include <stdio.h>

//#define BAD_DIMENSION

#ifndef BAD_DIMENSION
#define BUFF_SIZE 10
#endif

int main(void)
{

	_flushall();

#ifdef BAD_DIMENSION
	const int buffSize = 10;
	char myArray[buffSize];
	fgets(myArray, buffSize, stdin);
#endif

#ifndef BAD_DIMENSION
	char myArray[BUFF_SIZE] = { 0 };
	fgets(myArray, BUFF_SIZE, stdin);
#endif
		
	puts(myArray);

	return 0;
}
#include <stdio.h>
//#define BAD_CONSTANT

#ifdef BAD_CONSTANT
#define UNIT 90COS
#endif

#ifndef BAD_CONSTANT
#define UNIT "90COS"
#endif

int main(void)
{
#ifdef BAD_CONSTANT
	char squadron[] = { "UNIT" };
#endif

#ifndef BAD_CONSTANT
	char squadron[] = { UNIT };
#endif

	puts(squadron);

	return 0;
}
#include <stdio.h>

#define STRINGIFY_FOR_REAL(x) #x
#define STRINGIFY(a) STRINGIFY_FOR_REAL(a)

#define PASTE_FOR_REAL(x, y) x##y
#define PASTE(a, b) PASTE_FOR_REAL(a, b)

int main(void)
{
//	char PASTE(that, Guy)[] = {STRINGIFY(PASTE(That, Guy))};

//	puts(thatGuy);

	puts(STRINGIFY(PASTE(That, PASTE(Per, son))));

	puts(STRINGIFY_FOR_REAL(PASTE_FOR_REAL(That, Guy)));

	return 0;
}
#include <stdio.h>
#include <stdbool.h>

#define MERGE(x, y) x##y
#define FIRST_NAME(person, fName) strcpy(MERGE(person,.thePersonsFirstName), #fName);
#define LAST_NAME(person, lName) strcpy(MERGE(person,.thePersonsLastName), #lName);
#define ID(person, num) person##.thatPersonsEmployeedIdentificationNumber = num
#define COOL(person, boolean) person##.isThatPersonCoolOrNot = boolean

struct PeopleAtWork
{
	char thePersonsFirstName[50];
	char thePersonsLastName[50];
	int thatPersonsEmployeedIdentificationNumber;
	bool isThatPersonCoolOrNot;
};

int main(void)
{
	struct PeopleAtWork hark;

	FIRST_NAME(hark, Joseph);
	LAST_NAME(hark, Harkleroad);
	ID(hark, I.3.);
	COOL(hark, true);

	return 0;
}
#include <stdio.h>
#include <stdint.h>

#define BIT_MASK_MAKER(n) bitMaskValue##n = n

void print_binary(uint8_t value);

int main(void)
{
	uint8_t BIT_MASK_MAKER(1);
	uint8_t BIT_MASK_MAKER(2);
	uint8_t BIT_MASK_MAKER(4);
	uint8_t BIT_MASK_MAKER(8);
	uint8_t BIT_MASK_MAKER(16);
	uint8_t BIT_MASK_MAKER(32);
	uint8_t BIT_MASK_MAKER(64);
	uint8_t BIT_MASK_MAKER(128);

	print_binary(bitMaskValue1);
	print_binary(bitMaskValue2);
	print_binary(bitMaskValue4);
	print_binary(bitMaskValue8);
	print_binary(bitMaskValue16);
	print_binary(bitMaskValue32);
	print_binary(bitMaskValue64);
	print_binary(bitMaskValue128);

	return 0;
}

void print_binary(uint8_t value)
{
	int i = 0;
	uint8_t bitMask = 128;

	for (i = 0; i < 8; i++)
	{
		if (value & bitMask)
		{
			printf("%d", 1);
		}
		else
		{
			printf("%d", 0);
		}
		bitMask = bitMask >> 1;
	}
	putchar(10);

	return;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

#define DEBUG_INT(x) \
printf(#x " is %d\n", x)

int main(voiid)
{
	int getNum = 0;
	_flushall();
	scanf("%d", &getNum);
	DEBUG_INT(getNum);

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>

#define DIE(d) {puts(#d" err");\
exit(EXIT_FAILURE);}

int main(void)
{
	int x = 0;

	_flushall();
	scanf("%d", &x);

	if (0 == x)
		DIE(x);

	printf("%.5f", 10.0 / x);
	return 0;
}
#include <stdio.h>
#include "Math.h"
#include "Geometry.h"

int main(void)
{
	printf("PI is %.5f \n", (double)PI);

	return 0;
}
//////////////////////////////////////////////////////////////////////
///////////////////// PERFORMANCE LAB I.1.g-3 ////////////////////////
///////////////// Brute force an obfuscated string ///////////////////
//////////////////////////////////////////////////////////////////////
// C:\Temp\Obfuscated?.txt contains an obfuscated string
//     ? represents the fact that multiple files exist, (1 - 14)
//     Modify the "#define File?" line below to access different files
//     The ? number equates to the Obfuscated?.txt file that is opened
// The original string was XOR'd against a four (4) bit mask stored in
//     an unsigned char
// Shell code has been provided that already:
//     Safely read the file contents into a char array
//     Loops through each element of the char array
// Fill in the shell code, as documented, to brute force this
//     obfuscated string
// There are sections of this shell code that contain a comment block
//     specifying remaining code requirements.  Replace the comment
//     block with the code required.
// Visually scan the results for a human-readable string
//////////////////////////////////////////////////////////////////////

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#define BUFF_SIZE 256
#define MAX_MASKS 14
#define File1

int main(void)
{
	unsigned char cypherText[BUFF_SIZE] = { 0 }; // Stores the obfuscated text from the C:\Temp file
	unsigned char clearText[BUFF_SIZE] = { 0 }; // Stores the XOR'd cypherText 
	unsigned char xorMask = 0; // Stores the mask used to XOR the cypher text read from the file
	unsigned char inputChar = 255; // Temporarily stores file input character by character on its way to the cypher text array
	unsigned int i = 0; // Used to iterate through a loop
	unsigned int j = 0; // Used to iterate through a loop
	FILE * obfuscatedFile; // File pointer used to store the memory address of the opened Obfuscated?.txt file
#ifdef File1
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated1.txt", "r"); // Opens Obfuscated1.txt as read-only.  "#define File1" to access this file.
#endif
#ifdef File2
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated2.txt", "r"); // Opens Obfuscated2.txt as read-only.  "#define File2" to access this file.
#endif
#ifdef File3
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated3.txt", "r"); // Opens Obfuscated3.txt as read-only.  "#define File3" to access this file.
#endif
#ifdef File4
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated4.txt", "r"); // Opens Obfuscated4.txt as read-only.  "#define File4" to access this file.
#endif
#ifdef File5
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated5.txt", "r"); // Opens Obfuscated5.txt as read-only.  "#define File5" to access this file.
#endif
#ifdef File6
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated6.txt", "r"); // Opens Obfuscated6.txt as read-only.  "#define File6" to access this file.
#endif
#ifdef File7
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated7.txt", "r"); // Opens Obfuscated7.txt as read-only.  "#define File7" to access this file.
#endif
#ifdef File8
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated8.txt", "r"); // Opens Obfuscated8.txt as read-only.  "#define File8" to access this file.
#endif
#ifdef File9
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated9.txt", "r"); // Opens Obfuscated9.txt as read-only.  "#define File9" to access this file.
#endif
#ifdef File10
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated10.txt", "r"); // Opens Obfuscated10.txt as read-only.  "#define File10" to access this file.
#endif
#ifdef File11
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated11.txt", "r"); // Opens Obfuscated11.txt as read-only.  "#define File11" to access this file.
#endif
#ifdef File12
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated12.txt", "r"); // Opens Obfuscated12.txt as read-only.  "#define File12" to access this file.
#endif
#ifdef File13
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated13.txt", "r"); // Opens Obfuscated13.txt as read-only.  "#define File13" to access this file.
#endif
#ifdef File14
	obfuscatedFile = fopen("C:\\Temp\\Obfuscated14.txt", "r"); // Opens Obfuscated14.txt as read-only.  "#define File14" to access this file.
#endif

	/* Verify the file is open */
	if (obfuscatedFile) // File pointer is NOT NULL
	{
		/* Stops at newlines (10), line feeds (13), End of File (EOF), empty characters (inputChar), and verifies there's room at the end for a newline and NUL termination */
		while (inputChar != 10 && inputChar != 13 && inputChar != EOF && inputChar && i < (BUFF_SIZE - 1))
		{
			inputChar = fgetc(obfuscatedFile); // Reads one character from the open file into inputChar
			cypherText[i] = inputChar; // Assigns inputChar into an element of the cypher text array
			i++; // Increments the counter used to iterate through the array
		}
		cypherText[BUFF_SIZE - 1] = '\0'; // Manually null terminates the string... for safety
	}
	else // File pointer is NULL
	{
		fprintf(stderr, "Error:  Unable to input file! \n"); // Prints and error statement
		return -1; // Ends main() and returns a value of -1 to indicate an error
	}

	/* Iterate all possible	XOR mask values for each cypher text array */
	for (xorMask = 1; xorMask <= MAX_MASKS; xorMask++) // Iterates through xorMask (1, 2, 3, ... MAX_MASKS).  (see "#define MAX_MASKS")
	{
		for (j = 0; j < strlen(cypherText); j++) // Iterates through all elements of the cypherText array
		{
			if (cypherText[j] != 0 && cypherText[j] != 10 && cypherText[j] != 13) // Skips XOR'ing NULL, newline, and line feed characters...
			{
				/**************************************************************
				Write a statement, or block of code, here that:
				    A. Performs a Bitwise XOR between the unsigned char 
					variable named "xorMask" and index "j" of the unsigned char
					array named "cypherText"
					B. Assign the result from the Bitwise XOR into index "j" of
					the unsigned char array named "clearText"
					C. Remove, or comment, the printf statement on the line
					below.  It was only intended as a placeholder for the
					statement, or block of code, you must write here.
				**************************************************************/
				printf("****\nReplace this statement with a Bitwise XOR\n****"); // ...and XORs all the rest against xorMASK, storing the result in the clearText array
			}
			else
			{
				/**************************************************************
				Write a statement, or block of code, here that:
				A. Assigns index "j" of the unsigned char array named
				"cypherText" into index "j" of the unsigned char array named 
				"clearText"
				NOTE:  No XOR is necessary here because we want to preserve
				any NULL, newline, or line feed characters.
				**************************************************************/
				printf("****\nReplace this statement with an assignment statement\n****");
			}
		}
		printf("\nMask #%d produced the string: \n\t%s", xorMask, clearText); // This line is printed once for each of the XOR masks attempted on the cypher text
	}

	/* Print the Cleartext */
//	puts(clearText1); // DEBUGGING
	/* Print the Cyphertext */
//	puts(cypherText); // DEBUGGING
	/* Close the open file */
	fclose(obfuscatedFile); // Closes the open file

	return 0;
}
#include <stdio.h>

//#define BAD_MACRO

int main(void)
{
	printf("Old EOF:  %d \n", EOF);

#ifndef BAD_MACRO
#undef EOF
#endif

#define EOF (-3)
	printf("New EOF:  %d \n", EOF);

	return 0;
}

#include <stdio.h>

int main(void)
{
	char theDreamIsReal[6][6] = {
		{ "Leo" }, { "Chris" }, { "Ellen" }, { "Tom" }, { "Joe" }
	};

	printf("theDreamIsReal:\t%p\n", theDreamIsReal);
	printf("theDreamIsReal + 2:\t%p\n", theDreamIsReal + 2);
	printf("*(theDreamIsReal + 2):\t%s\n", *(theDreamIsReal + 2));
	printf("*(theDreamIsReal) + 3:\t%p\n", *(theDreamIsReal) + 3);
	printf("*(*(theDreamIsReal) + 3):\t%c\n", *(*(theDreamIsReal) + 3));
	printf("*(*(theDreamIsReal + 2) + 3):\t%c\n", *(*(theDreamIsReal + 2) + 3));

	char * test_ptr = *(theDreamIsReal) + 3;
	char test = *(*(theDreamIsReal)+3);

	return 0;
}
#include <stdio.h>

int main(void)
{
	int someIntArray[3][4] = { 0 };
	int row = 0;
	int col = 0;
	int value = 0;

	for (row = 0; row < 3; row++)
	{
		for (col = 0; col < 4; col++)
		{
//			value = row * col;
//			someIntArray[row][col] = value;
//			value++;
			*(*(someIntArray + row) + col) = value++;
		}
	}
//	someIntArray[0][0] = 0xBEEF;

	/* KSPLICE POINTER CHALLENGE */
	printf("%p\n", someIntArray);
	printf("%p\n", someIntArray + 1);
	printf("%p\n", &someIntArray);
	printf("%p\n", &someIntArray + 1);



	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-3 ////////////////////////////////////////////
////////////////////////////////////////////////// ADDRESS ARITHMETIC //////////////////////////////////////////////
/////////////////////////////////////////////////// "String Splitter" //////////////////////////////////////////////
/////////////////////////////////////////////////////// Stub Code //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Do *NOT* modify main() as it runs 19 tests on split_the_string()
// Define char * split_the_string(char * string_ptr, char delimiter) with the following requirements:
// Return Value - 
//     In short, split_the_string() returns a pointer to a second null-terminated string upon success.
//     ERROR_NULL_POINTER if string_ptr is NULL
//     ERROR_ABUNDANT_DELIMITER if string_ptr has more than one occurrence of delimiter
//     ERROR_NULL_DELIMITER if delimiter is '\0' (0x0)
//     string_ptr if delimiter is not found
// Parameters - 
//     string_ptr is a null-terminated char array (see: string) that may include a delimiting
//         character.  That delimiting character (see: char delimiter) is a logical (as in virtual) break point
//         between two separate phrases/words/characters/sentences within the original null-terminated char array
//         (string_ptr).  If there is a delimiting character, this function will return the pointer to the
//         beginning of the second null-terminated char array (in addition to performing other procedures).
//         
//     delimiter is the delimiting character that separates the two strings logically combined inside the
//         the null-terminated char array found at string_ptr.  (NOTE:  delimiter should *NOT* be '\0' (0x0)
// Purpose - This function separates a null-terminated string into two different strings, breaking them apart
//     at "delimiter".  The first part of the original string (the portion of the array preceding "delimiter")
//     will remain as is.  The deliminating character will be changed to a null character ('\0').  Then, the
//     memory address of the second part of the original string (the portion of the array following the "delimiter")
//     will be returned to the caller.  This function can't handle more than two strings so it verifies there's
//     only one occurrence of the delimiting character.  It also checks if string_ptr is NULL.  This function
//     only utilizes Address Arithmetic (see: Pointer Math) to access the data found in the char array found
//     at string_ptr. 
// Version 3 incorporates tests to verify the student re-nul-terminated the original string
//     by replacing the "delimiter" character with '\0'.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <string.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#ifdef ERROR_NULL_POINTER
#undef ERROR_NULL_POINTER
#endif
#define ERROR_NULL_POINTER ((char*)-1)

#ifdef ERROR_ABUNDANT_DELIMITER
#undef ERROR_ABUNDANT_DELIMITER
#endif
#define ERROR_ABUNDANT_DELIMITER ((char*)-2)

#ifdef ERROR_NULL_DELIMITER
#undef ERROR_NULL_DELIMITER
#endif
#define ERROR_NULL_DELIMITER ((char*)-3)

#ifndef TRUE
#define TRUE ((int)1)
#endif

#ifndef FALSE
#define FALSE ((int)0)
#endif

#define NUM_TEST_STRINGS 19

/*
 * FUNCTION:   char * split_the_string(char * string_ptr, char delimiter)
 *
 * ARGUMENTS:  string_ptr is a null-terminated string that may or may not contain a delimiting
 *                 character (see: delimiter) that logically separates two phrases to be "split"
 *             delimiter is the character that logically separates the two phrases that may be
 *                 in the null-terminated char array found at string_ptr
 *
 * RETURNS:	   char pointer to the first element of the second (null-terminated) phrase on success
 *             ERROR_NULL_POINTER if string_ptr is NULL
 *             ERROR_NULL_DELIMITER if delimiter is '\0' (0x0)
 *             ERROR_ABUNDANT_DELIMITER if string_ptr has more than one occurrence of delimiter
 *             string_ptr if delimiter is not found
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at string_ptr
 *             Only access elements of the char array found at string_ptr using address arithmetic
 *                 (AKA pointer math).  The definition of this function should be entirely devoid
 *                 of the [ and ] characters.  (e.g., string_ptr[i] is forbidden)
 *             The only guarantee for the arguments is that string_ptr is null-terminated
 *             There is no guarantee it has a delimiter (return string_ptr if not)
 *             There is no guarantee it only has one delimiter if there is one (return ERROR_ABUNDANT_DELIMITER if not)
 *             There is no guarantee the delimiter is some char *other* than '\0' (return ERROR_NULL_DELIMITER if not)
 *             There is no guarantee that string_ptr has an address (return ERROR_NULL_POINTER if NULL)
 */
char * split_the_string(char * string_ptr, char delimiter);

int main(void)
{
	int i = 0;								// Iterating variable
	char * secondString_ptr = NULL;			// Holds the return value of split_the_string()
	int tempValue = 0;						// Used to temporarily hold strcmp()'s return value
	int numTestsRun = 0;					// Number of tests that ran
	int numTestsPassed = 0;					// Number of ran tests that passed
	int thereWasAnErrorCode = FALSE;		// Boolean representation that one of the #defined ERROR_* codes were returned
	int thereShouldBeAnErrorCode = FALSE;	// Boolean representation that one of the #defined ERROR_* codes should be returned

	//////////////////////////////////
	// INPUT STRINGS
	//////////////////////////////////
	/*
	 *  Normal input
	 *  Two examples each of special characters, letters, and non-printable
	 *      characters as delimiters
	 */
	char inputString0[] = { "Integer/Float" };	// Delimiter = 0x2F
	char inputString1[] = { "aeiou" };			// Delimiter = 0x69
	char inputString2[] = { "First phrase&Second phrase" };	// Delimiter = 0xA
	inputString2[12] = 10; // Manually setting delimiter
	char inputString3[] = {"C programming uses the & character to determine the address of something."}; // Delimite = 0x26
	char inputString4[] = { "Bust A Move" }; // Delimiter = 0x41
	char inputString5[] = { "Alexander Graham was a Scottish-born scientist, inventor, engineer and innovator who is credited with patenting the first practical telephone." }; // Delimiter = 0x7
	inputString5[16] = 7; // Manually setting delimiter
	/*
	 *  No delimiters found
	 *  Two examples
	 */
	char inputString6[] = { "This string does not have any delimiters." }; // Delimiter = 0x5A
	char inputString7[] = { "!@#$%^&*()_+" }; // Delimiter = 0x20
	/*
	 *  Null pointers
	 *  Two examples
	 */
	char * inputString8 = NULL; // Delimiter doesn't matter
	char * inputString9 = NULL; // Delimiter doesn't matter
	/*
	 *  Extra delimiters
	 *  Two examples each of two, 10, and many delimiters
	 */
	char inputString10[] = { "This uses spaces." }; // Delimiter = 0x20
	char inputString11[] = { "Fandango" }; // Delimiter = 0x61
	char inputString12[] = { "This-string-uses-dashes-as-delimiters.  They-were-selected-by-Hark." }; // Delimiter = 0x2D
	char inputString13[22] = { "a b c d e f g h i j k" }; // Delimiter = 0xD
	for (i = 1; i <= 20; i+= 2)
	{
		inputString13[i] = 13;
	}
	char inputString14[] = { "The dental patient says, 'Aaaaaaaah'" }; // Delimiter = 0x61
	char inputString15[127] = { 0 }; // Delimiter = 0x7F
	for (i = 0; i < 126; i+=2)
	{
		inputString15[i] = 0x7F;							// Sets a multitude of delimiting characters
		inputString15[i + 1] = (char)((2 * i) - i + 1); // Sets each index to it's own index number in decimal
	}
	inputString15[126] = 0; // For safety
	char inputString16[127] = { 0 }; // Delimiter = 0x5A;
	for (i = 0; i < 126; i++)
	{
		inputString16[i] = 0x5A;
	}
	char inputString17[] = { "Normal string with the null character as the deliminator" }; // Deliminator = 0x0
	char inputString18[] = { 0, 'W', 'h', 'o', 'o', 'p', 's', 0 }; // Deliminator = 0x0
	char * inputStringArray[NUM_TEST_STRINGS] = { \
		inputString0, inputString1, inputString2, \
		inputString3, inputString4, inputString5, \
		inputString6, inputString7, inputString8, \
		inputString9, inputString10, inputString11, \
		inputString12, inputString13, inputString14, \
		inputString15, inputString16, inputString17, \
		inputString18 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// DELIMITING CHARACTERS
	//////////////////////////////////
	char inputStringDelimiters[NUM_TEST_STRINGS] = { \
		0x2F, 0x69, 0xA, \
		0x26, 0x41, 0x7, \
		0x5A, 0x20, 0x13, \
		0x37, 0x20, 0x61, \
		0x2D, 0xD, 0x61, \
		0x7F, 0x5A, 0x0, \
		0x0 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// NEW INPUT STRINGS
	//////////////////////////////////
	char newInputString0[] = { "Integer" };
	char newInputString1[] = { "ae" };
	char newInputString2[] = { "First phrase" };
	char newInputString3[] = { "C programming uses the " };
	char newInputString4[] = { "Bust " };
	char newInputString5[] = { "Alexander Graham" };
	char newInputString6[] = { "This string does not have any delimiters." };
	char newInputString7[] = { "!@#$%^&*()_+" };
	//char newInputString8[] = { 0 };
	//char newInputString9[] = { 0 };
	char * newInputString8 = NULL;
	char * newInputString9 = NULL;
	char newInputString10[] = { "This uses spaces." };
	char newInputString11[] = { "Fandango" };
	char newInputString12[] = { "This-string-uses-dashes-as-delimiters.  They-were-selected-by-Hark." };
	char newInputString13[22] = { "a b c d e f g h i j k" };
	for (i = 1; i <= 20; i += 2)
	{
		newInputString13[i] = 13;
	}
	char newInputString14[] = { "The dental patient says, 'Aaaaaaaah'" };
	char newInputString15[127] = { 0 };
	for (i = 0; i < 126; i += 2)
	{
		newInputString15[i] = 0x7F;							// Sets a multitude of delimiting characters
		newInputString15[i + 1] = (char)((2 * i) - i + 1); // Sets each index to it's own index number in decimal
	}
	newInputString15[126] = 0; // For safety
	char newInputString16[127] = { 0 };
	for (i = 0; i < 126; i++)
	{
		newInputString16[i] = 0x5A;
	}
	newInputString16[126] = 0; // For safety
	char newInputString17[] = { "Normal string with the null character as the deliminator" }; 
	char newInputString18[] = { 0, 'W', 'h', 'o', 'o', 'p', 's', 0 };

	char * newInputStringArray[NUM_TEST_STRINGS] = { \
		newInputString0, newInputString1, newInputString2, \
		newInputString3, newInputString4, newInputString5, \
		newInputString6, newInputString7, newInputString8, \
		newInputString9, newInputString10, newInputString11, \
		newInputString12, newInputString13, newInputString14, \
		newInputString15, newInputString16, newInputString17, \
		newInputString18 \
	};
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// OUTPUT STRINGS
	//////////////////////////////////
	/*
	 *  Expected output
	 *  Parallels the input strings
	 */
	char outputString0[] = { "Float" };	// Delimiter = /
	char outputString1[] = { "ou" };			// Delimiter = i
	char outputString2[] = { "Second phrase" };	// Delimiter = 0xA
	char outputString3[] = { " character to determine the address of something." }; // Delimite = &
	char outputString4[] = { " Move" }; // Delimiter = A
	char outputString5[] = { "was a Scottish-born scientist, inventor, engineer and innovator who is credited with patenting the first practical telephone." }; // Delimiter = 0x7
    /*
	 *  No delimiters found
	 *  Two examples
	 */
	char outputString6[] = { "This string does not have any delimiters." }; // Delimiter = Z
	char outputString7[] = { "!@#$%^&*()_+" }; // Delimiter = 0x20
	/*
	*  Null pointers
	*  Two examples
	*/
	char * outputString8 = ERROR_NULL_POINTER;
	char * outputString9 = ERROR_NULL_POINTER;
	/*
	*  Extra delimiters
	*  Two examples each of two, 10, and many delimiters
	*/
	char * outputString10 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x20
	char * outputString11 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x61
	char * outputString12 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x2D
	char * outputString13 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0xD
	char * outputString14 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x61
	char * outputString15 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x7F
	char * outputString16 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x5A;
	char * outputString17 = ERROR_NULL_DELIMITER; // Deliminator = 0x0
	char * outputString18 = ERROR_NULL_DELIMITER; // Deliminator = 0x0
	char * outputStringArray[NUM_TEST_STRINGS] = { \
		outputString0, outputString1, outputString2, \
		outputString3, outputString4, outputString5, \
		outputString6, outputString7, outputString8, \
		outputString9, outputString10, outputString11, \
		outputString12, outputString13, outputString14, \
		outputString15, outputString16, outputString17, \
		outputString18 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////


	for (i = 0; i < (int)NUM_TEST_STRINGS; i++)
	{
		thereWasAnErrorCode = FALSE; // Reset the variable
		thereShouldBeAnErrorCode = FALSE; // Reset the variable
		printf("\nUNIT TEST #%d:\n\t", i);
		secondString_ptr = split_the_string(inputStringArray[i], inputStringDelimiters[i]);
		if (secondString_ptr == ERROR_ABUNDANT_DELIMITER || \
			secondString_ptr == ERROR_NULL_DELIMITER || \
			secondString_ptr == ERROR_NULL_POINTER)
		{
			thereWasAnErrorCode = TRUE;
		}
		if (outputStringArray[i] == ERROR_ABUNDANT_DELIMITER || outputStringArray[i] == ERROR_NULL_DELIMITER || outputStringArray[i] == ERROR_NULL_POINTER)
		{
			thereShouldBeAnErrorCode = TRUE;
		}
		if (thereWasAnErrorCode == FALSE && thereShouldBeAnErrorCode == FALSE && secondString_ptr && outputStringArray[i]) // If both pointers are *NOT* NULL...
		{
			/* TEST ORIGINAL STRING WAS NEWLY NUL TERMINATED */
//			puts(secondString_ptr); // DEBUGGING
			printf("Original String Test:\t");
			tempValue = strcmp(newInputStringArray[i], inputStringArray[i]);
			numTestsRun++;
			if (!tempValue) // If those two strings match...
			{
				printf("Success\n\t"); // ...then let the human know...
				numTestsPassed++; // ...and increment the counter
			}
			else // ...Otherwise, they don't match...
			{
				printf("Error\n\t"); // ...so let the human know
				printf("Received:\t%s\n\t", inputStringArray[i]);
				printf("Expected:\t%s\n\t", newInputStringArray[i]);
			}

			/* TEST THE NEWLY SPLIT STRING */
			printf("Split String Test:\t");
			tempValue = strcmp(secondString_ptr, outputStringArray[i]); // ...then compare the two strings
			numTestsRun++;
			if (!tempValue) // If those two strings match...
			{
				puts("Success"); // ...then let the human know...
				numTestsPassed++; // ...and increment the counter
			}
			else // ...Otherwise, they don't match...
			{
				printf("Error\n\t"); // ...so let the human know
				printf("Received:\t%s\n\t", secondString_ptr);
				printf("Expected:\t%s\n\t", outputStringArray[i]);
			}
		}
		else	/* THERE WAS AN ERROR CODE */
		{
			/* TEST THE ORIGINAL STRING */
			printf("Original String Test:\t");
			
			if (newInputStringArray[i] > NULL && inputStringArray[i] > NULL)
			{
				tempValue = strcmp(newInputStringArray[i], inputStringArray[i]);
			}
			else
			{
				tempValue = !(newInputStringArray[i] == inputStringArray[i]);
			}
			numTestsRun++;
			if (!tempValue) // If those two strings match...
			{
				printf("Success\n\t"); // ...then let the human know...
				numTestsPassed++; // ...and increment the counter
			}
			else // ...Otherwise, they don't match...
			{
				printf("Error\n\t"); // ...so let the human know
				if (inputStringArray[i] != NULL && \
					inputStringArray[i] != ERROR_NULL_POINTER && \
					inputStringArray[i] != ERROR_ABUNDANT_DELIMITER && \
					inputStringArray[i] != ERROR_NULL_DELIMITER \
					)
				{
					printf("Original String:\t%s\n\t", inputStringArray[i]);
				}
				else
				{
					printf("Original String:\tNULL\n\t");
				}

				if (newInputStringArray[i] != NULL && \
					newInputStringArray[i] != ERROR_NULL_POINTER && \
					newInputStringArray[i] != ERROR_ABUNDANT_DELIMITER && \
					newInputStringArray[i] != ERROR_NULL_DELIMITER \
					)
				{
					printf("Expected String:\t%s\n\t", newInputStringArray[i]);
				}
				else
				{
					printf("Expected String:\tNULL\n\t");
				}
			}

			/* TEST THE NEWLY SPLIT STRING */
			printf("Split String Test:\t");
//			tempValue = strcmp(secondString_ptr, outputStringArray[i]); // ...then compare the two strings
			numTestsRun++;

			if (secondString_ptr == outputStringArray[i]) // Otherwise, there's at least one error so if they match...
			{
				puts("Success"); // ...then count that as a success because they match...
				numTestsPassed++; // ...and increment the counter
			}
			else // Otherwise, only one of the pointers is NULL so they don't match...
			{
				printf("Error\n\t"); // ...so let the human know
				if (secondString_ptr != NULL && \
					secondString_ptr != ERROR_NULL_POINTER && \
					secondString_ptr != ERROR_ABUNDANT_DELIMITER && \
					secondString_ptr != ERROR_NULL_DELIMITER \
					)
				{
					printf("Second String:\t%s\n\t", secondString_ptr);
				}
				else
				{
					printf("Second String:\t\tNULL\n\t");
				}

				if (outputStringArray[i] != NULL && \
					outputStringArray[i] != ERROR_NULL_POINTER && \
					outputStringArray[i] != ERROR_ABUNDANT_DELIMITER && \
					outputStringArray[i] != ERROR_NULL_DELIMITER \
					)
				{
					printf("Expected String:\t%s\n\t", outputStringArray[i]);
				}
				else
				{
					printf("Expected String:\tNULL\n\t");
				}
			}
		}
	}

	/* Let the human know how they did in a safe way */
	if (numTestsRun && numTestsPassed)
	{
		if (numTestsRun >= numTestsPassed)
		{
			printf("\nOf the %d tests run...\n%d tests passed.", numTestsRun, numTestsPassed);
		}
		else
		{
			fputs("Something has gone awry with the test counter.", stderr);
		}
	}

	return 0;
}

/*
 * FUNCTION:   char * split_the_string(char * string_ptr, char delimiter)
 *
 * ARGUMENTS:  string_ptr is a null-terminated string that may or may not contain a delimiting
 *                 character (see: delimiter) that logically separates two phrases to be "split"
 *             delimiter is the character that logically separates the two phrases that may be
 *                 in the null-terminated char array found at string_ptr
 *
 * RETURNS:	   char pointer to the first element of the second (null-terminated) phrase on success
 *             ERROR_NULL_POINTER if string_ptr is NULL
 *             ERROR_NULL_DELIMITER if delimiter is '\0' (0x0)
 *             ERROR_ABUNDANT_DELIMITER if string_ptr has more than one occurrence of delimiter
 *             string_ptr if delimiter is not found
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at string_ptr
 *             Only access elements of the char array found at string_ptr using address arithmetic
 *                 (AKA pointer math).  The definition of this function should be entirely devoid
 *                 of the [ and ] characters.  (e.g., string_ptr[i] is forbidden)
 *             The only guarantee for the arguments is that string_ptr is null-terminated
 *             There is no guarantee it has a delimiter (return string_ptr if not)
 *             There is no guarantee it only has one delimiter if there is one (return ERROR_ABUNDANT_DELIMITER if not)
 *             There is no guarantee the delimiter is some char *other* than '\0' (return ERROR_NULL_DELIMITER if not)
 *             There is no guarantee that string_ptr has an address (return ERROR_NULL_POINTER if NULL)
 */
char * split_the_string(char * string_ptr, char delimiter)
{
	///////////////////////
	///////////////////////
	///////////////////////

	/* Insert code here */

	///////////////////////
	///////////////////////
	///////////////////////

	return NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// PERFORMANCE LAB I.5.A-4 ////////////////////////////////////////////////
/////////////////////////////////////////////// FUNCTION ARGUMENTS //////////////////////////////////////////////////
///////////////////////////////////////////////// "Surfin' Bird" ////////////////////////////////////////////////////
/////////////////////////////////////////////////// Stub Code ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The students must define find_the_word() as specified below.
// Do *NOT* change main() as it contains 56 tests created for find_the_word()
// char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
// Return Value
//     char pointer to the first occurrence of searchWord in the null-terminated string found at sentence_ptr
//     NULL for all other situations (e.g., sentence_ptr is NULL, searchWord_ptr is NULL, errorCode_ptr is NULL)
// Parameters
//     sentence_ptr - char pointer to a null-terminated string which represents the sentence to search
//     searchWord_ptr - char pointer to a null-terminated string which represents the key to search for
//     errorCode_ptr - int pointer which will store an error code provided by find_the_word (see below)
// Purpose - Safely (e.g., watch for array overruns, mind the null-terminators) locate the memory address
//     of the string found at searchWord_ptr within sentence_ptr
// Requirements
//     Only Address Arithmetic is permitted to access sentence_ptr and searchWord_ptr.  The test input utilizes
//         methods other than address arithmetic but that is none of your concern.
//     Assign your error code to the memory address found in errorCode_ptr.  The error codes are #defined as constant
//         MACROS at the beginning of main() but are also listed here:
//         DEFAULT_ERROR_CODE - This is a default value used in testing.  The error code variable is initialized
//             with this value.  The error code variable is also reset to this value after each test.  The
//             students will not need to return this code.  It is entirely restricted to testing and debugging.
//         ERROR_CODE_SUCCESS - This is not an actual error.  Rather, it indicates your function has successfully
//             completed.  Use this MACRO to indicate success.
//         ERROR_NULL_SENTENCE_POINTER - This MACRO is to be used when sentence_ptr is NULL.  The return value of 
//             the function will of course be NULL but the function also needs to store this MACRO in the memory 
//             address stored in errorCode_ptr.
//         ERROR_NULL_SEARCH_POINTER - This MACRO is to be used when searchWord_ptr is NULL.  The return value 
//             of the function will of course be NULL but the function also needs to store this MACRO in the memory 
//             address stored in errorCode_ptr.
//         ERROR_SEARCH_NOT_FOUND - This MACRO is to be used when the string located at searchWord_ptr has not
//             been found inside the string located at sentence_ptr.  The return value of the function will of
//             course be NULL but the function also needs to store this MACRO in the memory address stored in
//             errorCode_ptr.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

/* Error code default value */
#ifdef DEFAULT_ERROR_CODE
#undef DEFAULT_ERROR_CODE
#endif
#define DEFAULT_ERROR_CODE 90318

/* Just in case NULL was undefined... */
#ifndef NULL
#define NULL ((void*) 0)
#endif

/* Error code for success */
#ifdef ERROR_CODE_SUCCESS
#undef ERROR_CODE_SUCCESS
#endif
#define ERROR_CODE_SUCCESS ((int)1)

/* Error code if sentence_ptr is NULL */
#ifdef ERROR_NULL_SENTENCE_POINTER
#undef ERROR_NULL_SENTENCE_POINTER
#endif
#define ERROR_NULL_SENTENCE_POINTER ((int)-1)

/* Error code if searchWord_ptr is NULL */
#ifdef ERROR_NULL_SEARCH_POINTER
#undef ERROR_NULL_SEARCH_POINTER
#endif
#define ERROR_NULL_SEARCH_POINTER ((int)-2)

/* Error code is the string in searchWord_ptr can not be found in the string located at sentence_ptr */
#ifdef ERROR_SEARCH_NOT_FOUND
#undef ERROR_SEARCH_NOT_FOUND
#endif
#define ERROR_SEARCH_NOT_FOUND ((int)-3)

/* Standard array size for manual dimension declaration */
#ifdef BUFF_SIZE
#undef BUFF_SIZE
#endif
#define BUFF_SIZE 1024

/*
 * FUNCTION:   find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
 *
 * ARGUMENTS:  sentence_ptr is a char pointer to a null-terminated string to search
 *             searchWord_ptr is a char pointer to a null-terminated string to find inside sentence_ptr
 *             errorCode_ptr is an int pointer.  Store your error code at this memory address.
 *
 * RETURNS:	   char pointer to the first occurrence of the searchWord_ptr string found in the
 *                 sentence_ptr string.  The char pointer should be a memory address in the
 *                 sentence_ptr string and this memory address should represent the first 'index'
 *                 of the searchWord_ptr string.  This memory address from the sentence_ptr string
 *                 should dereference to a value equivalent to searchWord_ptr[0].
 *             All other occurences should return NULL.  This includes, but is not limited to, the
 *                 following:
 *                     sentence_ptr is NULL
 *                     searchWord_ptr is NULL
 *                     errorCode_ptr is NULL
 *                     the searchWord_ptr string is not found in the sentence_ptr string
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at both sentence_ptr and searchWord_ptr
 *             Only access elements of the char array found at both sentence_ptr and searchWord_ptr
 *                 using address arithmetic (AKA pointer math).  The definition of this function should 
 *                 be entirely devoid of the [ and ] characters.  (e.g., sentence_ptr[i] is forbidden)
 *             The only guarantees for the arguments are:
 *                 Any string found at sentence_ptr is null-terminated
 *                 Any string found at searchWord_ptr is null-terminated
 *             There is no guarantee sentence_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee searchWord_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee errorCode_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee the string found at sentence_ptr contains the string found at 
 *                 searchWord_ptr (return NULL if the string at searchWord_ptr is not found and assign the
 *                 proper error code)
 *             There is no guarantee the strings found at both sentence_ptr and searchWord_ptr will
 *                 return a string length longer than zero (0)
 */
char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr);

int main(void)
{
	int i = 0; 
	int numTestsRun = 0;
	int numTestsPassed = 0;
	int putErrorCodeHere = DEFAULT_ERROR_CODE;
	char * tempReturnValue_ptr = NULL;
	char testChar1 = 0; // DEBUGGING
	char testChar2 = 0; // DEBUGGING

	/* TEST INPUT */
	// Three normal strings
	char testInput0[] = { "Good luck to you on this lab.\nI hope you do well." }; // Key: \n
	char testInput1[] = { "Normal test input.  'The' is the search key." }; // Key: The
	char testInput2[] = { "This is also normal input.  The 'bird' is the word." }; // Key: bird
	// Two strings that have duplicate keys
	char testInput3[] = { "This string is an example of a string that has two occurrences of the word 'is'." }; // Key: is
	char testInput4[] = { "The word 'the' is very common in the English language." }; // Key: the
	// Two strings that have multiple occurrences of the key
	char testInput5[] = { "Many English words are 'loan words', which is defined as 'a word that has been adopted from one language into another'." }; // Key: word
	char testInput6[] = { "The search keys don't have to be letters!  They could be any character or array of characters!  They could even be puntuation!  Maybe even non-printable characters!  Crazy, right?" }; // Key: "!  "
	// Two NULL strings to pass as sentence_ptr
	char * testInput7 = NULL; // Key: "Doesn't matter"
	char * testInput8 = NULL; // Key: "Don't bother"
	// Two real strings to pass alongside a NULL searchWord
	char testInput9[] = { "It's a shame to waste a perfectly good sentence." }; // Key:  NULL
	char testInput10[] = { "It's a shame to waste a perfectly good null-terminated string." }; // Key:  NULL
	// Two real strings to pass alongside a NULL errorCode
	char testInput11[] = { "At least electrons are free." }; // Key: are
	char testInput12[] = { "Even if they're not free, there is are a plethora of electrons freely available." }; // Key: e
	// Two strings that will pass more NULL search keys
	char testInput13[] = { "You can't find a key here!" }; // Key: NULL
	char testInput14[] = { "Take a picture!  It'll last longer." }; // Key: NULL
	// Two strings to pass long keys
	char testInput15[] = { "Now is the time for all good men to come to the aid of their country." }; // Key: "come to the aid"
	char testInput16[] = { "Sometimes it's hard to play the game the way it was intended to be played instead of following the game's rules as written." }; // Key: "play the game"
	// Edge cases that may break find_the_word()
	char testInput17[] = { "I hope you didn't find anything here!" }; // Key: '\0' (0x0)
	char testInput18[BUFF_SIZE] = { 0 }; // Key: "Don't do it!"
	char testInput19[] = { "Not a long string" }; // Key: "long string as a search key"
	char testInput20[] = { "part" }; // Key: "partial"
	char testInput21[BUFF_SIZE] = { 0 }; // Key: '\0' (0x0)
	// Two strings whose keys are non printable characters
	char testInput22[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x0 }; // Key: 0x8
	char testInput23[] = { 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x0 }; // Key: 0x1C
	// Two strings that include characters from the extended ASCII codes
	char testInput24[] = { '\n', 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, '\n', 0x7C, '$', '(', '5', ')', '$', 0x7C, '\n', 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, '\n', 0x0 }; // Key: 0xC4
//	puts(testInput24); // DEBUGGING
	char testInput25[] = {0xC4, 0x5C, 0x5F, 0x2, 0x5F, 0x2F, 0xC4, 0x0}; // Key: 0x2F
//	puts(testInput25); // DEBUGGING
	char testInput26[] = { "Sometimes keys are at the beggining of a string." }; // Key: "Sometime"
	char testInput27[] = { "When you lose an item, you always find it in the last place you look." }; // Key: "look."
	char * testInputArray[] = { \
		testInput0, testInput1, testInput2, \
		testInput3, testInput4, testInput5, \
		testInput6, testInput7, testInput8, \
		testInput9, testInput10, testInput11, \
		testInput12, testInput13, testInput14, \
		testInput15, testInput16, testInput17, \
		testInput18, testInput19, testInput20, \
		testInput21, testInput22, testInput23, \
		testInput24, testInput25, testInput26, \
	    testInput27 };

	/* TEST SEARCH KEYS */
	char testKey0[] = {10,0};
	char testKey1[] = { "The" };
	char testKey2[] = { "bird" };
	char testKey3[] = { "is" };
	char testKey4[] = { "the" };
	char testKey5[] = { "word" };
	char testKey6[] = { "!  " };
	char testKey7[] = { "Doesn't matter" };
	char testKey8[] = { "Don't bother" };
	char * testKey9 = NULL;
	char * testKey10 = NULL;
	char testKey11[] = {"are"};
	char testKey12[] = {"e"};
	char * testKey13 = NULL;
	char * testKey14 = NULL;
	char testKey15[] = {"come to the aid"};
	char testKey16[] = {"play the game"};
	char testKey17[] = {0x0, 0x0};
	char testKey18[] = {"Don't do it!"};
	char testKey19[] = {"long string as a search key"};
	char testKey20[] = {"partial"};
	char testKey21[1] = {0x0};
	char testKey22[] = {0x8, 0x0};
	char testKey23[] = {0x1C, 0x0};
	char testKey24[] = {0xC4, 0x0};
	char testKey25[] = {0x2F, 0x0};
	char testKey26[] = { "Sometime" };
	char testKey27[] = { "look." };
	char * testKeyArray[] = { \
		testKey0, testKey1, testKey2, \
		testKey3, testKey4, testKey5, \
		testKey6, testKey7, testKey8, \
		testKey9, testKey10, testKey11, \
		testKey12, testKey13, testKey14, \
		testKey15, testKey16, testKey17, \
		testKey18, testKey19, testKey20, \
		testKey21, testKey22, testKey23, \
		testKey24, testKey25, testKey26, \
	    testKey27 };

	/* TEST ERROR CODE POINTERS */
	int * errorCodePointerArray[] = { \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, NULL, \
		NULL, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
	    &putErrorCodeHere };

	/* TEST RETURN VALUES */
	char * expectedReturnValueArray[] = { \
		&testInput0[29], &testInput1[21], &testInput2[33], \
		&testInput3[2], &testInput4[10], &testInput5[13], \
		&testInput6[40], testInput7, testInput8, \
		NULL, NULL, NULL, \
		NULL, NULL, NULL, \
		&testInput15[36], &testInput16[23], NULL, \
		NULL, NULL, NULL, \
		NULL, &testInput22[7], &testInput23[2], \
		&testInput24[17], &testInput25[5], &testInput26[0], \
	    &testInput27[64]};

	/* TEST ERROR CODES */
	int expectedErrorCodeArray[] = { \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_NULL_SENTENCE_POINTER, ERROR_NULL_SENTENCE_POINTER, \
		ERROR_NULL_SEARCH_POINTER, ERROR_NULL_SEARCH_POINTER, DEFAULT_ERROR_CODE, \
		DEFAULT_ERROR_CODE, ERROR_NULL_SEARCH_POINTER, ERROR_NULL_SEARCH_POINTER, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_SEARCH_NOT_FOUND, \
		ERROR_SEARCH_NOT_FOUND, ERROR_SEARCH_NOT_FOUND, ERROR_SEARCH_NOT_FOUND, \
		ERROR_SEARCH_NOT_FOUND, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
	    ERROR_CODE_SUCCESS };

	/* CALCULATE THE NUMBER OF TESTS */
	int numTotalTests = sizeof(testInputArray) / sizeof(testInputArray[0]);
//	printf("The length of the test array is: %d \n", sizeof(testInputArray)/sizeof(testInputArray[0])); // DEBUGGING

	/* EXECUTE THE TESTS */
	for (i = 0; i < numTotalTests; i++)
	{
		/* 0. TEST HEADER */
		printf("\n");
		printf("************\n");
		printf("* TEST #%02d *\n", i);
		printf("************\n");
		tempReturnValue_ptr = find_the_word(testInputArray[i], testKeyArray[i], errorCodePointerArray[i]);

		/* 1. TEST RETURN VALUE */
		numTestsRun++;
		printf("\tReturn Value Test:\t");
		if (tempReturnValue_ptr == expectedReturnValueArray[i])
		{
			puts("Pass");
			numTestsPassed++;
		}
		else
		{
			puts("FAIL!");
			printf("\t\tExpected pointer:\t%p\n", expectedReturnValueArray[i]);
			printf("\t\tReceived pointer:\t%d\n", tempReturnValue_ptr);
		}

		/* 2. TEST ERROR CODE */
		numTestsRun++;
		printf("\tError Code Test:\t");
		if (putErrorCodeHere == expectedErrorCodeArray[i])
		{
			puts("Pass");
			numTestsPassed++;
		}
		else
		{
			puts("FAIL!");
			printf("\t\tExpected error code:\t%d\n", expectedErrorCodeArray[i]);
			printf("\t\tReceived error code:\t%d\n", putErrorCodeHere);
			if (putErrorCodeHere == DEFAULT_ERROR_CODE)
			{
				puts("\t\tError code not even updated!");
			}
		}

		putErrorCodeHere = DEFAULT_ERROR_CODE; // Reset error code
	}

	if (numTestsRun)
	{
		printf("\n\n\n*******************************\n");
		printf("Out of the %d tests that ran...\n", numTestsRun);
		printf("%d tests passed.\n", numTestsPassed);
		printf("*******************************\n"); 
	}
	
	return 0;
}

/*
 * FUNCTION:   find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
 *
 * ARGUMENTS:  sentence_ptr is a char pointer to a null-terminated string to search
 *             searchWord_ptr is a char pointer to a null-terminated string to find inside sentence_ptr
 *             errorCode_ptr is an int pointer.  Store your error code at this memory address.
 *
 * RETURNS:	   char pointer to the first occurrence of the searchWord_ptr string found in the
 *                 sentence_ptr string.  The char pointer should be a memory address in the
 *                 sentence_ptr string and this memory address should represent the first 'index'
 *                 of the searchWord_ptr string.  This memory address from the sentence_ptr string
 *                 should dereference to a value equivalent to searchWord_ptr[0].
 *             All other occurences should return NULL.  This includes, but is not limited to, the
 *                 following:
 *                     sentence_ptr is NULL
 *                     searchWord_ptr is NULL
 *                     errorCode_ptr is NULL
 *                     the searchWord_ptr string is not found in the sentence_ptr string
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at both sentence_ptr and searchWord_ptr
 *             Only access elements of the char array found at both sentence_ptr and searchWord_ptr
 *                 using address arithmetic (AKA pointer math).  The definition of this function should
 *                 be entirely devoid of the [ and ] characters.  (e.g., sentence_ptr[i] is forbidden)
 *             The only guarantees for the arguments are:
 *                 Any string found at sentence_ptr is null-terminated
 *                 Any string found at searchWord_ptr is null-terminated
 *             There is no guarantee sentence_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee searchWord_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee errorCode_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee the string found at sentence_ptr contains the string found at
 *                 searchWord_ptr (return NULL if the string at searchWord_ptr is not found and assign the
 *                 proper error code)
 *             There is no guarantee the strings found at both sentence_ptr and searchWord_ptr will
 *                 return a string length longer than zero (0)
 */
char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
{

	/* INSERT YOUR CODE HERE */

	return 90;	// You will likely need to change this return statement
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// PERFORMANCE LAB I.5.A-4 ////////////////////////////////////////////////
/////////////////////////////////////////////// FUNCTION ARGUMENTS //////////////////////////////////////////////////
///////////////////////////////////////////////// "Surfin' Bird" ////////////////////////////////////////////////////
/////////////////////////////////////////////// Instructor Solution /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The students must define find_the_word() as specified below.
// Do *NOT* change main() as it contains 56 tests created for find_the_word()
// char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
// Return Value
//     char pointer to the first occurrence of searchWord in the null-terminated string found at sentence_ptr
//     NULL for all other situations (e.g., sentence_ptr is NULL, searchWord_ptr is NULL, errorCode_ptr is NULL)
// Parameters
//     sentence_ptr - char pointer to a null-terminated string which represents the sentence to search
//     searchWord_ptr - char pointer to a null-terminated string which represents the key to search for
//     errorCode_ptr - int pointer which will store an error code provided by find_the_word (see below)
// Purpose - Safely (e.g., watch for array overruns, mind the null-terminators) locate the memory address
//     of the string found at searchWord_ptr within sentence_ptr
// Requirements
//     Only Address Arithmetic is permitted to access sentence_ptr and searchWord_ptr.  The test input utilizes
//         methods other than address arithmetic but that is none of your concern.
//     Assign your error code to the memory address found in errorCode_ptr.  The error codes are #defined as constant
//         MACROS at the beginning of main() but are also listed here:
//         DEFAULT_ERROR_CODE - This is a default value used in testing.  The error code variable is initialized
//             with this value.  The error code variable is also reset to this value after each test.  The
//             students will not need to return this code.  It is entirely restricted to testing and debugging.
//         ERROR_CODE_SUCCESS - This is not an actual error.  Rather, it indicates your function has successfully
//             completed.  Use this MACRO to indicate success.
//         ERROR_NULL_SENTENCE_POINTER - This MACRO is to be used when sentence_ptr is NULL.  The return value of 
//             the function will of course be NULL but the function also needs to store this MACRO in the memory 
//             address stored in errorCode_ptr.
//         ERROR_NULL_SEARCH_POINTER - This MACRO is to be used when searchWord_ptr is NULL.  The return value 
//             of the function will of course be NULL but the function also needs to store this MACRO in the memory 
//             address stored in errorCode_ptr.
//         ERROR_SEARCH_NOT_FOUND - This MACRO is to be used when the string located at searchWord_ptr has not
//             been found inside the string located at sentence_ptr.  The return value of the function will of
//             course be NULL but the function also needs to store this MACRO in the memory address stored in
//             errorCode_ptr.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

/* Error code default value */
#ifdef DEFAULT_ERROR_CODE
#undef DEFAULT_ERROR_CODE
#endif
#define DEFAULT_ERROR_CODE 90318

/* Just in case NULL was undefined... */
#ifndef NULL
#define NULL ((void*) 0)
#endif

/* Error code for success */
#ifdef ERROR_CODE_SUCCESS
#undef ERROR_CODE_SUCCESS
#endif
#define ERROR_CODE_SUCCESS ((int)1)

/* Error code if sentence_ptr is NULL */
#ifdef ERROR_NULL_SENTENCE_POINTER
#undef ERROR_NULL_SENTENCE_POINTER
#endif
#define ERROR_NULL_SENTENCE_POINTER ((int)-1)

/* Error code if searchWord_ptr is NULL */
#ifdef ERROR_NULL_SEARCH_POINTER
#undef ERROR_NULL_SEARCH_POINTER
#endif
#define ERROR_NULL_SEARCH_POINTER ((int)-2)

/* Error code is the string in searchWord_ptr can not be found in the string located at sentence_ptr */
#ifdef ERROR_SEARCH_NOT_FOUND
#undef ERROR_SEARCH_NOT_FOUND
#endif
#define ERROR_SEARCH_NOT_FOUND ((int)-3)

/* Standard array size for manual dimension declaration */
#ifdef BUFF_SIZE
#undef BUFF_SIZE
#endif
#define BUFF_SIZE 1024

/*
 * FUNCTION:   find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
 *
 * ARGUMENTS:  sentence_ptr is a char pointer to a null-terminated string to search
 *             searchWord_ptr is a char pointer to a null-terminated string to find inside sentence_ptr
 *             errorCode_ptr is an int pointer.  Store your error code at this memory address.
 *
 * RETURNS:	   char pointer to the first occurrence of the searchWord_ptr string found in the
 *                 sentence_ptr string.  The char pointer should be a memory address in the
 *                 sentence_ptr string and this memory address should represent the first 'index'
 *                 of the searchWord_ptr string.  This memory address from the sentence_ptr string
 *                 should dereference to a value equivalent to searchWord_ptr[0].
 *             All other occurences should return NULL.  This includes, but is not limited to, the
 *                 following:
 *                     sentence_ptr is NULL
 *                     searchWord_ptr is NULL
 *                     errorCode_ptr is NULL
 *                     the searchWord_ptr string is not found in the sentence_ptr string
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at both sentence_ptr and searchWord_ptr
 *             Only access elements of the char array found at both sentence_ptr and searchWord_ptr
 *                 using address arithmetic (AKA pointer math).  The definition of this function should 
 *                 be entirely devoid of the [ and ] characters.  (e.g., sentence_ptr[i] is forbidden)
 *             The only guarantees for the arguments are:
 *                 Any string found at sentence_ptr is null-terminated
 *                 Any string found at searchWord_ptr is null-terminated
 *             There is no guarantee sentence_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee searchWord_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee errorCode_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee the string found at sentence_ptr contains the string found at 
 *                 searchWord_ptr (return NULL if the string at searchWord_ptr is not found and assign the
 *                 proper error code)
 *             There is no guarantee the strings found at both sentence_ptr and searchWord_ptr will
 *                 return a string length longer than zero (0)
 */
char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr);

int main(void)
{
	int i = 0; 
	int numTestsRun = 0;
	int numTestsPassed = 0;
	int putErrorCodeHere = DEFAULT_ERROR_CODE;
	char * tempReturnValue_ptr = NULL;
	char testChar1 = 0; // DEBUGGING
	char testChar2 = 0; // DEBUGGING

	/* TEST INPUT */
	// Three normal strings
	char testInput0[] = { "Good luck to you on this lab.\nI hope you do well." }; // Key: \n
	char testInput1[] = { "Normal test input.  'The' is the search key." }; // Key: The
	char testInput2[] = { "This is also normal input.  The 'bird' is the word." }; // Key: bird
	// Two strings that have duplicate keys
	char testInput3[] = { "This string is an example of a string that has two occurrences of the word 'is'." }; // Key: is
	char testInput4[] = { "The word 'the' is very common in the English language." }; // Key: the
	// Two strings that have multiple occurrences of the key
	char testInput5[] = { "Many English words are 'loan words', which is defined as 'a word that has been adopted from one language into another'." }; // Key: word
	char testInput6[] = { "The search keys don't have to be letters!  They could be any character or array of characters!  They could even be puntuation!  Maybe even non-printable characters!  Crazy, right?" }; // Key: "!  "
	// Two NULL strings to pass as sentence_ptr
	char * testInput7 = NULL; // Key: "Doesn't matter"
	char * testInput8 = NULL; // Key: "Don't bother"
	// Two real strings to pass alongside a NULL searchWord
	char testInput9[] = { "It's a shame to waste a perfectly good sentence." }; // Key:  NULL
	char testInput10[] = { "It's a shame to waste a perfectly good null-terminated string." }; // Key:  NULL
	// Two real strings to pass alongside a NULL errorCode
	char testInput11[] = { "At least electrons are free." }; // Key: are
	char testInput12[] = { "Even if they're not free, there is are a plethora of electrons freely available." }; // Key: e
	// Two strings that will pass more NULL search keys
	char testInput13[] = { "You can't find a key here!" }; // Key: NULL
	char testInput14[] = { "Take a picture!  It'll last longer." }; // Key: NULL
	// Two strings to pass long keys
	char testInput15[] = { "Now is the time for all good men to come to the aid of their country." }; // Key: "come to the aid"
	char testInput16[] = { "Sometimes it's hard to play the game the way it was intended to be played instead of following the game's rules as written." }; // Key: "play the game"
	// Edge cases that may break find_the_word()
	char testInput17[] = { "I hope you didn't find anything here!" }; // Key: '\0' (0x0)
	char testInput18[BUFF_SIZE] = { 0 }; // Key: "Don't do it!"
	char testInput19[] = { "Not a long string" }; // Key: "long string as a search key"
	char testInput20[] = { "part" }; // Key: "partial"
	char testInput21[BUFF_SIZE] = { 0 }; // Key: '\0' (0x0)
	// Two strings whose keys are non printable characters
	char testInput22[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x0 }; // Key: 0x8
	char testInput23[] = { 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x0 }; // Key: 0x1C
	// Two strings that include characters from the extended ASCII codes
	char testInput24[] = { '\n', 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, '\n', 0x7C, '$', '(', '5', ')', '$', 0x7C, '\n', 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, '\n', 0x0 }; // Key: 0xC4
//	puts(testInput24); // DEBUGGING
	char testInput25[] = {0xC4, 0x5C, 0x5F, 0x2, 0x5F, 0x2F, 0xC4, 0x0}; // Key: 0x2F
//	puts(testInput25); // DEBUGGING
	char testInput26[] = { "Sometimes keys are at the beggining of a string." }; // Key: "Sometime"
	char testInput27[] = { "When you lose an item, you always find it in the last place you look." }; // Key: "look."
	char * testInputArray[] = { \
		testInput0, testInput1, testInput2, \
		testInput3, testInput4, testInput5, \
		testInput6, testInput7, testInput8, \
		testInput9, testInput10, testInput11, \
		testInput12, testInput13, testInput14, \
		testInput15, testInput16, testInput17, \
		testInput18, testInput19, testInput20, \
		testInput21, testInput22, testInput23, \
		testInput24, testInput25, testInput26, \
	    testInput27 };

	/* TEST SEARCH KEYS */
	char testKey0[] = {10,0};
	char testKey1[] = { "The" };
	char testKey2[] = { "bird" };
	char testKey3[] = { "is" };
	char testKey4[] = { "the" };
	char testKey5[] = { "word" };
	char testKey6[] = { "!  " };
	char testKey7[] = { "Doesn't matter" };
	char testKey8[] = { "Don't bother" };
	char * testKey9 = NULL;
	char * testKey10 = NULL;
	char testKey11[] = {"are"};
	char testKey12[] = {"e"};
	char * testKey13 = NULL;
	char * testKey14 = NULL;
	char testKey15[] = {"come to the aid"};
	char testKey16[] = {"play the game"};
	char testKey17[] = {0x0, 0x0};
	char testKey18[] = {"Don't do it!"};
	char testKey19[] = {"long string as a search key"};
	char testKey20[] = {"partial"};
	char testKey21[1] = {0x0};
	char testKey22[] = {0x8, 0x0};
	char testKey23[] = {0x1C, 0x0};
	char testKey24[] = {0xC4, 0x0};
	char testKey25[] = {0x2F, 0x0};
	char testKey26[] = { "Sometime" };
	char testKey27[] = { "look." };
	char * testKeyArray[] = { \
		testKey0, testKey1, testKey2, \
		testKey3, testKey4, testKey5, \
		testKey6, testKey7, testKey8, \
		testKey9, testKey10, testKey11, \
		testKey12, testKey13, testKey14, \
		testKey15, testKey16, testKey17, \
		testKey18, testKey19, testKey20, \
		testKey21, testKey22, testKey23, \
		testKey24, testKey25, testKey26, \
	    testKey27 };

	/* TEST ERROR CODE POINTERS */
	int * errorCodePointerArray[] = { \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, NULL, \
		NULL, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
	    &putErrorCodeHere };

	/* TEST RETURN VALUES */
	char * expectedReturnValueArray[] = { \
		&testInput0[29], &testInput1[21], &testInput2[33], \
		&testInput3[2], &testInput4[10], &testInput5[13], \
		&testInput6[40], testInput7, testInput8, \
		NULL, NULL, NULL, \
		NULL, NULL, NULL, \
		&testInput15[36], &testInput16[23], NULL, \
		NULL, NULL, NULL, \
		NULL, &testInput22[7], &testInput23[2], \
		&testInput24[17], &testInput25[5], &testInput26[0], \
	    &testInput27[64]};

	/* TEST ERROR CODES */
	int expectedErrorCodeArray[] = { \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_NULL_SENTENCE_POINTER, ERROR_NULL_SENTENCE_POINTER, \
		ERROR_NULL_SEARCH_POINTER, ERROR_NULL_SEARCH_POINTER, DEFAULT_ERROR_CODE, \
		DEFAULT_ERROR_CODE, ERROR_NULL_SEARCH_POINTER, ERROR_NULL_SEARCH_POINTER, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_SEARCH_NOT_FOUND, \
		ERROR_SEARCH_NOT_FOUND, ERROR_SEARCH_NOT_FOUND, ERROR_SEARCH_NOT_FOUND, \
		ERROR_SEARCH_NOT_FOUND, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
	    ERROR_CODE_SUCCESS };

	/* CALCULATE THE NUMBER OF TESTS */
	int numTotalTests = sizeof(testInputArray) / sizeof(testInputArray[0]);
//	printf("The length of the test array is: %d \n", sizeof(testInputArray)/sizeof(testInputArray[0])); // DEBUGGING

	/* EXECUTE THE TESTS */
	for (i = 0; i < numTotalTests; i++)
	{
		/* 0. TEST HEADER */
		printf("\n");
		printf("************\n");
		printf("* TEST #%02d *\n", i);
		printf("************\n");
		tempReturnValue_ptr = find_the_word(testInputArray[i], testKeyArray[i], errorCodePointerArray[i]);

		/* 1. TEST RETURN VALUE */
		numTestsRun++;
		printf("\tReturn Value Test:\t");
		if (tempReturnValue_ptr == expectedReturnValueArray[i])
		{
			puts("Pass");
			numTestsPassed++;
		}
		else
		{
			puts("FAIL!");
			printf("\t\tExpected pointer:\t%p\n", expectedReturnValueArray[i]);
			printf("\t\tReceived pointer:\t%d\n", tempReturnValue_ptr);
		}

		/* 2. TEST ERROR CODE */
		numTestsRun++;
		printf("\tError Code Test:\t");
		if (putErrorCodeHere == expectedErrorCodeArray[i])
		{
			puts("Pass");
			numTestsPassed++;
		}
		else
		{
			puts("FAIL!");
			printf("\t\tExpected error code:\t%d\n", expectedErrorCodeArray[i]);
			printf("\t\tReceived error code:\t%d\n", putErrorCodeHere);
			if (putErrorCodeHere == DEFAULT_ERROR_CODE)
			{
				puts("\t\tError code not even updated!");
			}
		}

		putErrorCodeHere = DEFAULT_ERROR_CODE; // Reset error code
	}

	if (numTestsRun)
	{
		printf("\n\n\n*******************************\n");
		printf("Out of the %d tests that ran...\n", numTestsRun);
		printf("%d tests passed.\n", numTestsPassed);
		printf("*******************************\n"); 
	}
	
	return 0;
}

/*
 * FUNCTION:   find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
 *
 * ARGUMENTS:  sentence_ptr is a char pointer to a null-terminated string to search
 *             searchWord_ptr is a char pointer to a null-terminated string to find inside sentence_ptr
 *             errorCode_ptr is an int pointer.  Store your error code at this memory address.
 *
 * RETURNS:	   char pointer to the first occurrence of the searchWord_ptr string found in the
 *                 sentence_ptr string.  The char pointer should be a memory address in the
 *                 sentence_ptr string and this memory address should represent the first 'index'
 *                 of the searchWord_ptr string.  This memory address from the sentence_ptr string
 *                 should dereference to a value equivalent to searchWord_ptr[0].
 *             All other occurences should return NULL.  This includes, but is not limited to, the
 *                 following:
 *                     sentence_ptr is NULL
 *                     searchWord_ptr is NULL
 *                     errorCode_ptr is NULL
 *                     the searchWord_ptr string is not found in the sentence_ptr string
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at both sentence_ptr and searchWord_ptr
 *             Only access elements of the char array found at both sentence_ptr and searchWord_ptr
 *                 using address arithmetic (AKA pointer math).  The definition of this function should
 *                 be entirely devoid of the [ and ] characters.  (e.g., sentence_ptr[i] is forbidden)
 *             The only guarantees for the arguments are:
 *                 Any string found at sentence_ptr is null-terminated
 *                 Any string found at searchWord_ptr is null-terminated
 *             There is no guarantee sentence_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee searchWord_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee errorCode_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee the string found at sentence_ptr contains the string found at
 *                 searchWord_ptr (return NULL if the string at searchWord_ptr is not found and assign the
 *                 proper error code)
 *             There is no guarantee the strings found at both sentence_ptr and searchWord_ptr will
 *                 return a string length longer than zero (0)
 */
char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
{
	char testChar1 = 0; // DEBUGGING
	char testChar2 = 0; // DEBUGGING
	char * returnValue_ptr = NULL;
	int sentenceLength = 0;
	int searchWordLength = 0;
	int i = 0;
	int j = 0;

	if (!sentence_ptr)
	{
		returnValue_ptr = NULL;
		*errorCode_ptr = ERROR_NULL_SENTENCE_POINTER;
	}
	else if (!searchWord_ptr)
	{
		returnValue_ptr = NULL;
		*errorCode_ptr = ERROR_NULL_SEARCH_POINTER;
	}
	else if (!errorCode_ptr)
	{
		returnValue_ptr = NULL;
	}
	else
	{
		sentenceLength = strlen(sentence_ptr);
		searchWordLength = strlen(searchWord_ptr);
		if (searchWordLength > sentenceLength)
		{
			returnValue_ptr = NULL;
			*errorCode_ptr = ERROR_SEARCH_NOT_FOUND;
		}
		else
		{
			*errorCode_ptr = ERROR_SEARCH_NOT_FOUND;
			for (i = 0; i <= (sentenceLength - searchWordLength); i++)
			{
				testChar1 = *(sentence_ptr + i);
				testChar2 = *(searchWord_ptr);
				if (*(sentence_ptr + i) == *(searchWord_ptr)) // If the first letter of the Key matches the current value...
				{
					if (searchWordLength == 1)
					{
						returnValue_ptr = (sentence_ptr + i);
						*errorCode_ptr = ERROR_CODE_SUCCESS;
						return returnValue_ptr;
					}
					else
					{
						for (j = 1; j < searchWordLength; j++) // ...check for the rest of the Key
						{
							if (*(sentence_ptr + i + j) != *(searchWord_ptr + j))
							{
								break; // No match
							}
							else if (j == (searchWordLength - 1))
							{
								returnValue_ptr = (sentence_ptr + i);
								*errorCode_ptr = ERROR_CODE_SUCCESS;
								return returnValue_ptr;
							}
						}
					}
				}
			}
		}
	}

	return returnValue_ptr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// DEMONSTRATION LAB I.5.A-5 /////////////////////////////////////////////
////////////////////////////////////////////////// POINTER ARRAYS ///////////////////////////////////////////////////
/////////////////////////////////////////////////// "Legilimency" ///////////////////////////////////////////////////
////////////////////////////////////////////// Stub Code (bad function) /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test sorting_hat()
// The version of sorting_hat() in this solution is 100% functional
// The student will write parallel arrays of test parameters for sorting_hat()
//     char ** stringArray_ptr - An array of string arrays (not a typo) is necessary to pass to sorting_hat()
//     int numOfStrings - A parallel integer array of numOfStrings will need to hold the number of strings 
//         each string array holds
//     int * errorCode - No array is needed for the memory address, merely passing the memory address of an
//         integer variable should suffice
// The student must also write parallel arrays to test the expected output of sorting_hat()
//     "character pointer" return value - A parallel array of character pointers is necessary to test the return
//         values of sorting_hat()
//     errorCode - A parallel integer array of expected errorCodes is also necessary to test sorting_hat()
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke sorting_hat() with an array of strings, the number of the strings in that array, and 
//             an integer pointer to store the resulting errorCode.
//         2. Test the return value of sorting_hat() against what is expected.
//         3. Test the errorCode value against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// The student will not be testing convert_char_to_lower()
// 
// TESTING SPECIFICATIONS
// Write two tests for each of the following conditions:
//     1. Normal input
//     2. The array of strings passed to sorting_hat() include alphabetically 'first' matching strings 
//         NOTE: The first matching strings should be returned
//     3. Pass a NULL pointer as stringArray_ptr
//     4. Pass a NULL pointer as one of the strings found in the array of strings passed to sorting_hat()
//     5. Pass an normal array of strings but pass a negative number as the number of strings in the array (numOfStrings)
//     6. Pass an normal array of strings but pass a zero (0) as the number of strings in the array (numOfStrings)
//     7. Pass an normal array of strings but pass a one (1) as the number of strings in the array (numOfStrings)
// *ALL* non-NULL char pointers must dereference to null-terminated strings (otherwise sorting_hat() will crash)
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  sorting_hat() has been written with good code *and* bad code so that students can practice both conditions
//     as they write their tests.  This version of sorting_hat() happens to be the version that randomly answers
//     incorrectly more often than it guesses the correct response to a given test.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif


/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode);

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept 
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter);

int main(void)
{
	puts("You still need to write parallel arrays to test sorting_hat()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
{
	char * randomReturnValue_ptr = NULL;	// Variable used to store the function's random return value
	
	/* Attempt to Sleep */
#ifdef _WIN32
	Sleep(1000);
#elif defined(__linux__) || defined(__unix__)
	sleep(1);
#endif
	
	/* Seed the rand() function */
	srand((unsigned int)time(NULL));

	/* Randomize a 'sign' */
	int sign = (rand() % (2));
	if (!sign)
	{
		sign -= 1;
	}

	/* Randomize an Error Code */
	int randomErrorCode = (sign)* (rand() % (90318 - 1)) + 1; // Randomize an error code

	/* Pointers to return if stringArray_ptr is NULL */
	static char * randomResponsePointers[] = { "This isn't working.", "This function is broken!", "Why are you looking at this?", "You shouldn't even be able to read these.", "No." };

	/* Randomize a randomResponsePointer just in case */
	int randomArrayIndex = 0;
	
	if (!stringArray_ptr || !errorCode || (numOfStrings < 2)) // If one of the parameters are 'off'...
	{
		/* Randomize an index from randomResponsePointers */
		randomArrayIndex = (rand() % (sizeof(randomResponsePointers) / sizeof(*(randomResponsePointers))));
		/* Set the return value as a pointer to a randomResponsePointer */
		randomReturnValue_ptr = *(randomResponsePointers + randomArrayIndex);
	}
	else // Otherwise, the function parameters are fine so...
	{
		/* Randomize an index from stringArray_ptr */
		randomArrayIndex = (rand() % (numOfStrings));
		/* Set the return value as a pointer to a random string from stringArray_ptr */
		randomReturnValue_ptr = *(stringArray_ptr + randomArrayIndex);
	}

	/* Set random errorCode */
	if (errorCode)						// If the errorCode pointer is *NOT* NULL...
	{
		*errorCode = randomErrorCode;				// ...set the error code as random...
	}

	return randomReturnValue_ptr;
}

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter)
{
	char returnValue = 0;	// REturn value variable

	if (!letter)			// If letter is '\0' (0x0)...
	{
		returnValue = 0;	// ...set the return value to 0x0
	}
	else if (letter >= 0x41 && letter <= 0x5A) // Otherwise, if the input letter is a capital alphabet letter...
	{
		returnValue = letter + 0x20; // ...'shift' it to its equivalent lower-case value
	}
	else					// Otherwise, it's not '\0' (0x0) and it's not a capital letter so...
	{
		returnValue = letter; // ...just set the return value to "letter" since the function doesn't need to do anything
	}

	return returnValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// DEMONSTRATION LAB I.5.A-5 /////////////////////////////////////////////
////////////////////////////////////////////////// POINTER ARRAYS ///////////////////////////////////////////////////
/////////////////////////////////////////////////// "Legilimency" ///////////////////////////////////////////////////
////////////////////////////////////////////// Stub Code (good function) ////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test sorting_hat()
// The version of sorting_hat() in this solution is 100% functional
// The student will write parallel arrays of test parameters for sorting_hat()
//     char ** stringArray_ptr - An array of string arrays (not a typo) is necessary to pass to sorting_hat()
//     int numOfStrings - A parallel integer array of numOfStrings will need to hold the number of strings 
//         each string array holds
//     int * errorCode - No array is needed for the memory address, merely passing the memory address of an
//         integer variable should suffice
// The student must also write parallel arrays to test the expected output of sorting_hat()
//     "character pointer" return value - A parallel array of character pointers is necessary to test the return
//         values of sorting_hat()
//     errorCode - A parallel integer array of expected errorCodes is also necessary to test sorting_hat()
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke sorting_hat() with an array of strings, the number of the strings in that array, and 
//             an integer pointer to store the resulting errorCode.
//         2. Test the return value of sorting_hat() against what is expected.
//         3. Test the errorCode value against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// The student will not be testing convert_char_to_lower()
// 
// TESTING SPECIFICATIONS
// Write two tests for each of the following conditions:
//     1. Normal input
//     2. The array of strings passed to sorting_hat() include alphabetically 'first' matching strings 
//         NOTE: The first matching strings should be returned
//     3. Pass a NULL pointer as stringArray_ptr
//     4. Pass a NULL pointer as one of the strings found in the array of strings passed to sorting_hat()
//     5. Pass an normal array of strings but pass a negative number as the number of strings in the array (numOfStrings)
//     6. Pass an normal array of strings but pass a zero (0) as the number of strings in the array (numOfStrings)
//     7. Pass an normal array of strings but pass a one (1) as the number of strings in the array (numOfStrings)
// *ALL* non-NULL char pointers must dereference to null-terminated strings (otherwise sorting_hat() will crash)
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  sorting_hat() has been written with good code *and* bad code so that students can practice both conditions
//     as they write their tests.  This version of sorting_hat() happens to be the version that passes all tests
//     as listed.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif

/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode);

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept 
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter);

int main(void)
{
	puts("You still need to write parallel arrays to test sorting_hat()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
{
	char * returnValue_ptr = NULL;	// Variable used to store the function's return value
	char * currentString = NULL;	// Variable used to store a char pointer of a null-terminated string that happens to be the current "winner"
	char * stringToTest = NULL;		// Variable used to store a char pointer of a null-terminated string that is currently being checked as a "winner"
	int i = 0;						// Iterating variable
	int j = 0;						// Iterating variable
	char tempCharCurrentString = 0;	// Temp variable to hold a char to compare
	char tempCharStringToTest = 0;	// Temp variable to hold a char to test against tempCharCurrentString
	int shortestStringLen = 0;		// Delimiting variable to stop char-by-char comparisons from running over the end of a null-termianated string

	if (!stringArray_ptr || !errorCode) // If either pointer is NULL...
	{
		returnValue_ptr = NULL;			// ...set NULL as the return value...
		if (errorCode)
		{
			*errorCode = -1;				// ...set the error code as -1...
		}
		return returnValue_ptr;			// ...and return NULL
	}
	else if (numOfStrings < 2)			// Otherwise, if the number of strings in the array of strings is unreasonable (less than 2)...
	{
		returnValue_ptr = NULL;			// ...set NULL as the return value...
		*errorCode = -2;				// ...set the error code as -2...
		return returnValue_ptr;			// ...and return NULL
	}
	else
	{
		*errorCode = 0;					// This function is innocent (e.g., no errors, success) until proven guilty
		/*
		 *  Default case is that the first string is the answer.
		 *  Remaining functionality attempts to prove this assertion incorrect.
		 */
		currentString = *(stringArray_ptr);	// The current "champ" is the first string in the array of strings
		returnValue_ptr = currentString;	// As such, set the current "champ" as the return value

		for (i = 1; i < numOfStrings; i++)	// For each string found in the array of strings...
		{
			stringToTest = *(stringArray_ptr + i);	// ...test the "i"th string...

			j = 0;									// ...starting at element 0
			if (!currentString || !stringToTest)	// If the current "champ" or the first "challenger" are NULL...
			{
				returnValue_ptr = NULL;				// ...set NULL as the return value...
				*errorCode = -1;					// ...set the error code as -1...
				return returnValue_ptr;				// ...and return NULL
			}
			while (*(currentString + j) && *(stringToTest + j)) // Loop through the elements of the two strings as long as they're not '\0' (0x0)
			{
				tempCharCurrentString = convert_char_to_lower(*(currentString + j));	// Ensure the current character of the "champ" is lower-case
				tempCharStringToTest = convert_char_to_lower(*(stringToTest + j));		// Ensure the current character of the "competitor" is lower-case

				if (tempCharCurrentString && tempCharStringToTest) // If both of the characters are *NOT* NULL...
				{
					/* Alphabetizing characters by value (since they're all lower-case) */
					if (tempCharCurrentString < tempCharStringToTest) // If the "champ"'s char comes first...
					{
						returnValue_ptr = currentString; // ...so set the return value to the "champ"'s pointer...
						break;							 // ...and stop (while) looping. (The for loop will continue looking for more "challenger"s if there are any strings left in the array
					}
					else if (tempCharStringToTest < tempCharCurrentString) // Otherwise, the "challenger"'s char comes first...
					{
						returnValue_ptr = stringToTest; // ...so set the return value with the pointer to the "challenger" and...
						currentString = stringToTest;	// ...set the "challenger" as the new "champ"
						break; // ...and stop (while) looping. (The for loop will continue looking for more "challenger"s if there are any strings left in the array
					}
					// else... both chars are equivalent and the search (see: while loop) must continue with the next char
				}
				else // ....Otherwise, at least one of the current characters is NULL and something bad happened (which it should not have)
				{
					*errorCode = -3;
					puts("Something terrible has happened with convert_char_to_lower()!");
					return NULL;
				}

				j++;
			}
		}
	}

	return returnValue_ptr;
}

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter)
{
	char returnValue = 0;	// REturn value variable

	if (!letter)			// If letter is '\0' (0x0)...
	{
		returnValue = 0;	// ...set the return value to 0x0
	}
	else if (letter >= 0x41 && letter <= 0x5A) // Otherwise, if the input letter is a capital alphabet letter...
	{
		returnValue = letter + 0x20; // ...'shift' it to its equivalent lower-case value
	}
	else					// Otherwise, it's not '\0' (0x0) and it's not a capital letter so...
	{
		returnValue = letter; // ...just set the return value to "letter" since the function doesn't need to do anything
	}

	return returnValue;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//#define EFFICIENT_METHOD

int swap_em(int * firstNum, int * secondNum);

int main(void)
{
	int input1 = 0;
	printf("%p", &input1); // DEBUGGING
	int input2 = 0;
	printf("Input two integers separated by a space.\n");
	_flushall();
	scanf("%d %d", &input1, &input2);
	printf("You input %d and %d.\n", input1, input2);
	swap_em(&input1, &input2);
	printf("Now they're %d and %d.\n", input1, input2);

	return 0;
}

int swap_em(int * firstNum, int * secondNum)
{
//	printf("%p", &temp); // DEBUGGING

#ifdef EFFICIENT_METHOD
	*firstNum = *firstNum ^ *secondNum;
	*secondNum = *firstNum ^ *secondNum;
	*firstNum = *firstNum ^ *secondNum;
#else
	int temp = *firstNum;
	*firstNum = *secondNum;
	*secondNum = temp;
#endif

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int swap_em(int firstNum, int secondNum);

int main(void)
{
	int input1 = 0;
	int input2 = 0;
	printf("Input two integers separated by a space.\n");
	_flushall();
	scanf("%d %d", &input1, &input2);
	printf("You input %d and %d.\n", input1, input2);
	swap_em(input1, input2);
	printf("Now they're %d and %d.\n", input1, input2);

	return 0;
}

int swap_em(int firstNum, int secondNum)
{
	firstNum = firstNum ^ secondNum;
	secondNum = firstNum ^ secondNum;
	firstNum = firstNum ^ secondNum;
	
	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#define ERROR_CODE ((int)982451653)

int add(int * x, int * y);
int subtract(int * x, int * y);
int multiply(int * x, int * y);
int swap(int * x, int * y);

int main(void)
{
	int(*mathFunc_ptr)(int * a, int * b);
	int num1 = 0;
	int num2 = 0;
	char mathOperator = 0;
	int returnValue = 0;


	printf("Enter two ints separated by a math operator (e.g., 5 + 1, 4 - 3, 1 * 2, 2 ^ 3)\n");
	_flushall();
	scanf("%d %c %d", &num1, &mathOperator, &num2);

	if (mathOperator == '+')
	{
		mathFunc_ptr = &add;
	}
	else if (mathOperator == '-')
	{
		mathFunc_ptr = &subtract;
	}
	else if (mathOperator == '*')
	{
		mathFunc_ptr = &multiply;
	}
	else if (mathOperator == '^')
	{
		mathFunc_ptr = &swap;
	}
	else
	{
		puts("Something went wrong.");
		return -1;
	}

	if (mathFunc_ptr)
	{
		returnValue = mathFunc_ptr(&num1, &num2);
		printf("Return Value:\t%d\n", returnValue);
	}
	else
	{
		puts("Something went wrong.");
		return -1;
	}

	return 0;
}

int add(int * x, int * y)
{
	if (x && y)
	{
		return (*x + *y);
	}
	else
	{
		return ERROR_CODE;
	}
}

int subtract(int * x, int * y)
{
	if (x && y)
	{
		return (*x - *y);
	}
	else
	{
		return ERROR_CODE;
	}
}

int multiply(int * x, int * y)
{
	if (x && y)
	{
		return (*x * *y);
	}
	else
	{
		return ERROR_CODE;
	}
}

int swap(int * x, int * y)
{
	if (x && y)
	{
		*x = *x ^ *y;
		*y = *x ^ *y;
		*x = *x ^ *y;
		return 1;
	}
	else
	{
		return ERROR_CODE;
	}
}
#include <stdio.h>

#define ROWS ((int)6)
#define COLUMNS ((int)9)

int main(void)
{
	double dbaseTable1[9][6] = {
		{ 1.1, 1.2, 1.3, 1.4, 1.5, 1.6 },
		{ 2.1, 2.2, 2.3, 2.4, 2.5, 2.6 },
		{ 3.1, 3.2, 3.3, 3.4, 3.5, 3.6 },
		{ 4.1, 4.2, 4.3, 4.4, 4.5, 4.6 },
		{ 5.1, 5.2, 5.3, 5.4, 5.5, 5.6 },
		{ 6.1, 6.2, 6.3, 6.4, 6.5, 6.6 },
		{ 7.1, 7.2, 7.3, 7.4, 7.5, 7.6 },
		{ 8.1, 8.2, 8.3, 8.4, 8.5, 8.6 },
		{ 9.1, 9.2, 9.3, 9.4, 9.5, 9.6 }
	};

	int threeDimChessBoard[3][4][4] = { { 1, 2, 3, 4 } };

	int triDTournament[20][3][4][4] = { 0 };
	
	double numberArray[3][4] = { \
		0.0, 0.1, 0.2, 0.3, \
		1.0, 1.1, 1.2, 1.3, \
		2.0, 2.1, 2.2, 2.3 \
	};

	int literal2DimArray[ROWS][COLUMNS] = { 0 };

	int i = 0;
	int j = 0;

	for (i = 0; i < ROWS; i++)
	{
		for (j = 0; j < COLUMNS; j++)
		{
			literal2DimArray[i][j] = (i * 10) + j;
		}
	}



	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// MQT (I.5.A) PERFORMANCE LAB 2 ///////////////////////////////////////////
/////////////////////////////////////////////////////// ARRAYS ///////////////////////////////////////////////////////
//////////////////////////////////////////// "Telescope Array Project" ///////////////////////////////////////////////
///////////////////////////////////////////////////// Stub Code //////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The following stub code defines four non-null-terminated character arrays
// Each array stores the map coordinates, in Degrees Mintues Seconds (DMS) format, of a 
//     "Telescope Array Project" station (https://en.wikipedia.org/wiki/Telescope_Array_Project)
// The coordinates are not listed complete with degrees (o), minutes ('), and seconds ("")
// The student must modify each char array to change the underscores (_) to the appropriate symbol
// For each array:
//     Index 3 and index 17 must be changed to 0xF8, the degree symbol (or 0xB0, depending on the implementation)
//     Index 7 and index 21 must be changed to 0x27, the apostrophe
//     Index 11 and index 25 must be changed to 0x22, the double apostrophe
// The students may only modify the char arrays using dereferenced pointers
//     (the exact reasoning will become clear later in this objective)
//     (SPOILER:  "pass by reference")
// After the modifications have been made, print all four char arrays in a human-readable format
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

#define BUFF_SIZE 27 // Standard dimension for the four char arrays

int main(void)
{
	/* The four "Telescope Array Project" station char arrays are defined with DMS coordinates */
	// IMPORTANT NOTE:  These char arrays are (purposely) *NOT* null-terminated so take care!
	char blackRockMesaDMS[BUFF_SIZE] = { "039_011_018_N 112_042_042_W" };
	char longRidgeDMS[BUFF_SIZE] = { "039_012_028_N 113_007_017_W" };
	char middleDrumDMS[BUFF_SIZE] = { "039_028_022_N 112_059_037_W" };
	char centralLaserFacilityDMS[BUFF_SIZE] = { "039_017_049_N 112_054_031_W" };



	///////////////////////
	// MODIFY THE ARRAYS //
	///////////////////////

	/* Insert code here */

	///////////////////////
	///////////////////////
	///////////////////////



	//////////////////////
	// PRINT THE ARRAYS //
	//////////////////////

	/* Insert code here */

	///////////////////////
	///////////////////////
	///////////////////////

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-3 ////////////////////////////////////////////
////////////////////////////////////////////////// ADDRESS ARITHMETIC //////////////////////////////////////////////
/////////////////////////////////////////////////// "String Splitter" //////////////////////////////////////////////
////////////////////////////////////////////////// Instructor Solution /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Do *NOT* modify main() as it runs 19 tests on split_the_string()
// Define char * split_the_string(char * string_ptr, char delimiter) with the following requirements:
// Return Value - 
//     In short, split_the_string() returns a pointer to a second null-terminated string upon success.
//     NULL if string_ptr is NULL
//     NULL if string_ptr has more than one occurrence of delimiter
//     NULL if delimiter is '\0' (0x0)
//     string_ptr if delimiter is not found
// Parameters - 
//     string_ptr is a null-terminated char array (see: string) that may include a delimiting
//         character.  That delimiting character (see: char delimiter) is a logical (as in virtual) break point
//         between two separate phrases/words/characters/sentences within the original null-terminated char array
//         (string_ptr).  If there is a delimiting character, this function will return the pointer to the
//         beginning of the second null-terminated char array (in addition to performing other procedures).
//         
//     delimiter is the delimiting character that separates the two strings logically combined inside the
//         the null-terminated char array found at string_ptr.  (NOTE:  delimiter should *NOT* be '\0' (0x0)
// Purpose - This function separates a null-terminated string into two different strings, breaking them apart
//     at "delimiter".  The first part of the original string (the portion of the array preceding "delimiter")
//     will remain as is.  The deliminating character will be changed to a null character ('\0').  Then, the
//     memory address of the second part of the original string (the portion of the array following the "delimiter")
//     will be returned to the caller.  This function can't handle more than two strings so it verifies there's
//     only one occurrence of the delimiting character.  It also checks if string_ptr is NULL.  This function
//     only utilizes Address Arithmetic (see: Pointer Math) to access the data found in the char array found
//     at string_ptr. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <string.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define NUM_TEST_STRINGS 19

/*
 * FUNCTION:   char * split_the_string(char * string_ptr, char delimiter)
 *
 * ARGUMENTS:  string_ptr is a null-terminated string that may or may not contain a delimiting
 *                 character (see: delimiter) that logically separates two phrases to be "split"
 *             delimiter is the character that logically separates the two phrases that may be
 *                 in the null-terminated char array found at string_ptr
 *
 * RETURNS:	   char pointer to the first element of the second (null-terminated) phrase on success
 *             NULL if string_ptr is NULL
 *             NULL if delimiter is '\0' (0x0)
 *             NULL if string_ptr has more than one occurrence of delimiter
 *             string_ptr if delimiter is not found
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at string_ptr
 *             Only access elements of the char array found at string_ptr using address arithmetic
 *                 (AKA pointer math).  The definition of this function should be entirely devoid
 *                 of the [ and ] characters.  (e.g., string_ptr[i] is forbidden)
 *             The only guarantee for the arguments is that string_ptr is null-terminated
 *             There is no guarantee it has a delimiter (return string_ptr if not)
 *             There is no guarantee it only has one delimiter if there is one (return NULL if not)
 *             There is no guarantee the delimiter is some char *other* than '\0' (return NULL if not)
 *             There is no guarantee that string_ptr has an address (return NULL if NULL)
 */
char * split_the_string(char * string_ptr, char delimiter);

int main(void)
{
	int i = 0;						// Iterating variable
	char * secondString_ptr = NULL; // Holds the return value of split_the_string()
	int tempValue = 0;				// Used to temporarily hold strcmp()'s return value
	int numTestsRun = 0;			// Number of tests that ran
	int numTestsPassed = 0;			// Number of ran tests that passed

	//////////////////////////////////
	// INPUT STRINGS
	//////////////////////////////////
	/*
	 *  Normal input
	 *  Two examples each of special characters, letters, and non-printable
	 *      characters as delimiters
	 */
	char inputString0[] = { "Integer/Float" };	// Delimiter = 0x2F
	char inputString1[] = { "aeiou" };			// Delimiter = 0x69
	char inputString2[] = { "First phrase&Second phrase" };	// Delimiter = 0xA
	inputString2[12] = 10; // Manually setting delimiter
	char inputString3[] = {"C programming uses the & character to determine the address of something."}; // Delimite = 0x26
	char inputString4[] = { "Bust A Move" }; // Delimiter = 0x41
	char inputString5[] = { "Alexander Graham was a Scottish-born scientist, inventor, engineer and innovator who is credited with patenting the first practical telephone." }; // Delimiter = 0x7
	inputString5[16] = 7; // Manually setting delimiter
	/*
	 *  No delimiters found
	 *  Two examples
	 */
	char inputString6[] = { "This string does not have any delimiters." }; // Delimiter = 0x5A
	char inputString7[] = { "!@#$%^&*()_+" }; // Delimiter = 0x20
	/*
	 *  Null pointers
	 *  Two examples
	 */
	char * inputString8 = NULL; // Delimiter doesn't matter
	char * inputString9 = NULL; // Delimiter doesn't matter
	/*
	 *  Extra delimiters
	 *  Two examples each of two, 10, and many delimiters
	 */
	char inputString10[] = { "This uses spaces." }; // Delimiter = 0x20
	char inputString11[] = { "Fandango" }; // Delimiter = 0x61
	char inputString12[] = { "This-string-uses-dashes-as-delimiters.  They-were-selected-by-Hark." }; // Delimiter = 0x2D
	char inputString13[22] = { "a b c d e f g h i j k" }; // Delimiter = 0xD
	for (i = 1; i <= 20; i+= 2)
	{
		inputString13[i] = 13;
	}
	char inputString14[] = { "The dental patient says, 'Aaaaaaaah'" }; // Delimiter = 0x61
	char inputString15[127] = { 0 }; // Delimiter = 0x7F
	for (i = 0; i < 126; i+=2)
	{
		inputString15[i] = 0x7F;							// Sets a multitude of delimiting characters
		inputString15[i + 1] = (char)((2 * i) - i + 1); // Sets each index to it's own index number in decimal
	}
	inputString15[126] = 0; // For safety
	char inputString16[127] = { 0 }; // Delimiter = 0x5A;
	for (i = 0; i < 126; i++)
	{
		inputString16[i] = 0x5A;
	}
	char inputString17[] = { "Normal string with the null character as the deliminator" }; // Deliminator = 0x0
	char inputString18[] = { 0, 'W', 'h', 'o', 'o', 'p', 's', 0 }; // Deliminator = 0x0
	char * inputStringArray[NUM_TEST_STRINGS] = { \
		inputString0, inputString1, inputString2, \
		inputString3, inputString4, inputString5, \
		inputString6, inputString7, inputString8, \
		inputString9, inputString10, inputString11, \
		inputString12, inputString13, inputString14, \
		inputString15, inputString16, inputString17, \
		inputString18 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// DELIMITING CHARACTERS
	//////////////////////////////////
	char inputStringDelimiters[NUM_TEST_STRINGS] = { \
		0x2F, 0x69, 0xA, \
		0x26, 0x41, 0x7, \
		0x5A, 0x20, 0x13, \
		0x37, 0x20, 0x61, \
		0x2D, 0xD, 0x61, \
		0x7F, 0x5A, 0x0, \
		0x0 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// OUTPUT STRINGS
	//////////////////////////////////
	/*
	 *  Expected output
	 *  Parallels the input strings
	 */
	char outputString0[] = { "Float" };	// Delimiter = /
	char outputString1[] = { "ou" };			// Delimiter = i
	char outputString2[] = { "Second phrase" };	// Delimiter = 0xA
	char outputString3[] = { " character to determine the address of something." }; // Delimite = &
	char outputString4[] = { " Move" }; // Delimiter = A
	char outputString5[] = { "was a Scottish-born scientist, inventor, engineer and innovator who is credited with patenting the first practical telephone." }; // Delimiter = 0x7
    /*
	 *  No delimiters found
	 *  Two examples
	 */
	char outputString6[] = { "This string does not have any delimiters." }; // Delimiter = Z
	char outputString7[] = { "!@#$%^&*()_+" }; // Delimiter = 0x20
	/*
	*  Null pointers
	*  Two examples
	*/
	char * outputString8 = NULL;
	char * outputString9 = NULL;
	/*
	*  Extra delimiters
	*  Two examples each of two, 10, and many delimiters
	*/
	char * outputString10 = NULL; // Delimiter = 0x20
	char * outputString11 = NULL; // Delimiter = 0x61
	char * outputString12 = NULL; // Delimiter = 0x2D
	char * outputString13 = NULL; // Delimiter = 0xD
	char * outputString14 = NULL; // Delimiter = 0x61
	char * outputString15 = NULL; // Delimiter = 0x7F
	char * outputString16 = NULL; // Delimiter = 0x5A;
	char * outputString17 = NULL; // Deliminator = 0x0
	char * outputString18 = NULL; // Deliminator = 0x0
	char * outputStringArray[NUM_TEST_STRINGS] = { \
		outputString0, outputString1, outputString2, \
		outputString3, outputString4, outputString5, \
		outputString6, outputString7, outputString8, \
		outputString9, outputString10, outputString11, \
		outputString12, outputString13, outputString14, \
		outputString15, outputString16, outputString17, \
		outputString18 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////


	for (i = 0; i < (int)NUM_TEST_STRINGS; i++)
	{
		printf("Test #%d:\t", i);
		numTestsRun++;
		secondString_ptr = split_the_string(inputStringArray[i], inputStringDelimiters[i]);
		if (secondString_ptr && outputStringArray[i]) // If both pointers are *NOT* NULL...
		{
//			puts(secondString_ptr); // DEBUGGING

			tempValue = strcmp(secondString_ptr, outputStringArray[i]); // ...then compare the two strings
			if (!tempValue) // If those two strings match...
			{
				puts("Success"); // ...then let the human know...
				numTestsPassed++; // ...and increment the counter
			}
			else // ...Otherwise, they don't match...
			{
				puts("Error"); // ...so let the human know
			}
		}
		else if (!secondString_ptr && !outputStringArray[i]) // If both pointers are NULL...
		{
			puts("Success"); // ...then count that as a success because they match...
			numTestsPassed++; // ...and increment the counter
		}
		else // Otherwise, only one of the pointers is NULL so they don't match...
		{
			puts("Error"); // ...so let the human know
		}

	}

	/* Let the human know how they did in a safe way */
	if (numTestsRun && numTestsPassed)
	{
		printf("\nOf the %d tests run...\n%d tests passed.", numTestsRun, numTestsPassed);
	}

	return 0;
}

/*
 * FUNCTION:   char * split_the_string(char * string_ptr, char delimiter)
 *
 * ARGUMENTS:  string_ptr is a null-terminated string that may or may not contain a delimiting
 *                 character (see: delimiter) that logically separates two phrases to be "split"
 *             delimiter is the character that logically separates the two phrases that may be
 *                 in the null-terminated char array found at string_ptr
 *
 * RETURNS:	   char pointer to the first element of the second (null-terminated) phrase on success
 *             NULL if string_ptr is NULL
 *             NULL if delimiter is '\0' (0x0)
 *             NULL if string_ptr has more than one occurrence of delimiter
 *             string_ptr if delimiter is not found
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the 
 *                 null-terminated char array found at string_ptr
 *             Only access elements of the char array found at string_ptr using address arithmetic
 *                 (AKA pointer math).  The definition of this function should be entirely devoid
 *                 of the [ and ] characters.  (e.g., string_ptr[i] is forbidden)
 *             The only guarantee for the arguments is that string_ptr is null-terminated
 *             There is no guarantee it has a delimiter (return string_ptr if not)
 *             There is no guarantee it only has one delimiter if there is one (return NULL if not)
 *             There is no guarantee the delimiter is some char *other* than '\0' (return NULL if not)
 *             There is no guarantee that string_ptr has an address (return NULL if NULL)
 */
char * split_the_string(char * string_ptr, char delimiter)
{
	///////////////////////
	///////////////////////
	///////////////////////

	/* Insert code here */

	///////////////////////
	///////////////////////
	///////////////////////

	return 0; // You'll want to change this return statement
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-3 ////////////////////////////////////////////
////////////////////////////////////////////////// ADDRESS ARITHMETIC //////////////////////////////////////////////
/////////////////////////////////////////////////// "String Splitter" //////////////////////////////////////////////
/////////////////////////////////////////////////////// Stub Code //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Do *NOT* modify main() as it runs 19 tests on split_the_string()
// Define char * split_the_string(char * string_ptr, char delimiter) with the following requirements:
// Return Value - 
//     In short, split_the_string() returns a pointer to a second null-terminated string upon success.
//     ERROR_NULL_POINTER if string_ptr is NULL
//     ERROR_ABUNDANT_DELIMITER if string_ptr has more than one occurrence of delimiter
//     ERROR_NULL_DELIMITER if delimiter is '\0' (0x0)
//     string_ptr if delimiter is not found
// Parameters - 
//     string_ptr is a null-terminated char array (see: string) that may include a delimiting
//         character.  That delimiting character (see: char delimiter) is a logical (as in virtual) break point
//         between two separate phrases/words/characters/sentences within the original null-terminated char array
//         (string_ptr).  If there is a delimiting character, this function will return the pointer to the
//         beginning of the second null-terminated char array (in addition to performing other procedures).
//         
//     delimiter is the delimiting character that separates the two strings logically combined inside the
//         the null-terminated char array found at string_ptr.  (NOTE:  delimiter should *NOT* be '\0' (0x0)
// Purpose - This function separates a null-terminated string into two different strings, breaking them apart
//     at "delimiter".  The first part of the original string (the portion of the array preceding "delimiter")
//     will remain as is.  The deliminating character will be changed to a null character ('\0').  Then, the
//     memory address of the second part of the original string (the portion of the array following the "delimiter")
//     will be returned to the caller.  This function can't handle more than two strings so it verifies there's
//     only one occurrence of the delimiting character.  It also checks if string_ptr is NULL.  This function
//     only utilizes Address Arithmetic (see: Pointer Math) to access the data found in the char array found
//     at string_ptr. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <string.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#ifdef ERROR_NULL_POINTER
#undef ERROR_NULL_POINTER
#else
#define ERROR_NULL_POINTER ((char*)-1)
#endif

#ifdef ERROR_ABUNDANT_DELIMITER
#undef ERROR_ABUNDANT_DELIMITER
#else
#define ERROR_ABUNDANT_DELIMITER ((char*)-2)
#endif

#ifdef ERROR_NULL_DELIMITER
#undef ERROR_NULL_DELIMITER
#else
#define ERROR_NULL_DELIMITER ((char*)-3)
#endif

#ifndef TRUE
#define TRUE ((int)1)
#endif

#ifndef FALSE
#define FALSE ((int)0)
#endif

#define NUM_TEST_STRINGS 19

/*
 * FUNCTION:   char * split_the_string(char * string_ptr, char delimiter)
 *
 * ARGUMENTS:  string_ptr is a null-terminated string that may or may not contain a delimiting
 *                 character (see: delimiter) that logically separates two phrases to be "split"
 *             delimiter is the character that logically separates the two phrases that may be
 *                 in the null-terminated char array found at string_ptr
 *
 * RETURNS:	   char pointer to the first element of the second (null-terminated) phrase on success
 *             ERROR_NULL_POINTER if string_ptr is NULL
 *             ERROR_NULL_DELIMITER if delimiter is '\0' (0x0)
 *             ERROR_ABUNDANT_DELIMITER if string_ptr has more than one occurrence of delimiter
 *             string_ptr if delimiter is not found
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at string_ptr
 *             Only access elements of the char array found at string_ptr using address arithmetic
 *                 (AKA pointer math).  The definition of this function should be entirely devoid
 *                 of the [ and ] characters.  (e.g., string_ptr[i] is forbidden)
 *             The only guarantee for the arguments is that string_ptr is null-terminated
 *             There is no guarantee it has a delimiter (return string_ptr if not)
 *             There is no guarantee it only has one delimiter if there is one (return ERROR_ABUNDANT_DELIMITER if not)
 *             There is no guarantee the delimiter is some char *other* than '\0' (return ERROR_NULL_DELIMITER if not)
 *             There is no guarantee that string_ptr has an address (return ERROR_NULL_POINTER if NULL)
 */
char * split_the_string(char * string_ptr, char delimiter);

int main(void)
{
	int i = 0;								// Iterating variable
	char * secondString_ptr = NULL;			// Holds the return value of split_the_string()
	int tempValue = 0;						// Used to temporarily hold strcmp()'s return value
	int numTestsRun = 0;					// Number of tests that ran
	int numTestsPassed = 0;					// Number of ran tests that passed
	int thereWasAnErrorCode = FALSE;		// Boolean representation that one of the #defined ERROR_* codes were returned
	int thereShouldBeAnErrorCode = FALSE;	// Boolean representation that one of the #defined ERROR_* codes should be returned

	//////////////////////////////////
	// INPUT STRINGS
	//////////////////////////////////
	/*
	 *  Normal input
	 *  Two examples each of special characters, letters, and non-printable
	 *      characters as delimiters
	 */
	char inputString0[] = { "Integer/Float" };	// Delimiter = 0x2F
	char inputString1[] = { "aeiou" };			// Delimiter = 0x69
	char inputString2[] = { "First phrase&Second phrase" };	// Delimiter = 0xA
	inputString2[12] = 10; // Manually setting delimiter
	char inputString3[] = {"C programming uses the & character to determine the address of something."}; // Delimite = 0x26
	char inputString4[] = { "Bust A Move" }; // Delimiter = 0x41
	char inputString5[] = { "Alexander Graham was a Scottish-born scientist, inventor, engineer and innovator who is credited with patenting the first practical telephone." }; // Delimiter = 0x7
	inputString5[16] = 7; // Manually setting delimiter
	/*
	 *  No delimiters found
	 *  Two examples
	 */
	char inputString6[] = { "This string does not have any delimiters." }; // Delimiter = 0x5A
	char inputString7[] = { "!@#$%^&*()_+" }; // Delimiter = 0x20
	/*
	 *  Null pointers
	 *  Two examples
	 */
	char * inputString8 = NULL; // Delimiter doesn't matter
	char * inputString9 = NULL; // Delimiter doesn't matter
	/*
	 *  Extra delimiters
	 *  Two examples each of two, 10, and many delimiters
	 */
	char inputString10[] = { "This uses spaces." }; // Delimiter = 0x20
	char inputString11[] = { "Fandango" }; // Delimiter = 0x61
	char inputString12[] = { "This-string-uses-dashes-as-delimiters.  They-were-selected-by-Hark." }; // Delimiter = 0x2D
	char inputString13[22] = { "a b c d e f g h i j k" }; // Delimiter = 0xD
	for (i = 1; i <= 20; i+= 2)
	{
		inputString13[i] = 13;
	}
	char inputString14[] = { "The dental patient says, 'Aaaaaaaah'" }; // Delimiter = 0x61
	char inputString15[127] = { 0 }; // Delimiter = 0x7F
	for (i = 0; i < 126; i+=2)
	{
		inputString15[i] = 0x7F;							// Sets a multitude of delimiting characters
		inputString15[i + 1] = (char)((2 * i) - i + 1); // Sets each index to it's own index number in decimal
	}
	inputString15[126] = 0; // For safety
	char inputString16[127] = { 0 }; // Delimiter = 0x5A;
	for (i = 0; i < 126; i++)
	{
		inputString16[i] = 0x5A;
	}
	char inputString17[] = { "Normal string with the null character as the deliminator" }; // Deliminator = 0x0
	char inputString18[] = { 0, 'W', 'h', 'o', 'o', 'p', 's', 0 }; // Deliminator = 0x0
	char * inputStringArray[NUM_TEST_STRINGS] = { \
		inputString0, inputString1, inputString2, \
		inputString3, inputString4, inputString5, \
		inputString6, inputString7, inputString8, \
		inputString9, inputString10, inputString11, \
		inputString12, inputString13, inputString14, \
		inputString15, inputString16, inputString17, \
		inputString18 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// DELIMITING CHARACTERS
	//////////////////////////////////
	char inputStringDelimiters[NUM_TEST_STRINGS] = { \
		0x2F, 0x69, 0xA, \
		0x26, 0x41, 0x7, \
		0x5A, 0x20, 0x13, \
		0x37, 0x20, 0x61, \
		0x2D, 0xD, 0x61, \
		0x7F, 0x5A, 0x0, \
		0x0 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////

	//////////////////////////////////
	// OUTPUT STRINGS
	//////////////////////////////////
	/*
	 *  Expected output
	 *  Parallels the input strings
	 */
	char outputString0[] = { "Float" };	// Delimiter = /
	char outputString1[] = { "ou" };			// Delimiter = i
	char outputString2[] = { "Second phrase" };	// Delimiter = 0xA
	char outputString3[] = { " character to determine the address of something." }; // Delimite = &
	char outputString4[] = { " Move" }; // Delimiter = A
	char outputString5[] = { "was a Scottish-born scientist, inventor, engineer and innovator who is credited with patenting the first practical telephone." }; // Delimiter = 0x7
    /*
	 *  No delimiters found
	 *  Two examples
	 */
	char outputString6[] = { "This string does not have any delimiters." }; // Delimiter = Z
	char outputString7[] = { "!@#$%^&*()_+" }; // Delimiter = 0x20
	/*
	*  Null pointers
	*  Two examples
	*/
	char * outputString8 = ERROR_NULL_POINTER;
	char * outputString9 = ERROR_NULL_POINTER;
	/*
	*  Extra delimiters
	*  Two examples each of two, 10, and many delimiters
	*/
	char * outputString10 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x20
	char * outputString11 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x61
	char * outputString12 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x2D
	char * outputString13 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0xD
	char * outputString14 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x61
	char * outputString15 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x7F
	char * outputString16 = ERROR_ABUNDANT_DELIMITER; // Delimiter = 0x5A;
	char * outputString17 = ERROR_NULL_DELIMITER; // Deliminator = 0x0
	char * outputString18 = ERROR_NULL_DELIMITER; // Deliminator = 0x0
	char * outputStringArray[NUM_TEST_STRINGS] = { \
		outputString0, outputString1, outputString2, \
		outputString3, outputString4, outputString5, \
		outputString6, outputString7, outputString8, \
		outputString9, outputString10, outputString11, \
		outputString12, outputString13, outputString14, \
		outputString15, outputString16, outputString17, \
		outputString18 };
	//////////////////////////////////
	//////////////////////////////////
	//////////////////////////////////


	for (i = 0; i < (int)NUM_TEST_STRINGS; i++)
	{
		thereWasAnErrorCode = FALSE; // Reset the variable
		thereShouldBeAnErrorCode = FALSE; // Reset the variable
		printf("Test #%d:\t", i);
		numTestsRun++;
		secondString_ptr = split_the_string(inputStringArray[i], inputStringDelimiters[i]);
		if (secondString_ptr == ERROR_ABUNDANT_DELIMITER || secondString_ptr == ERROR_NULL_DELIMITER || secondString_ptr == ERROR_NULL_POINTER)
		{
			thereWasAnErrorCode = TRUE;
		}
		if (outputStringArray[i] == ERROR_ABUNDANT_DELIMITER || outputStringArray[i] == ERROR_NULL_DELIMITER || outputStringArray[i] == ERROR_NULL_POINTER)
		{
			thereShouldBeAnErrorCode = TRUE;
		}
		if (thereWasAnErrorCode == FALSE && thereShouldBeAnErrorCode == FALSE && secondString_ptr && outputStringArray[i]) // If both pointers are *NOT* NULL...
		{
//			puts(secondString_ptr); // DEBUGGING

			tempValue = strcmp(secondString_ptr, outputStringArray[i]); // ...then compare the two strings
			if (!tempValue) // If those two strings match...
			{
				puts("Success"); // ...then let the human know...
				numTestsPassed++; // ...and increment the counter
			}
			else // ...Otherwise, they don't match...
			{
				puts("Error"); // ...so let the human know
			}
		}
		else if (secondString_ptr == outputStringArray[i]) // Otherwise, there's at least one error so if they match...
		{
			puts("Success"); // ...then count that as a success because they match...
			numTestsPassed++; // ...and increment the counter
		}
		else // Otherwise, only one of the pointers is NULL so they don't match...
		{
			puts("Error"); // ...so let the human know
		}

	}

	/* Let the human know how they did in a safe way */
	if (numTestsRun && numTestsPassed)
	{
		printf("\nOf the %d tests run...\n%d tests passed.", numTestsRun, numTestsPassed);
	}

	return 0;
}

/*
 * FUNCTION:   char * split_the_string(char * string_ptr, char delimiter)
 *
 * ARGUMENTS:  string_ptr is a null-terminated string that may or may not contain a delimiting
 *                 character (see: delimiter) that logically separates two phrases to be "split"
 *             delimiter is the character that logically separates the two phrases that may be
 *                 in the null-terminated char array found at string_ptr
 *
 * RETURNS:	   char pointer to the first element of the second (null-terminated) phrase on success
 *             ERROR_NULL_POINTER if string_ptr is NULL
 *             ERROR_NULL_DELIMITER if delimiter is '\0' (0x0)
 *             ERROR_ABUNDANT_DELIMITER if string_ptr has more than one occurrence of delimiter
 *             string_ptr if delimiter is not found
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at string_ptr
 *             Only access elements of the char array found at string_ptr using address arithmetic
 *                 (AKA pointer math).  The definition of this function should be entirely devoid
 *                 of the [ and ] characters.  (e.g., string_ptr[i] is forbidden)
 *             The only guarantee for the arguments is that string_ptr is null-terminated
 *             There is no guarantee it has a delimiter (return string_ptr if not)
 *             There is no guarantee it only has one delimiter if there is one (return ERROR_ABUNDANT_DELIMITER if not)
 *             There is no guarantee the delimiter is some char *other* than '\0' (return ERROR_NULL_DELIMITER if not)
 *             There is no guarantee that string_ptr has an address (return ERROR_NULL_POINTER if NULL)
 */
char * split_the_string(char * string_ptr, char delimiter)
{
	///////////////////////
	///////////////////////
	///////////////////////

	/* Insert code here */

	///////////////////////
	///////////////////////
	///////////////////////

	return NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// PERFORMANCE LAB I.5.A-4 ////////////////////////////////////////////////
/////////////////////////////////////////////// FUNCTION ARGUMENTS //////////////////////////////////////////////////
///////////////////////////////////////////////// "Surfin' Bird" ////////////////////////////////////////////////////
/////////////////////////////////////////////// Instructor Solution /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The students must define find_the_word() as specified below.
// Do *NOT* change main() as it contains 56 tests created for find_the_word()
// char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
// Return Value
//     char pointer to the first occurrence of searchWord in the null-terminated string found at sentence_ptr
//     NULL for all other situations (e.g., sentence_ptr is NULL, searchWord_ptr is NULL, errorCode_ptr is NULL)
// Parameters
//     sentence_ptr - char pointer to a null-terminated string which represents the sentence to search
//     searchWord_ptr - char pointer to a null-terminated string which represents the key to search for
//     errorCode_ptr - int pointer which will store an error code provided by find_the_word (see below)
// Purpose - Safely (e.g., watch for array overruns, mind the null-terminators) locate the memory address
//     of the string found at searchWord_ptr within sentence_ptr
// Requirements
//     Only Address Arithmetic is permitted to access sentence_ptr and searchWord_ptr.  The test input utilizes
//         methods other than address arithmetic but that is none of your concern.
//     Assign your error code to the memory address found in errorCode_ptr.  The error codes are #defined as constant
//         MACROS at the beginning of main() but are also listed here:
//         DEFAULT_ERROR_CODE - This is a default value used in testing.  The error code variable is initialized
//             with this value.  The error code variable is also reset to this value after each test.  The
//             students will not need to return this code.  It is entirely restricted to testing and debugging.
//         ERROR_CODE_SUCCESS - This is not an actual error.  Rather, it indicates your function has successfully
//             completed.  Use this MACRO to indicate success.
//         ERROR_NULL_SENTENCE_POINTER - This MACRO is to be used when sentence_ptr is NULL.  The return value of 
//             the function will of course be NULL but the function also needs to store this MACRO in the memory 
//             address stored in errorCode_ptr.
//         ERROR_NULL_SEARCH_POINTER - This MACRO is to be used when searchWord_ptr is NULL.  The return value 
//             of the function will of course be NULL but the function also needs to store this MACRO in the memory 
//             address stored in errorCode_ptr.
//         ERROR_SEARCH_NOT_FOUND - This MACRO is to be used when the string located at searchWord_ptr has not
//             been found inside the string located at sentence_ptr.  The return value of the function will of
//             course be NULL but the function also needs to store this MACRO in the memory address stored in
//             errorCode_ptr.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

/* Error code default value */
#ifdef DEFAULT_ERROR_CODE
#undef DEFAULT_ERROR_CODE
#endif
#define DEFAULT_ERROR_CODE 90318

/* Just in case NULL was undefined... */
#ifndef NULL
#define NULL ((void*) 0)
#endif

/* Error code for success */
#ifdef ERROR_CODE_SUCCESS
#undef ERROR_CODE_SUCCESS
#endif
#define ERROR_CODE_SUCCESS ((int)1)

/* Error code if sentence_ptr is NULL */
#ifdef ERROR_NULL_SENTENCE_POINTER
#undef ERROR_NULL_SENTENCE_POINTER
#endif
#define ERROR_NULL_SENTENCE_POINTER ((int)-1)

/* Error code if searchWord_ptr is NULL */
#ifdef ERROR_NULL_SEARCH_POINTER
#undef ERROR_NULL_SEARCH_POINTER
#endif
#define ERROR_NULL_SEARCH_POINTER ((int)-2)

/* Error code is the string in searchWord_ptr can not be found in the string located at sentence_ptr */
#ifdef ERROR_SEARCH_NOT_FOUND
#undef ERROR_SEARCH_NOT_FOUND
#endif
#define ERROR_SEARCH_NOT_FOUND ((int)-3)

/* Standard array size for manual dimension declaration */
#ifdef BUFF_SIZE
#undef BUFF_SIZE
#endif
#define BUFF_SIZE 1024

/*
 * FUNCTION:   find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
 *
 * ARGUMENTS:  sentence_ptr is a char pointer to a null-terminated string to search
 *             searchWord_ptr is a char pointer to a null-terminated string to find inside sentence_ptr
 *             errorCode_ptr is an int pointer.  Store your error code at this memory address.
 *
 * RETURNS:	   char pointer to the first occurrence of the searchWord_ptr string found in the
 *                 sentence_ptr string.  The char pointer should be a memory address in the
 *                 sentence_ptr string and this memory address should represent the first 'index'
 *                 of the searchWord_ptr string.  This memory address from the sentence_ptr string
 *                 should dereference to a value equivalent to searchWord_ptr[0].
 *             All other occurences should return NULL.  This includes, but is not limited to, the
 *                 following:
 *                     sentence_ptr is NULL
 *                     searchWord_ptr is NULL
 *                     errorCode_ptr is NULL
 *                     the searchWord_ptr string is not found in the sentence_ptr string
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at both sentence_ptr and searchWord_ptr
 *             Only access elements of the char array found at both sentence_ptr and searchWord_ptr
 *                 using address arithmetic (AKA pointer math).  The definition of this function should 
 *                 be entirely devoid of the [ and ] characters.  (e.g., sentence_ptr[i] is forbidden)
 *             The only guarantees for the arguments are:
 *                 Any string found at sentence_ptr is null-terminated
 *                 Any string found at searchWord_ptr is null-terminated
 *             There is no guarantee sentence_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee searchWord_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee errorCode_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee the string found at sentence_ptr contains the string found at 
 *                 searchWord_ptr (return NULL if the string at searchWord_ptr is not found and assign the
 *                 proper error code)
 *             There is no guarantee the strings found at both sentence_ptr and searchWord_ptr will
 *                 return a string length longer than zero (0)
 */
char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr);

int main(void)
{
	int i = 0; 
	int numTestsRun = 0;
	int numTestsPassed = 0;
	int putErrorCodeHere = DEFAULT_ERROR_CODE;
	char * tempReturnValue_ptr = NULL;
	char testChar1 = 0; // DEBUGGING
	char testChar2 = 0; // DEBUGGING

	/* TEST INPUT */
	// Three normal strings
	char testInput0[] = { "Good luck to you on this lab.\nI hope you do well." }; // Key: \n
	char testInput1[] = { "Normal test input.  'The' is the search key." }; // Key: The
	char testInput2[] = { "This is also normal input.  The 'bird' is the word." }; // Key: bird
	// Two strings that have duplicate keys
	char testInput3[] = { "This string is an example of a string that has two occurrences of the word 'is'." }; // Key: is
	char testInput4[] = { "The word 'the' is very common in the English language." }; // Key: the
	// Two strings that have multiple occurrences of the key
	char testInput5[] = { "Many English words are 'loan words', which is defined as 'a word that has been adopted from one language into another'." }; // Key: word
	char testInput6[] = { "The search keys don't have to be letters!  They could be any character or array of characters!  They could even be puntuation!  Maybe even non-printable characters!  Crazy, right?" }; // Key: "!  "
	// Two NULL strings to pass as sentence_ptr
	char * testInput7 = NULL; // Key: "Doesn't matter"
	char * testInput8 = NULL; // Key: "Don't bother"
	// Two real strings to pass alongside a NULL searchWord
	char testInput9[] = { "It's a shame to waste a perfectly good sentence." }; // Key:  NULL
	char testInput10[] = { "It's a shame to waste a perfectly good null-terminated string." }; // Key:  NULL
	// Two real strings to pass alongside a NULL errorCode
	char testInput11[] = { "At least electrons are free." }; // Key: are
	char testInput12[] = { "Even if they're not free, there is are a plethora of electrons freely available." }; // Key: e
	// Two strings that will pass more NULL search keys
	char testInput13[] = { "You can't find a key here!" }; // Key: NULL
	char testInput14[] = { "Take a picture!  It'll last longer." }; // Key: NULL
	// Two strings to pass long keys
	char testInput15[] = { "Now is the time for all good men to come to the aid of their country." }; // Key: "come to the aid"
	char testInput16[] = { "Sometimes it's hard to play the game the way it was intended to be played instead of following the game's rules as written." }; // Key: "play the game"
	// Edge cases that may break find_the_word()
	char testInput17[] = { "I hope you didn't find anything here!" }; // Key: '\0' (0x0)
	char testInput18[BUFF_SIZE] = { 0 }; // Key: "Don't do it!"
	char testInput19[] = { "Not a long string" }; // Key: "long string as a search key"
	char testInput20[] = { "part" }; // Key: "partial"
	char testInput21[BUFF_SIZE] = { 0 }; // Key: '\0' (0x0)
	// Two strings whose keys are non printable characters
	char testInput22[] = { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x0 }; // Key: 0x8
	char testInput23[] = { 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x0 }; // Key: 0x1C
	// Two strings that include characters from the extended ASCII codes
	char testInput24[] = { '\n', 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, '\n', 0x7C, '$', '(', '5', ')', '$', 0x7C, '\n', 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, '\n', 0x0 }; // Key: 0xC4
//	puts(testInput24); // DEBUGGING
	char testInput25[] = {0xC4, 0x5C, 0x5F, 0x2, 0x5F, 0x2F, 0xC4, 0x0}; // Key: 0x2F
//	puts(testInput25); // DEBUGGING
	char testInput26[] = { "Sometimes keys are at the beggining of a string." }; // Key: "Sometime"
	char testInput27[] = { "When you lose an item, you always find it in the last place you look." }; // Key: "look."
	char * testInputArray[] = { \
		testInput0, testInput1, testInput2, \
		testInput3, testInput4, testInput5, \
		testInput6, testInput7, testInput8, \
		testInput9, testInput10, testInput11, \
		testInput12, testInput13, testInput14, \
		testInput15, testInput16, testInput17, \
		testInput18, testInput19, testInput20, \
		testInput21, testInput22, testInput23, \
		testInput24, testInput25, testInput26, \
	    testInput27 };

	/* TEST SEARCH KEYS */
	char testKey0[] = {10,0};
	char testKey1[] = { "The" };
	char testKey2[] = { "bird" };
	char testKey3[] = { "is" };
	char testKey4[] = { "the" };
	char testKey5[] = { "word" };
	char testKey6[] = { "!  " };
	char testKey7[] = { "Doesn't matter" };
	char testKey8[] = { "Don't bother" };
	char * testKey9 = NULL;
	char * testKey10 = NULL;
	char testKey11[] = {"are"};
	char testKey12[] = {"e"};
	char * testKey13 = NULL;
	char * testKey14 = NULL;
	char testKey15[] = {"come to the aid"};
	char testKey16[] = {"play the game"};
	char testKey17[] = {0x0, 0x0};
	char testKey18[] = {"Don't do it!"};
	char testKey19[] = {"long string as a search key"};
	char testKey20[] = {"partial"};
	char testKey21[1] = {0x0};
	char testKey22[] = {0x8, 0x0};
	char testKey23[] = {0x1C, 0x0};
	char testKey24[] = {0xC4, 0x0};
	char testKey25[] = {0x2F, 0x0};
	char testKey26[] = { "Sometime" };
	char testKey27[] = { "look." };
	char * testKeyArray[] = { \
		testKey0, testKey1, testKey2, \
		testKey3, testKey4, testKey5, \
		testKey6, testKey7, testKey8, \
		testKey9, testKey10, testKey11, \
		testKey12, testKey13, testKey14, \
		testKey15, testKey16, testKey17, \
		testKey18, testKey19, testKey20, \
		testKey21, testKey22, testKey23, \
		testKey24, testKey25, testKey26, \
	    testKey27 };

	/* TEST ERROR CODE POINTERS */
	int * errorCodePointerArray[] = { \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, NULL, \
		NULL, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
		&putErrorCodeHere, &putErrorCodeHere, &putErrorCodeHere, \
	    &putErrorCodeHere };

	/* TEST RETURN VALUES */
	char * expectedReturnValueArray[] = { \
		&testInput0[29], &testInput1[21], &testInput2[33], \
		&testInput3[2], &testInput4[10], &testInput5[13], \
		&testInput6[40], testInput7, testInput8, \
		NULL, NULL, NULL, \
		NULL, NULL, NULL, \
		&testInput15[36], &testInput16[23], NULL, \
		NULL, NULL, NULL, \
		NULL, &testInput22[7], &testInput23[2], \
		&testInput24[17], &testInput25[5], &testInput26[0], \
	    &testInput27[64]};

	/* TEST ERROR CODES */
	int expectedErrorCodeArray[] = { \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_NULL_SENTENCE_POINTER, ERROR_NULL_SENTENCE_POINTER, \
		ERROR_NULL_SEARCH_POINTER, ERROR_NULL_SEARCH_POINTER, DEFAULT_ERROR_CODE, \
		DEFAULT_ERROR_CODE, ERROR_NULL_SEARCH_POINTER, ERROR_NULL_SEARCH_POINTER, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_SEARCH_NOT_FOUND, \
		ERROR_SEARCH_NOT_FOUND, ERROR_SEARCH_NOT_FOUND, ERROR_SEARCH_NOT_FOUND, \
		ERROR_SEARCH_NOT_FOUND, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
		ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, ERROR_CODE_SUCCESS, \
	    ERROR_CODE_SUCCESS };

	/* CALCULATE THE NUMBER OF TESTS */
	int numTotalTests = sizeof(testInputArray) / sizeof(testInputArray[0]);
//	printf("The length of the test array is: %d \n", sizeof(testInputArray)/sizeof(testInputArray[0])); // DEBUGGING

	/* EXECUTE THE TESTS */
	for (i = 0; i < numTotalTests; i++)
	{
		/* 0. TEST HEADER */
		printf("\n");
		printf("************\n");
		printf("* TEST #%02d *\n", i);
		printf("************\n");
		tempReturnValue_ptr = find_the_word(testInputArray[i], testKeyArray[i], errorCodePointerArray[i]);

		/* 1. TEST RETURN VALUE */
		numTestsRun++;
		printf("\tReturn Value Test:\t");
		if (tempReturnValue_ptr == expectedReturnValueArray[i])
		{
			puts("Pass");
			numTestsPassed++;
		}
		else
		{
			puts("FAIL!");
			printf("\t\tExpected pointer:\t%p\n", expectedReturnValueArray[i]);
			printf("\t\tReceived pointer:\t%d\n", tempReturnValue_ptr);
		}

		/* 2. TEST ERROR CODE */
		numTestsRun++;
		printf("\tError Code Test:\t");
		if (putErrorCodeHere == expectedErrorCodeArray[i])
		{
			puts("Pass");
			numTestsPassed++;
		}
		else
		{
			puts("FAIL!");
			printf("\t\tExpected error code:\t%d\n", expectedErrorCodeArray[i]);
			printf("\t\tReceived error code:\t%d\n", putErrorCodeHere);
			if (putErrorCodeHere == DEFAULT_ERROR_CODE)
			{
				puts("\t\tError code not even updated!");
			}
		}

		putErrorCodeHere = DEFAULT_ERROR_CODE; // Reset error code
	}

	if (numTestsRun)
	{
		printf("\n\n\n*******************************\n");
		printf("Out of the %d tests that ran...\n", numTestsRun);
		printf("%d tests passed.\n", numTestsPassed);
		printf("*******************************\n"); 
	}
	
	return 0;
}

/*
 * FUNCTION:   find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
 *
 * ARGUMENTS:  sentence_ptr is a char pointer to a null-terminated string to search
 *             searchWord_ptr is a char pointer to a null-terminated string to find inside sentence_ptr
 *             errorCode_ptr is an int pointer.  Store your error code at this memory address.
 *
 * RETURNS:	   char pointer to the first occurrence of the searchWord_ptr string found in the
 *                 sentence_ptr string.  The char pointer should be a memory address in the
 *                 sentence_ptr string and this memory address should represent the first 'index'
 *                 of the searchWord_ptr string.  This memory address from the sentence_ptr string
 *                 should dereference to a value equivalent to searchWord_ptr[0].
 *             All other occurences should return NULL.  This includes, but is not limited to, the
 *                 following:
 *                     sentence_ptr is NULL
 *                     searchWord_ptr is NULL
 *                     errorCode_ptr is NULL
 *                     the searchWord_ptr string is not found in the sentence_ptr string
 *
 * NOTES:      This function only utilizes address arithmetic to access information within the
 *                 null-terminated char array found at both sentence_ptr and searchWord_ptr
 *             Only access elements of the char array found at both sentence_ptr and searchWord_ptr
 *                 using address arithmetic (AKA pointer math).  The definition of this function should
 *                 be entirely devoid of the [ and ] characters.  (e.g., sentence_ptr[i] is forbidden)
 *             The only guarantees for the arguments are:
 *                 Any string found at sentence_ptr is null-terminated
 *                 Any string found at searchWord_ptr is null-terminated
 *             There is no guarantee sentence_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee searchWord_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee errorCode_ptr has an address (return NULL if it's NULL and assign the
 *                 proper error code)
 *             There is no guarantee the string found at sentence_ptr contains the string found at
 *                 searchWord_ptr (return NULL if the string at searchWord_ptr is not found and assign the
 *                 proper error code)
 *             There is no guarantee the strings found at both sentence_ptr and searchWord_ptr will
 *                 return a string length longer than zero (0)
 */
char * find_the_word(char * sentence_ptr, char * searchWord_ptr, int * errorCode_ptr)
{
	char testChar1 = 0; // DEBUGGING
	char testChar2 = 0; // DEBUGGING
	char * returnValue_ptr = NULL;
	int sentenceLength = 0;
	int searchWordLength = 0;
	int i = 0;
	int j = 0;

	if (!sentence_ptr)
	{
		returnValue_ptr = NULL;
		*errorCode_ptr = ERROR_NULL_SENTENCE_POINTER;
	}
	else if (!searchWord_ptr)
	{
		returnValue_ptr = NULL;
		*errorCode_ptr = ERROR_NULL_SEARCH_POINTER;
	}
	else if (!errorCode_ptr)
	{
		returnValue_ptr = NULL;
	}
	else
	{
		sentenceLength = strlen(sentence_ptr);
		searchWordLength = strlen(searchWord_ptr);
		if (searchWordLength > sentenceLength)
		{
			returnValue_ptr = NULL;
			*errorCode_ptr = ERROR_SEARCH_NOT_FOUND;
		}
		else
		{
			*errorCode_ptr = ERROR_SEARCH_NOT_FOUND;
			for (i = 0; i <= (sentenceLength - searchWordLength); i++)
			{
				testChar1 = *(sentence_ptr + i);
				testChar2 = *(searchWord_ptr);
				if (*(sentence_ptr + i) == *(searchWord_ptr)) // If the first letter of the Key matches the current value...
				{
					if (searchWordLength == 1)
					{
						returnValue_ptr = (sentence_ptr + i);
						*errorCode_ptr = ERROR_CODE_SUCCESS;
						return returnValue_ptr;
					}
					else
					{
						for (j = 1; j < searchWordLength; j++) // ...check for the rest of the Key
						{
							if (*(sentence_ptr + i + j) != *(searchWord_ptr + j))
							{
								break; // No match
							}
							else if (j == (searchWordLength - 1))
							{
								returnValue_ptr = (sentence_ptr + i);
								*errorCode_ptr = ERROR_CODE_SUCCESS;
								return returnValue_ptr;
							}
						}
					}
				}
			}
		}
	}

	return returnValue_ptr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-5 ////////////////////////////////////////////
//////////////////////////////////////////////////// POINTER ARRAYS ////////////////////////////////////////////////
////////////////////////////////////////////// "Good Order and Discipline" /////////////////////////////////////////
////////////////////////////////////////////////// Stub Code (bad code) ////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test counting_array()
// The version of counting_array() in this solution will rarely pass tests, if at all
// The student will write parallel arrays of test parameters for counting_array() which, at a minimum, includes:
//     inputStartingNumbers - A parallel integer array of "starting numbers"
//     inputEndingNumbers - A parallel integer array of "ending numbers"
//     expectedErrorCodes - A parallel integer array of expected "error codes"
//     expectedIntArrays - A parallel array of integer arrays which holds the expected output
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke counting_array() with a starting number, an ending number, and an integer pointer to store
//             the resulting errorCode.
//         2. Test the dereferenced value of the integer pointer against what is expected.
//         3. Test the returned integer pointer against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// 
// TESTING SPECIFICATIONS
// Write one test for each of the following conditions:
// Test #		startingNumber		endingNumber		expectedErrorCode
// 1.			x					y					0
// 2.			a					y					0
// 3.			a					b					0
// 4.			y					x					-2
// 5.			b					a					-2
// 6.			y					a					-2
// NOTE 1:  If a < b < 0 < x < y
// NOTE 2:  The values of a, b, x, and y don't have to be the same each time.  In fact, it's best for testing
//     if they're not always the same.
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  counting_array() has been written with good code *and* bad code so that students can practice both
//     conditions as they write their tests.  This version of counting_array() happens to be the version that 
//     will likely fail all tests as listed.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements 
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.  
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode);

int main(void)
{
	puts("You still need to write parallel arrays to test counting_array()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode)
{
	/* WRITE SOME BAD CODE HERE */
	int * returnValue_ptr = NULL;	// Return value variable
	int randomErrorCode = 0;		// Return error code variable
	int i = 0;						// Iterating variable
//	int j = 0;						// Iterating variable
	int tempArrayDimension = 0;		// Variable which holds the calculated dimension of the int array to return
	int randomAlgorithm = 0;		// Variable which stores randomized algorithm to execute WRT the int array
	int tempIndexNumber = 0;		// Variable used to temporarily store an index number
	/* Attempt to Sleep */
#ifdef _WIN32
	Sleep(1000);
#elif defined(__linux__) || defined(__unix__)
	sleep(1);
#endif

	/* Seed the rand() function */
	srand((unsigned int)time(NULL));

	/* Randomize a 'sign' */
	int sign = (rand() % (2));
	if (!sign)
	{
		sign -= 1;
	}

	/* Randomize an Error Code */
	randomErrorCode = sign * (rand() % (90318 - 1)) + 1; // Randomize an error code

	if (!errorCode)					// If the int pointer is NULL...
	{
		returnValue_ptr = NULL;		// ...set the return value as NULL and...
//		randomErrorCode = -1;		// ...set the error code variable to -1
	}
	if (startingNumber > endingNumber)	// If the start number is greater than the end number...
	{
		returnValue_ptr = NULL;			// ...set the return value as NULL and...
//		randomErrorCode = -2;			// ...set the error code variable to -2
	}
	else // Otherwise, the parameters are fine (so far)
	{
		tempArrayDimension = endingNumber - startingNumber + 1; // Compute the dimension of the int array to return

		/* Paranoid error check */
		if (tempArrayDimension > 0) // If the calculated dimension is valid...
		{
			/* AVAILABLE ALGORITHMS */
			// 1. NULL Pointer; Error Code 0
			// 2. Unitialized Memory; Random Error Code
			// 3. Pointer to appropriately sized memory, zeroized; Random Error Code
			// 4. Pointer to appropriately sized memory, backwards values; Random Error Code
			// 5. Pointer to appropriately sized memory, random values; Random Error Code
			// 6. Pointer to appropriately sized memory, appropriate values (first element is wrong); Error Code 0
			// 7. Pointer to appropriately sized memory, appropriate values (middle element is wrong); Random Error Code
			// 8. Pointer to appropriately sized memory, appropriate values (last element is wrong); Random Error Code
			// 9. Pointer to appropriately sized memory, appropriate values (random element is wrong); Random Error Code
			// 10. Pointer to appropriately sized memory, appropriate values; Random Error Code
			// 11. Pointer to appropriately sized memory, appropriate values; Appropriate Error Code

			/* RESPONSE CONSTRUCTION */
			/* Randomize an algorithm to use */
			randomAlgorithm = (rand() % 11) + 1; // Randomize from 1 to 10

			/* A. Memory Allocation */
			switch (randomAlgorithm) // To allocate or not to allocate?  That is the question.
			{
			case 1:		// Return a NULL pointer regardless
				returnValue_ptr = NULL;
				randomErrorCode = 0;
				break;
			case 2:		// Return a pointer to unitialized memory
				returnValue_ptr = (int *)malloc((sizeof(int) * tempArrayDimension));
				break;
			default:	// Return a pointer to initiailzed memory
				returnValue_ptr = (int *)calloc(tempArrayDimension, sizeof(int)); // Dynamically allocate initialized memory into an appropriately sized int array
				break;
			}

			if (returnValue_ptr)
			{
				/* B. Memory Values */
				switch (randomAlgorithm) // To assign values or not to assign values?  That is the question.
				{
				case 1:		// NULL pointer so... no values to assign
				case 2:		// Leave the memory unitialized
				case 3:		// Leave the memory zeroized
					break;
				case 4:		// Initialize the array with backwards values

					/* ...initialize that int array with the appropriate values */
					for (i = 0; i < tempArrayDimension; i++)
					{
						*(returnValue_ptr + i) = endingNumber - i;
					}

					break;
				case 5:		// Initialize the memory with random values
					/* ...initialize that int array with the appropriate values */
					for (i = 0; i < tempArrayDimension; i++)
					{
						/* Seed the rand() function */
						srand((unsigned int)i);

						/* Feed a random value into the current element */
						*(returnValue_ptr + i) = (rand() % (i + 1)); // (i + 1) to avoid "divide by 0" errors
					}
					break;
				default:	// Properly initialize memory
					/* ...initialize that int array with the appropriate values */
					for (i = 0; i < tempArrayDimension; i++)
					{
						*(returnValue_ptr + i) = (startingNumber + i);
					}
					break;
				}


				/* C. Value Tweaks */
				switch (randomAlgorithm)
				{
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
					break;
				case 6:
					if (tempArrayDimension > 0)
					{
						if (*(returnValue_ptr) != 0xDEADC0DE)
						{
							*(returnValue_ptr) = 0xDEADC0DE;
						}
						else
						{
							*(returnValue_ptr) = 0xC0DEDEAD;
						}

						randomErrorCode = 0;
					}
					break;
				case 7:
					if (tempArrayDimension > 1)
					{
						tempIndexNumber = (int)(tempArrayDimension / 2);
						if (*(returnValue_ptr + tempIndexNumber) != 0xDEADC0DE)
						{
							*(returnValue_ptr + tempIndexNumber) = 0xDEADC0DE;
						}
						else
						{
							*(returnValue_ptr + tempIndexNumber) = 0xC0DEDEAD;
						}
						tempIndexNumber = 0;
					}
					else
					{
						returnValue_ptr = NULL;
						randomErrorCode = -3;
					}
					break;
				case 8: // Last element is mangled; Random error code
					if (tempArrayDimension > 0)
					{
						tempIndexNumber = (tempArrayDimension - 1);
						if (*(returnValue_ptr + tempIndexNumber) != 0xDEADC0DE)
						{
							*(returnValue_ptr + tempIndexNumber) = 0xDEADC0DE;
						}
						else
						{
							*(returnValue_ptr + tempIndexNumber) = 0xC0DEDEAD;
						}
					}
					else
					{
						returnValue_ptr = NULL;
						randomErrorCode = -3;
					}
					tempIndexNumber = 0;
					break;
				case 9: // Random element is mangled; Random error code
					if (tempArrayDimension)
					{
						tempIndexNumber = (rand() % tempArrayDimension);
						if (tempIndexNumber >= 0 && tempIndexNumber < tempArrayDimension)
						{
							if (*(returnValue_ptr + tempIndexNumber) != 0xDEADC0DE)
							{
								*(returnValue_ptr + tempIndexNumber) = 0xDEADC0DE;
							}
							else
							{
								*(returnValue_ptr + tempIndexNumber) = 0xC0DEDEAD;
							}
						}
					}
					tempIndexNumber = 0;
					break;
				case 10: // Normal behavior; Proper int pointer to an int array; Random error code
					break;
				default: // Normal behavior; Proper int pointer to an int array; Error code 0
					randomErrorCode = 0;
					break;
				}

			}
			else // Otherwise, dynamic memory allocation failed so...
			{
				returnValue_ptr = NULL; // ...return NULL and...
				randomErrorCode = -3;	// ...set the error code to -3 (which should be a very rare occurrence)
			}
		}
		else
		{
			returnValue_ptr = NULL;
		}
	}
	
	if (errorCode) // If errorCode is *NOT* NULL...
	{
		*errorCode = randomErrorCode; // ...set the value at that memory address to the error code variable value
	}
	return returnValue_ptr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-5 ////////////////////////////////////////////
//////////////////////////////////////////////////// POINTER ARRAYS ////////////////////////////////////////////////
////////////////////////////////////////////// "Good Order and Discipline" /////////////////////////////////////////
////////////////////////////////////////////////// Stub Code (good code) ///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test counting_array()
// The version of counting_array() in this solution is 100% functional
// The student will write parallel arrays of test parameters for counting_array() which, at a minimum, includes:
//     inputStartingNumbers - A parallel integer array of "starting numbers"
//     inputEndingNumbers - A parallel integer array of "ending numbers"
//     expectedErrorCodes - A parallel integer array of expected "error codes"
//     expectedIntArrays - A parallel array of integer arrays which holds the expected output
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke counting_array() with a starting number, an ending number, and an integer pointer to store
//             the resulting errorCode.
//         2. Test the dereferenced value of the integer pointer against what is expected.
//         3. Test the returned integer pointer against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// 
// TESTING SPECIFICATIONS
// Write one test for each of the following conditions:
// Test #		startingNumber		endingNumber		expectedErrorCode
// 1.			x					y					0
// 2.			a					y					0
// 3.			a					b					0
// 4.			y					x					-2
// 5.			b					a					-2
// 6.			y					a					-2
// NOTE 1:  If a < b < 0 < x < y
// NOTE 2:  The values of a, b, x, and y don't have to be the same each time.  In fact, it's best for testing
//     if they're not always the same.
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  counting_array() has been written with good code *and* bad code so that students can practice both
//     conditions as they write their tests.  This version of counting_array() happens to be the version that 
//     passes all tests as listed.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements 
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.  
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode);

int main(void)
{
	puts("You still need to write parallel arrays to test sorting_hat()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode)
{
	int * returnValue_ptr = NULL;	// Return value variable
	int returnErrorCode = 0;		// Return error code variable
	int i = 0;						// Iterating variable
	int tempArrayDimension = 0;		// Variable which holds the calculated dimension of the int array to return

	if (!errorCode)					// If the int pointer is NULL...
	{
		returnValue_ptr = NULL;		// ...set the return value as NULL and...
		returnErrorCode = -1;		// ...set the error code variable to -1
	}
	if (startingNumber > endingNumber)	// If the start number is greater than the end number...
	{
		returnValue_ptr = NULL;			// ...set the return value as NULL and...
		returnErrorCode = -2;			// ...set the error code variable to -2
	}
	else // Otherwise, the parameters are fine (so far)
	{
		tempArrayDimension = endingNumber - startingNumber + 1; // Compute the dimension of the int array to return

		/* Paranoid error check */
		if (tempArrayDimension > 0) // If the calculated dimension is valid...
		{
			returnValue_ptr = (int *)calloc(tempArrayDimension, sizeof(int)); // Dynamically allocate initialized memory into an appropriately sized int array

			/* Semi-Paranoid error check */
			if (returnValue_ptr) // If calloc actually returned a pointer to valid memory space...
			{
				/* ...initialize that int array with the appropriate values */
				for (i = 0; i < tempArrayDimension; i++)
				{
					*(returnValue_ptr + i) = (startingNumber + i);
				}
			}
			else // Otherwise, calloc messed up so...
			{
				returnValue_ptr = NULL; // ...return NULL and...
				returnErrorCode = -3;	// ...set the error code to -3 (which should be a very rare occurrence)
			}
		}
	}
	
	if (errorCode) // If errorCode is *NOT* NULL...
	{
		*errorCode = returnErrorCode; // ...set the value at that memory address to the error code variable value
	}
	return returnValue_ptr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// PERFORMANCE LAB (I.5.A) 6 /////////////////////////////////////////////
////////////////////////////////////////////// MULTI-DIMENSIONAL ARRAYS /////////////////////////////////////////////
//////////////////////////////////////////////////// "Tic Tac Toe" //////////////////////////////////////////////////
////////////////////////////////////////////////////// Stub Code ////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Replicate a tic tac toe grid using a two-dimensional char array of global scope (for ease of use)
// Define the following prototype functions in main(void) according to their specifications:
//     int printTheGrid(void);
//     int any_plays_left(void);
//     char did_someone_win(void);
//     int what_is_your_play(char currentPlayer, int gridLocation);
// Loop through those functions, in the order listed above and below, taking input until:
//     Someone wins *or*
//     There are no more selections (stalemate)
// Check for bad input (e.g., Selection 99) and reported errors (e.g., what_is_your_play() should return -1 on
//     an invalid selection)
// Direct reference to array elements (e.g., myArray[0][1]) is authorized.  In other words, pointer arithmetic
//     is not mandatory.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

/*
 * FUNCTION:   int print_the_grid(void)
 *
 * ARGUMENTS:  NONE
 *
 * RETURNS:	   On success, 1
 *             On failure, 0
 *
 * NOTES:      This function should first print out a tic tac toe legend:
 *              1 | 2 | 3
 *             -----------
 *              4 | 5 | 6
 *             -----------
 *              7 | 8 | 9
 *
 *             Then, this function should print out the current state of the 2D char array in a similar format:
 *                |   | X
 *             -----------
 *              X | O |  
 *             -----------
 *                |   |  
 */
int print_the_grid(void);

/*
 * FUNCTION:   int any_plays_left(void)
 *
 * ARGUMENTS:  NONE
 *
 * RETURNS:	   On success, the number of available choices
 *             On failure, 0
 *
 * NOTES:      This function should count and return the number of remaining 'moves' from the 2D array
 */
int any_plays_left(void);

/*
 * FUNCTION:   char did_someone_win(void)
 *
 * ARGUMENTS:  NONE
 *
 * RETURNS:	   On success, the character of the winner (should be either 'X' or 'O') or 0 for "no winner"
 *             On failure, 0
 *
 * NOTES:      There are 8 possible win conditions:
 *                 Top row, middle row, bottom row
 *                 Left column, middle column, right column
 *                 Backslash, "Frontslash" (TM pending)
 */
char did_someone_win(void);

/*
 * FUNCTION:   int what_is_your_play(char currentPlayer, int gridLocation)
 *
 * ARGUMENTS:  char currentPlayer should either be 'X' or 'O' to represent the char to store
 *             int gridLocation should indicate the position on the grid to place "currentPlayer" as
 *                 defined by whomever defined print_the_grid().
 *
 * RETURNS:	   On a successful choice, 1
 *             If the user chooses a location that has already been taken, 0
 *             On failure, -1
 *
 * NOTES:      Verify that gridLocation has not already been chosed before accepting the play
 *             If the play is valid, record the selection within the 2D tic tac toe array
 */
int what_is_your_play(char currentPlayer, int gridLocation);

/* TIC TAC TOE char array */
char ticTacToeGrid[3][3];

int main(void)
{
	puts("Good luck to you."); // Remove this

	/* PRINT THE LEGEND AND CURRENT STATUS OF THE GAME */
	print_the_grid();

	/* DETERMINE IF THERE ARE NO MORE MOVES LEFT */
	any_plays_left();

	/* DID SOMEONE WIN?  INFORM THE PLAYERS AND END THE GAME */
	did_someone_win();

	/* OTHERWISE, ALLOW THE NEXT PLAYER TO MAKE A MOVE */
	what_is_your_play('U', 0);

	// NOTE:  Don't forget error checking and input validation along the way.

	return 0;
}

/*
 * FUNCTION:   int printTheGrid(void)
 *
 * ARGUMENTS:  NONE
 *
 * RETURNS:	   On success, 1
 *             On failure, 0
 *
 * NOTES:      This function should first print out a tic tac toe legend:
 *              1 | 2 | 3
 *             -----------
 *              4 | 5 | 6
 *             -----------
 *              7 | 8 | 9
 *
 *             Then, this function should print out the current state of the 2D char array in a similar format:
 *                |   | X
 *             -----------
 *              X | O |
 *             -----------
 *                |   |
 */
int print_the_grid(void)
{
	puts("No grid was printed."); // Remove this

	return 0x90C05; // You'll need to change this
}

/*
 * FUNCTION:   int any_plays_left(void)
 *
 * ARGUMENTS:  NONE
 *
 * RETURNS:	   On success, the number of available choices
 *             On failure, 0
 *
 * NOTES:      This function should count and return the number of remaining 'moves' from the 2D array
 */
int any_plays_left(void)
{
	puts("The 2D array was not evaluated."); // Remove this

	return 0x90C05; // You'll need to change this
}

/*
 * FUNCTION:   char did_someone_win(void)
 *
 * ARGUMENTS:  NONE
 *
 * RETURNS:	   On success, the character of the winner (should be either 'X' or 'O') or 0 for "no winner"
 *             On failure, 0
 *
 * NOTES:      There are 8 possible win conditions:
 *                 Top row, middle row, bottom row
 *                 Left column, middle column, right column
 *                 Backslash, "Frontslash" (TM pending)
 */
char did_someone_win(void)
{
	puts("Nobody knows who won."); // Remove this

	return 0x90C05; // You'll need to change this
}

/*
 * FUNCTION:   int what_is_your_play(char currentPlayer, int gridLocation)
 *
 * ARGUMENTS:  char currentPlayer should either be 'X' or 'O' to represent the char to store
 *             int gridLocation should indicate the position on the grid to place "currentPlayer" as
 *                 defined by whomever defined print_the_grid().
 *
 * RETURNS:	   On a successful choice, 1
 *             If the user chooses a location that has already been taken, 0
 *             On failure, -1
 *
 * NOTES:      Verify that gridLocation has not already been chosed before accepting the play
 *             If the play is valid, record the selection within the 2D tic tac toe array
 */
int what_is_your_play(char currentPlayer, int gridLocation)
{
	puts("No play was made."); // Remove this

	return 0x90C05; // You'll need to change this}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// PERFORMANCE LAB (I.5.A) 8 /////////////////////////////////////////////
///////////////////////////////////////////////// FUNCTION POINTERS /////////////////////////////////////////////////
/////////////////////////////////////////// "Every integer is bigger in Texas" //////////////////////////////////////
///////////////////////////////////////////////// Instructor Solution ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Define each of the following function prototypes IAW their associated comment blocks:
//     int low_to_high_compare(int x, int y)
//     int high_to_low_compare(int x, int y)
//     int absolute_low_to_high_compare(int x, int y)
//     int absolute_high_to_low_compare(int x, int y)
// Write eight (8) tests for bubble_sort() (see: the comment block below), two tests for each of the function
//     prototypes listed above. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <math.h>

#ifndef TRUE
#define TRUE ((int)1)
#endif

#ifndef FALSE
#define FALSE ((int)0)
#endif

/*
 * FUNCTION:   low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is greater than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is greater than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 1
 */
int low_to_high_compare(int x, int y);				// Choice 1

/*
 * FUNCTION:   int high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is less than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is less than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 0
 */
int high_to_low_compare(int x, int y);				// Choice 2

/*
 * FUNCTION:   int absolute_low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 *  RETURNS:   If the absolute value of x is greater than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is greater than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Smaller numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 0
 */
int absolute_low_to_high_compare(int x, int y);		// Choice 3

/*
 * FUNCTION:   absolute_high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:    If the absolute value of x is less than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is less than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Large numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 1
 */
int absolute_high_to_low_compare(int x, int y);		// Choice 4


/*
 * FUNCTION:   bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int))
 *
 * ARGUMENTS:  arrayOfInts - a pointer to an array of integers
 *             numOfElements - the dimension of the integer array found at the int pointer arrayOfInts
 *             compare_function - a function pointer; This function should take two ints as parameters
 *                 and return an int.  The expectation is that compare_function performs a comparison
 *                 of the two ints and returns a boolean value.  This boolean value should represent
 *                 whether or not the two ints should be swapped.  If the return value of compare_function
 *                 is 1, then the two ints should be swapped in place.
 *
 * RETURNS:    The total number of int swaps that were made
 *             0 if no swaps were made
 *             -1 if any pointer is NULL
 *             -2 if numOfElements is unrealistic
 *             -3 on any other error             
 *
 * NOTES:      This function is already defined below.  Do not modify this function.
 *             This function will sort, in place, the first "numOfElements" elements that are found
 *                 in the integer array found at pointer "arrayOfInts".  To accomplish this, bubble_sort()
 *                 will utilize the comparison function found at "compare_function" to accomplish this.
 *                 The expectation is that compare_function will compare two ints, n1 and n2.  In this, it
 *                 is expected that n1 comes before n2.  If n1 needs to swap with n2, compare_function will
 *                 return 1.  If not, compare_function will return 0.  Any other return value from
 *                 compare_function will be considered an error value (see: RETURNS).
 */
int bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int));

int main(void)
{
	/********************/
	/* Place code here! */
	/********************/

	return 0;
}

/*
 * FUNCTION:   low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is greater than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is greater than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 1
 */
int low_to_high_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   int high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is less than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is less than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 * 
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 0
 */
int high_to_low_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   int absolute_low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 *  RETURNS:   If the absolute value of x is greater than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is greater than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Smaller numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 0
 */
int absolute_low_to_high_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   absolute_high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:    If the absolute value of x is less than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is less than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Large numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 1
 */
int absolute_high_to_low_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int))
 *
 * ARGUMENTS:  arrayOfInts - a pointer to an array of integers
 *             numOfElements - the dimension of the integer array found at the int pointer arrayOfInts
 *              compare_function - a function pointer; This function should take two ints as parameters
 *                 and return an int.  The expectation is that compare_function performs a comparison
 *                 of the two ints and returns a boolean value.  This boolean value should represent
 *                 whether or not the two ints should be swapped.  If the return value of compare_function
 *                 is 1, then the two ints should be swapped in place.
 *
 * RETURNS:    The total number of int swaps that were made
 *             0 if no swaps were made
 *             -1 if any pointer is NULL
 *             -2 if numOfElements is unrealistic
 *             -3 on any other error
 *
 * NOTES:      This function is already defined below.  Do not modify this function.
 *             This function will sort, in place, the first "numOfElements" elements that are found
 *                 in the integer array found at pointer "arrayOfInts".  To accomplish this, bubble_sort()
 *                 will utilize the comparison function found at "compare_function" to accomplish this.
 *                 The expectation is that compare_function will compare two ints, n1 and n2.  In this, it
 *                 is expected that n1 comes before n2.  If n1 needs to swap with n2, compare_function will
 *                 return 1.  If not, compare_function will return 0.  Any other return value from
 *                 compare_function will be considered an error value (see: RETURNS).
 */
int bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int))
{
	int returnValue = -3;	// Default return value in case something dies
	int i = 0;				// Iterating variable
	int j = 0;				// Iterating variable
	int swapCount = 0;		// Number of element swaps that have been made

	if (!arrayOfInts || !compare_function)	// If either of the pointers are NULL...
	{
		returnValue = -1;	// ...return -1
	}
	else if (numOfElements < 2) // If the number of elements is unrealistic...
	{
		returnValue = -2; // ...return -2
	}
	else
	{
		for (i = 0; i < numOfElements; i++) // Iterate through all of the elements...
		{
			for (j = 0; j < (numOfElements - 1); j++) // ...comparing each element to all the other elements
			{
				if ((compare_function(*(arrayOfInts + j), *(arrayOfInts + j + 1))) > 0) // If the compare function suggests a swap...
				{
					/* ...swap the values stored in each element */
					*(arrayOfInts + j)		= *(arrayOfInts + j) ^ *(arrayOfInts + j + 1);
					*(arrayOfInts + j + 1)	= *(arrayOfInts + j) ^ *(arrayOfInts + j + 1);
					*(arrayOfInts + j)		= *(arrayOfInts + j) ^ *(arrayOfInts + j + 1);
					swapCount++; // A swap took place so increment the number of swaps counted
				}
			}
		}
		returnValue = swapCount; // Return the total number of swaps that took place
	}
	
	return returnValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// PERFORMANCE LAB (I.5.A) 8 /////////////////////////////////////////////
///////////////////////////////////////////////// FUNCTION POINTERS /////////////////////////////////////////////////
/////////////////////////////////////////// "Every integer is bigger in Texas" //////////////////////////////////////
///////////////////////////////////////////////// Instructor Solution ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Define each of the following function prototypes IAW their associated comment blocks:
//     int low_to_high_compare(int x, int y)
//     int high_to_low_compare(int x, int y)
//     int absolute_low_to_high_compare(int x, int y)
//     int absolute_high_to_low_compare(int x, int y)
// Write eight (8) tests for bubble_sort() (see: the comment block below), two tests for each of the function
//     prototypes listed above. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <math.h>

#ifndef TRUE
#define TRUE ((int)1)
#endif

#ifndef FALSE
#define FALSE ((int)0)
#endif

/*
 * FUNCTION:   low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is greater than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is greater than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 1
 */
int low_to_high_compare(int x, int y);				// Choice 1

/*
 * FUNCTION:   int high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is less than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is less than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 0
 */
int high_to_low_compare(int x, int y);				// Choice 2

/*
 * FUNCTION:   int absolute_low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 *  RETURNS:   If the absolute value of x is greater than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is greater than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Smaller numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 0
 */
int absolute_low_to_high_compare(int x, int y);		// Choice 3

/*
 * FUNCTION:   absolute_high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:    If the absolute value of x is less than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is less than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Large numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 1
 */
int absolute_high_to_low_compare(int x, int y);		// Choice 4


/*
 * FUNCTION:   bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int))
 *
 * ARGUMENTS:  arrayOfInts - a pointer to an array of integers
 *             numOfElements - the dimension of the integer array found at the int pointer arrayOfInts
 *             compare_function - a function pointer; This function should take two ints as parameters
 *                 and return an int.  The expectation is that compare_function performs a comparison
 *                 of the two ints and returns a boolean value.  This boolean value should represent
 *                 whether or not the two ints should be swapped.  If the return value of compare_function
 *                 is 1, then the two ints should be swapped in place.
 *
 * RETURNS:    The total number of int swaps that were made
 *             0 if no swaps were made
 *             -1 if any pointer is NULL
 *             -2 if numOfElements is unrealistic
 *             -3 on any other error             
 *
 * NOTES:      This function is already defined below.  Do not modify this function.
 *             This function will sort, in place, the first "numOfElements" elements that are found
 *                 in the integer array found at pointer "arrayOfInts".  To accomplish this, bubble_sort()
 *                 will utilize the comparison function found at "compare_function" to accomplish this.
 *                 The expectation is that compare_function will compare two ints, n1 and n2.  In this, it
 *                 is expected that n1 comes before n2.  If n1 needs to swap with n2, compare_function will
 *                 return 1.  If not, compare_function will return 0.  Any other return value from
 *                 compare_function will be considered an error value (see: RETURNS).
 */
int bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int));

int main(void)
{
	/********************/
	/* Place code here! */
	/********************/

	return 0;
}

/*
 * FUNCTION:   low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is greater than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is greater than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 1
 */
int low_to_high_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   int high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:	   If x is less than or equal to y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If x is less than or equal y, y needs to be "bubbled up" to the top
 *             Large numbers are ordered first
 * 
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 0
 */
int high_to_low_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   int absolute_low_to_high_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 *  RETURNS:   If the absolute value of x is greater than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is greater than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Smaller numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 1
 *             x = 8, y = 68, return 0
 *             x = -24, y = 318, return 0
 *             x = -318, y = -688, return 0
 */
int absolute_low_to_high_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   absolute_high_to_low_compare(int x, int y)
 *
 * ARGUMENTS:  Two sequential integers to compare
 *             For the sake of ordering, x should come before y
 *
 * RETURNS:    If the absolute value of x is less than or equal to the absolute value of y, return 1
 *             On error, return -1
 *             Return 0 for all other conditions
 *
 * NOTES:      This function compares the values of x and y
 *             If the absolute value of x is less than or equal the absolute value of y,
 *                 y needs to be "bubbled up" to the top
 *             This function will not attempt to modify the values of x and y
 *             Large numbers, regardless of 'sign', are ordered first
 *
 * EXAMPLES:   x = 9, y = 0, return 0
 *             x = 8, y = 68, return 1
 *             x = -24, y = 318, return 1
 *             x = -318, y = -688, return 1
 */
int absolute_high_to_low_compare(int x, int y)
{
	/********************/
	/* Place code here! */
	/********************/

	return -1; // You'll want to modify this
}

/*
 * FUNCTION:   bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int))
 *
 * ARGUMENTS:  arrayOfInts - a pointer to an array of integers
 *             numOfElements - the dimension of the integer array found at the int pointer arrayOfInts
 *              compare_function - a function pointer; This function should take two ints as parameters
 *                 and return an int.  The expectation is that compare_function performs a comparison
 *                 of the two ints and returns a boolean value.  This boolean value should represent
 *                 whether or not the two ints should be swapped.  If the return value of compare_function
 *                 is 1, then the two ints should be swapped in place.
 *
 * RETURNS:    The total number of int swaps that were made
 *             0 if no swaps were made
 *             -1 if any pointer is NULL
 *             -2 if numOfElements is unrealistic
 *             -3 on any other error
 *
 * NOTES:      This function is already defined below.  Do not modify this function.
 *             This function will sort, in place, the first "numOfElements" elements that are found
 *                 in the integer array found at pointer "arrayOfInts".  To accomplish this, bubble_sort()
 *                 will utilize the comparison function found at "compare_function" to accomplish this.
 *                 The expectation is that compare_function will compare two ints, n1 and n2.  In this, it
 *                 is expected that n1 comes before n2.  If n1 needs to swap with n2, compare_function will
 *                 return 1.  If not, compare_function will return 0.  Any other return value from
 *                 compare_function will be considered an error value (see: RETURNS).
 */
int bubble_sort(int * arrayOfInts, int numOfElements, int(*compare_function)(int, int))
{
	int returnValue = -3;	// Default return value in case something dies
	int i = 0;				// Iterating variable
	int j = 0;				// Iterating variable
	int swapCount = 0;		// Number of element swaps that have been made

	if (!arrayOfInts || !compare_function)	// If either of the pointers are NULL...
	{
		returnValue = -1;	// ...return -1
	}
	else if (numOfElements < 2) // If the number of elements is unrealistic...
	{
		returnValue = -2; // ...return -2
	}
	else
	{
		for (i = 0; i < numOfElements; i++) // Iterate through all of the elements...
		{
			for (j = 0; j < (numOfElements - 1); j++) // ...comparing each element to all the other elements
			{
				if ((compare_function(*(arrayOfInts + j), *(arrayOfInts + j + 1))) > 0) // If the compare function suggests a swap...
				{
					/* ...swap the values stored in each element */
					*(arrayOfInts + j)		= *(arrayOfInts + j) ^ *(arrayOfInts + j + 1);
					*(arrayOfInts + j + 1)	= *(arrayOfInts + j) ^ *(arrayOfInts + j + 1);
					*(arrayOfInts + j)		= *(arrayOfInts + j) ^ *(arrayOfInts + j + 1);
					swapCount++; // A swap took place so increment the number of swaps counted
				}
			}
		}
		returnValue = swapCount; // Return the total number of swaps that took place
	}
	
	return returnValue;
}
#include <stdio.h>

int main(void)
{
	char * userString1 = { "Test?" };

	puts(userString1);

	return 0;
}
#include <stdio.h>

int main(void)
{
	float x = 1.2;
	float y = 3.4;
	float cartesianCoordinate1[] = { x, y };

	return 0;
}
#include <stdio.h>

int main(void)
{
	int i = 0;

	char rule0[] = { "Talk about Byte Club." };
	char rule1[] = { "Please talk about Byte Club." };
	char rule2[] = { "If a byte is 0x0 the string is over." };
	char * byteClubRules[] = { rule0, rule1, rule2 };

	for (i = 0; i < 3; i++)
	{
		printf("Rule #%d:\t%s\n", i, byteClubRules[i]);
	}

	return 0;
}
#include <stdio.h>

float average_students_grades(float * stuGradeArray, int arrayDimension);

int main(void)
{
	float stu1Grades[5] = { 90.1, 100.0, 89.9, 78.1, 87.6 };
	float stu2Grades[5] = { 70.5, 79.3, 68.9, 3.0, 0.0 };
	float stu3Grades[5] = { 100.0, 100.0, 100.0, 100.0, 99.9 };
	float * classGrades[] = { stu1Grades, stu2Grades, stu3Grades };
	int i = 0;

	float tempAvgGrade = 0;
	printf("\nStudent Averages\n----------------\n");
	for (i = 0; i < 3; i++)
	{
		tempAvgGrade = average_students_grades(*(classGrades + i), 5);
		printf("Student #%d:\t%2.1f\n", (i + 1), tempAvgGrade);
//		printf("Student #%d:\t%f\n", (i + 1), tempAvgGrade);
	}

	return 0;
}

/*
 * FUNCTION:   average_students_grades(float * stuGradeArray, int arrayDimension)
 *
 * ARGUMENTS:  stuGradeArray is a floating pointer integer pointer to an array of grades for a particular student
 *             arrayDimension is the dimension of stuGradeArray
 *
 * RETURNS:	   Floating point integer average of first x grades found in stuGradeArray if x is defined as
 *                 x == arrayDimension
 *             -1 if stuGradeArray is NULL
 *             -2 if arrayDimension is unrealistic
 *
 * NOTES:      This function will only average the first x grades found in the stuGradeArray if x is defined as
 *                 x == arrayDimension
 */
float average_students_grades(float * stuGradeArray, int arrayDimension)
{
	float returnValue = 0.0;
	int i = arrayDimension;

	if (!stuGradeArray)
	{
		returnValue = -1;
	}
	else if (arrayDimension < 1)
	{
		returnValue = -2;
	}
	else
	{
		for (i = 0; i < arrayDimension; i++)
		{
			returnValue += (*(stuGradeArray + i) * 1.0);
		}
		returnValue /= (arrayDimension * 1.0);
	}

	return returnValue;
}
#include <stdio.h>

int main(void)
{
	int i = 0;

	char initials1[] = { 'j', 'e', 'h', 0 };
	char initials2[] = { 'm', 'a', 't', 0 };
	char initials3[] = { 'c', 's', 'n', 0 };
	char * arrayOfInitials[] = { initials1, initials2, initials3 };

	for (i = 0; i < 3; i++)
	{
		puts(*(arrayOfInitials + i));
	}

	return 0;
}
#include <stdio.h>

int main(void)
{
	int someNums[5] = { 0, 1, 2, 3, 4 };
	int * someNums_ptr = someNums;
//	int * someNums_ptr2 = (someNums + 1);

	someNums_ptr++;

	someNums_ptr += 2;

	someNums_ptr--;

	someNums_ptr -= 2;

//	printf("%p - %p = %p \n", someNums_ptr, someNums, someNums_ptr - someNums);
//	printf("%p - %p = %p \n", someNums_ptr, someNums_ptr2, someNums_ptr - someNums_ptr2);


	return 0;
}
#include <stdio.h>

int main(void)
{
	int someNums[5] = { 0, 1, 2, 3, 4 };
	int * someNums_ptr = someNums;
//	int * someNums_ptr2 = (someNums + 1);

	someNums_ptr++;

	someNums_ptr += 2;

	someNums_ptr--;

	someNums_ptr -= 2;

//	printf("%p - %p = %p \n", someNums_ptr, someNums, someNums_ptr - someNums);
//	printf("%p - %p = %p \n", someNums_ptr, someNums_ptr2, someNums_ptr - someNums_ptr2);


	return 0;
}
#include <stdio.h>

int main(void)
{
	int someNums[5] = { 0, 1, 2, 3, 4 };
	int * someNums_ptr = someNums;

	*someNums = 1;					// someNums[0] == 1;

	*(someNums + 4) = 2;			// someNums[4] == 2;

	someNums_ptr = someNums + 3;	// Pointer now set to &someNums[3]

	return 0;
}
#include <stdio.h>

int main(void)
{
	int * someNum_ptr = (int *)0x1234;				// BAD!1!

//	*someNum_ptr = 66;								// ERROR!1!

	return 0;
}
#include <stdio.h>

int main(void)
{
	int x = 3;
	int y = 5;
	int * x_ptr = &x;
	int * y_ptr = &y;

	printf("X has a value %d at address %p \n", x, x_ptr);
	printf("Y has a value %d at address %p \n", y, y_ptr);

	if (x > y)
	{
		printf("x_ptr comes after y_ptr sequentially\n");
	}
	else if (y > x)
	{
		printf("y_ptr comes after x_ptr sequentially\n");
	}
	else
	{
		printf("Somehow, x_ptr and y_ptr are the same?!\n");
	}

	return 0;
}
#include <stdio.h>

int main(void)
{
	int numArray[] = { 0, 1, 2, 3 };
	int * num_ptr = numArray;
	int * otherNum_ptr = (numArray + 2);

	printf("The first value of %d is at address %p\n", *num_ptr, num_ptr);
	printf("The second value of %d is at address %p\n", *otherNum_ptr, otherNum_ptr);
	printf("&first - &second = %d\n", num_ptr - otherNum_ptr);
	printf("&second - &first = %d\n", otherNum_ptr - num_ptr);
	
	if (otherNum_ptr > num_ptr)
	{
		puts("otherNum_ptr is higher");
	}
	else if (num_ptr > otherNum_ptr)
	{
		puts("num_ptr is higher");
	}
	else
	{
		puts("They are equal?!");
	}

	if (otherNum_ptr > num_ptr)
	{
		printf("%d comes after %d \n", *otherNum_ptr, *num_ptr);
	}

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	FILE * readFile = fopen("no-read.txt", "r");
	FILE * writeFile = fopen("no-write.txt", "w");
	FILE * appendFile;

//	readFile = fopen("no-read.txt", "r");
//	writeFile = fopen("no-write.txt", "w");
	appendFile = fopen("no-append.txt", "a");

	if (!readFile)
	{
		puts("Failed to read a file.");
	}
	else
	{
		fputs("Read it!", readFile);
		fclose(readFile);
	}

	if (!writeFile)
	{
		puts("Failed to write a file.");
	}
	else
	{
		fputs("Wrote it!", writeFile);
		fclose(writeFile);
	}
	
	if (!appendFile)
	{
		puts("Failed to append a file.");
	}
	else
	{
		fputs("Appended it!1!", appendFile);
		fclose(appendFile);
	}

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main(void)
{
	FILE * myFile_ptr = fopen("no-append.txt", "r");
	char readFromFile = 0;
	if (myFile_ptr)
	{
		while (readFromFile != EOF)
		{
			readFromFile = getc(myFile_ptr);
			putc(readFromFile, stdout);
		}
		fclose(myFile_ptr);
	}

	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

#define BUFF_SIZE 256

int main(void)
{
	FILE * myFile_ptr = fopen("no-append.txt", "r");
	char tempBuff[BUFF_SIZE] = { 0 };
	char * tempReturnValue = tempBuff;

	if (!myFile_ptr)
	{
		puts("Error opening file!");
		return -1;
	}
	else
	{
		while (tempReturnValue)
		{
//			printf("EOF?\t%d\n", feof(myFile_ptr)); // DEBUGGING 
			printf("Size of tempBuff:\t%d\n", sizeof(tempBuff));
			tempReturnValue = fgets(tempBuff, sizeof(tempBuff), myFile_ptr);
		
			if (tempReturnValue)
			{
				puts(tempBuff);
			}
		}
//		printf("EOF?\t%d\n", feof(myFile_ptr)); // DEBUGGING 
	}

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// DEMONSTRATION LAB I.7.A-2 //////////////////////////////////////////////
//////////////////////////////////////////////// ARRAYS OF STRUCTS //////////////////////////////////////////////////
//////////////////////////////////////////// "Legilimency Structomancy" /////////////////////////////////////////////
///////////////////////////////////////////// Stub Code (bad function) //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Define a struct to test sorting_hat() from Demonstration Lab I.5.a-5 (see below)
// Only Address Arithmetic is permitted
// Write at least one test to cover the following sorting_hat() requirements:
//     Normal input
//     Alpahbetically ordered strings match
//     stringArray_ptr is NULL
//     At least one NULL pointer within stringArray_ptr
//     numOfStrings is negative
//     numOfStrings is zero (0)
//     numOfStrings is one (1)
// Remember, all non-NULL char pointers must dereference to null-terminated strings
// All tests must display human-readable parameters and results
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// DEMONSTRATION LAB I.5.A-5 /////////////////////////////////////////////
////////////////////////////////////////////////// POINTER ARRAYS ///////////////////////////////////////////////////
/////////////////////////////////////////////////// "Legilimency" ///////////////////////////////////////////////////
///////////////////////////////////////////// Stub Code (bad function) //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test sorting_hat()
// The version of sorting_hat() in this solution is 100% functional
// The student will write parallel arrays of test parameters for sorting_hat()
//     char ** stringArray_ptr - An array of string arrays (not a typo) is necessary to pass to sorting_hat()
//     int numOfStrings - A parallel integer array of numOfStrings will need to hold the number of strings 
//         each string array holds
//     int * errorCode - No array is needed for the memory address, merely passing the memory address of an
//         integer variable should suffice
// The student must also write parallel arrays to test the expected output of sorting_hat()
//     "character pointer" return value - A parallel array of character pointers is necessary to test the return
//         values of sorting_hat()
//     errorCode - A parallel integer array of expected errorCodes is also necessary to test sorting_hat()
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke sorting_hat() with an array of strings, the number of the strings in that array, and 
//             an integer pointer to store the resulting errorCode.
//         2. Test the return value of sorting_hat() against what is expected.
//         3. Test the errorCode value against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// The student will not be testing convert_char_to_lower()
// 
// TESTING SPECIFICATIONS
// Write two tests for each of the following conditions:
//     1. Normal input
//     2. The array of strings passed to sorting_hat() include alphabetically 'first' matching strings 
//         NOTE: The first matching strings should be returned
//     3. Pass a NULL pointer as stringArray_ptr
//     4. Pass a NULL pointer as one of the strings found in the array of strings passed to sorting_hat()
//     5. Pass an normal array of strings but pass a negative number as the number of strings in the array (numOfStrings)
//     6. Pass an normal array of strings but pass a zero (0) as the number of strings in the array (numOfStrings)
//     7. Pass an normal array of strings but pass a one (1) as the number of strings in the array (numOfStrings)
// *ALL* non-NULL char pointers must dereference to null-terminated strings (otherwise sorting_hat() will crash)
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  sorting_hat() has been written with good code *and* bad code so that students can practice both conditions
//     as they write their tests.  This version of sorting_hat() happens to be the version that randomly answers
//     incorrectly more often than it guesses the correct response to a given test.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif


/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode);

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept 
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter);

/*
 *  PLACE STRUCT HERE
 */

int main(void)
{
	puts("You still need to write an array of struct pointers to test sorting_hat()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
{
	char * randomReturnValue_ptr = NULL;	// Variable used to store the function's random return value
	
	/* Attempt to Sleep */
#ifdef _WIN32
	Sleep(1000);
#elif defined(__linux__) || defined(__unix__)
	sleep(1);
#endif
	
	/* Seed the rand() function */
	srand((unsigned int)time(NULL));

	/* Randomize a 'sign' */
	int sign = (rand() % (2));
	if (!sign)
	{
		sign -= 1;
	}

	/* Randomize an Error Code */
	int randomErrorCode = (sign)* (rand() % (90318 - 1)) + 1; // Randomize an error code

	/* Pointers to return if stringArray_ptr is NULL */
	static char * randomResponsePointers[] = { "This isn't working.", "This function is broken!", "Why are you looking at this?", "You shouldn't even be able to read these.", "No." };

	/* Randomize a randomResponsePointer just in case */
	int randomArrayIndex = 0;
	
	if (!stringArray_ptr || !errorCode || (numOfStrings < 2)) // If one of the parameters are 'off'...
	{
		/* Randomize an index from randomResponsePointers */
		randomArrayIndex = (rand() % (sizeof(randomResponsePointers) / sizeof(*(randomResponsePointers))));
		/* Set the return value as a pointer to a randomResponsePointer */
		randomReturnValue_ptr = *(randomResponsePointers + randomArrayIndex);
	}
	else // Otherwise, the function parameters are fine so...
	{
		/* Randomize an index from stringArray_ptr */
		randomArrayIndex = (rand() % (numOfStrings));
		/* Set the return value as a pointer to a random string from stringArray_ptr */
		randomReturnValue_ptr = *(stringArray_ptr + randomArrayIndex);
	}

	/* Set random errorCode */
	if (errorCode)						// If the errorCode pointer is *NOT* NULL...
	{
		*errorCode = randomErrorCode;				// ...set the error code as random...
	}

	return randomReturnValue_ptr;
}

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter)
{
	char returnValue = 0;	// REturn value variable

	if (!letter)			// If letter is '\0' (0x0)...
	{
		returnValue = 0;	// ...set the return value to 0x0
	}
	else if (letter >= 0x41 && letter <= 0x5A) // Otherwise, if the input letter is a capital alphabet letter...
	{
		returnValue = letter + 0x20; // ...'shift' it to its equivalent lower-case value
	}
	else					// Otherwise, it's not '\0' (0x0) and it's not a capital letter so...
	{
		returnValue = letter; // ...just set the return value to "letter" since the function doesn't need to do anything
	}

	return returnValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// DEMONSTRATION LAB I.7.A-2 //////////////////////////////////////////////
//////////////////////////////////////////////// ARRAYS OF STRUCTS //////////////////////////////////////////////////
//////////////////////////////////////////// "Legilimency Structomancy" /////////////////////////////////////////////
///////////////////////////////////////////// Stub Code (good function) /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Define a struct to test sorting_hat() from Demonstration Lab I.5.a-5 (see below)
// Only Address Arithmetic is permitted
// Write at least one test to cover the following sorting_hat() requirements:
//     Normal input
//     Alpahbetically ordered strings match
//     stringArray_ptr is NULL
//     At least one NULL pointer within stringArray_ptr
//     numOfStrings is negative
//     numOfStrings is zero (0)
//     numOfStrings is one (1)
// Remember, all non-NULL char pointers must dereference to null-terminated strings
// All tests must display human-readable parameters and results
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// DEMONSTRATION LAB I.5.A-5 /////////////////////////////////////////////
////////////////////////////////////////////////// POINTER ARRAYS ///////////////////////////////////////////////////
/////////////////////////////////////////////////// "Legilimency" ///////////////////////////////////////////////////
///////////////////////////////////////////// Stub Code (good function) /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test sorting_hat()
// The version of sorting_hat() in this solution is 100% functional
// The student will write parallel arrays of test parameters for sorting_hat()
//     char ** stringArray_ptr - An array of string arrays (not a typo) is necessary to pass to sorting_hat()
//     int numOfStrings - A parallel integer array of numOfStrings will need to hold the number of strings 
//         each string array holds
//     int * errorCode - No array is needed for the memory address, merely passing the memory address of an
//         integer variable should suffice
// The student must also write parallel arrays to test the expected output of sorting_hat()
//     "character pointer" return value - A parallel array of character pointers is necessary to test the return
//         values of sorting_hat()
//     errorCode - A parallel integer array of expected errorCodes is also necessary to test sorting_hat()
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke sorting_hat() with an array of strings, the number of the strings in that array, and 
//             an integer pointer to store the resulting errorCode.
//         2. Test the return value of sorting_hat() against what is expected.
//         3. Test the errorCode value against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// The student will not be testing convert_char_to_lower()
// 
// TESTING SPECIFICATIONS
// Write two tests for each of the following conditions:
//     1. Normal input
//     2. The array of strings passed to sorting_hat() include alphabetically 'first' matching strings 
//         NOTE: The first matching strings should be returned
//     3. Pass a NULL pointer as stringArray_ptr
//     4. Pass a NULL pointer as one of the strings found in the array of strings passed to sorting_hat()
//     5. Pass an normal array of strings but pass a negative number as the number of strings in the array (numOfStrings)
//     6. Pass an normal array of strings but pass a zero (0) as the number of strings in the array (numOfStrings)
//     7. Pass an normal array of strings but pass a one (1) as the number of strings in the array (numOfStrings)
// *ALL* non-NULL char pointers must dereference to null-terminated strings (otherwise sorting_hat() will crash)
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  sorting_hat() has been written with good code *and* bad code so that students can practice both conditions
//     as they write their tests.  This version of sorting_hat() happens to be the version that passes all tests
//     as listed.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif

/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode);

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept 
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter);

/*
 *  PLACE STRUCT HERE
 */

int main(void)
{
	puts("You still need to write an array of struct pointers to test sorting_hat()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
 *
 * ARGUMENTS:  stringArray_ptr is a pointer to array of char pointers.  Those char pointers happen to
 *                 be null-terminated strings.
 *             numOfStrings indicates the number of strings that can be found in the array of char pointers
 *                 found at stringArray_ptr
 *             errorCode is an integer pointer to store the errorCode provided by sorting_hat() (see below)
 *
 * RETURNS:	   On success, char pointer to the null-terminated string found within stringArray_ptr that would
 *                 come first, alphabetically.  For example, if stringArray_ptr dereferenced to:
 *                 "A", "B", "C", and "D", then sorting_hat() should return a pointer to "A".
 *             On failure, sorting_hat() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -1 if *ANY* pointer is NULL (this includes stringArray_ptr or any of the char pointers
 *                     found within stringArray_ptr)
 *                 -2 if numOfStrings is unrealistic (see: less than 2 strings in stringArray_ptr
 *                 -3 for all other errors (this may not be a testable condtion.  Currently, sorting_hat()
 *                     only utilizes Error Code -3 in the highly unlikely even that convert_char_to_lower() fails
 *                     somehow)
 */
char * sorting_hat(char ** stringArray_ptr, int numOfStrings, int * errorCode)
{
	char * returnValue_ptr = NULL;	// Variable used to store the function's return value
	char * currentString = NULL;	// Variable used to store a char pointer of a null-terminated string that happens to be the current "winner"
	char * stringToTest = NULL;		// Variable used to store a char pointer of a null-terminated string that is currently being checked as a "winner"
	int i = 0;						// Iterating variable
	int j = 0;						// Iterating variable
	char tempCharCurrentString = 0;	// Temp variable to hold a char to compare
	char tempCharStringToTest = 0;	// Temp variable to hold a char to test against tempCharCurrentString
	int shortestStringLen = 0;		// Delimiting variable to stop char-by-char comparisons from running over the end of a null-termianated string

	if (!stringArray_ptr || !errorCode) // If either pointer is NULL...
	{
		returnValue_ptr = NULL;			// ...set NULL as the return value...
		if (errorCode)
		{
			*errorCode = -1;				// ...set the error code as -1...
		}
		return returnValue_ptr;			// ...and return NULL
	}
	else if (numOfStrings < 2)			// Otherwise, if the number of strings in the array of strings is unreasonable (less than 2)...
	{
		returnValue_ptr = NULL;			// ...set NULL as the return value...
		*errorCode = -2;				// ...set the error code as -2...
		return returnValue_ptr;			// ...and return NULL
	}
	else
	{
		*errorCode = 0;					// This function is innocent (e.g., no errors, success) until proven guilty
		/*
		 *  Default case is that the first string is the answer.
		 *  Remaining functionality attempts to prove this assertion incorrect.
		 */
		currentString = *(stringArray_ptr);	// The current "champ" is the first string in the array of strings
		returnValue_ptr = currentString;	// As such, set the current "champ" as the return value

		for (i = 1; i < numOfStrings; i++)	// For each string found in the array of strings...
		{
			stringToTest = *(stringArray_ptr + i);	// ...test the "i"th string...

			j = 0;									// ...starting at element 0
			if (!currentString || !stringToTest)	// If the current "champ" or the first "challenger" are NULL...
			{
				returnValue_ptr = NULL;				// ...set NULL as the return value...
				*errorCode = -1;					// ...set the error code as -1...
				return returnValue_ptr;				// ...and return NULL
			}
			while (*(currentString + j) && *(stringToTest + j)) // Loop through the elements of the two strings as long as they're not '\0' (0x0)
			{
				tempCharCurrentString = convert_char_to_lower(*(currentString + j));	// Ensure the current character of the "champ" is lower-case
				tempCharStringToTest = convert_char_to_lower(*(stringToTest + j));		// Ensure the current character of the "competitor" is lower-case

				if (tempCharCurrentString && tempCharStringToTest) // If both of the characters are *NOT* NULL...
				{
					/* Alphabetizing characters by value (since they're all lower-case) */
					if (tempCharCurrentString < tempCharStringToTest) // If the "champ"'s char comes first...
					{
						returnValue_ptr = currentString; // ...so set the return value to the "champ"'s pointer...
						break;							 // ...and stop (while) looping. (The for loop will continue looking for more "challenger"s if there are any strings left in the array
					}
					else if (tempCharStringToTest < tempCharCurrentString) // Otherwise, the "challenger"'s char comes first...
					{
						returnValue_ptr = stringToTest; // ...so set the return value with the pointer to the "challenger" and...
						currentString = stringToTest;	// ...set the "challenger" as the new "champ"
						break; // ...and stop (while) looping. (The for loop will continue looking for more "challenger"s if there are any strings left in the array
					}
					// else... both chars are equivalent and the search (see: while loop) must continue with the next char
				}
				else // ....Otherwise, at least one of the current characters is NULL and something bad happened (which it should not have)
				{
					*errorCode = -3;
					puts("Something terrible has happened with convert_char_to_lower()!");
					return NULL;
				}

				j++;
			}
		}
	}

	return returnValue_ptr;
}

/*
 * FUNCTION:   char convert_char_to_lower(char letter)
 *
 * ARGUMENTS:  letter is a character to be converted to a lower-case alphabet letter, if appropriate
 *
 * RETURNS:	   On success, convert_char_to_lower() returns the modified character.  If "char letter" is an
 *                 upper-case letter, this function will return the lower-case version of "char letter".  If
 *                 "char letter" is *NOT* an upper-case letter, this function will merely return "letter"
 *                 as a 'pass through', if you will.
 *             On error, convert_char_to_lower() returns 0.  As a consequence, this function will not accept
 *                 '\0' (0x0) as a value of "letter" and will return 0.
 *
 * NOTES:      This function is very simple and should not provide any errors.
 */
char convert_char_to_lower(char letter)
{
	char returnValue = 0;	// Return value variable

	if (!letter)			// If letter is '\0' (0x0)...
	{
		returnValue = 0;	// ...set the return value to 0x0
	}
	else if (letter >= 0x41 && letter <= 0x5A) // Otherwise, if the input letter is a capital alphabet letter...
	{
		returnValue = letter + 0x20; // ...'shift' it to its equivalent lower-case value
	}
	else					// Otherwise, it's not '\0' (0x0) and it's not a capital letter so...
	{
		returnValue = letter; // ...just set the return value to "letter" since the function doesn't need to do anything
	}

	return returnValue;
}
#include <stdio.h>

int add(int num1, int num2);
int multiply(int num1, int num2);
int subtract(int num1, int num2);

struct ModifyNumbers{
	int number_one;
	int number_two;
	int results;
	int(*mathFunc_ptr)(int x, int y);
};

int main(void)
{
	int i = 0;
	struct ModifyNumbers testCase1 = { 1, 2, 0, &add };			// 3
	struct ModifyNumbers testCase2 = { 2, 3, 0, &multiply };	// 6
	struct ModifyNumbers testCase3 = { 3, 4, 0, &subtract };	// -1

	struct ModifyNumbers * testCases[] = { &testCase1, &testCase2, &testCase3 };
	int numOfTestCases = sizeof(testCases) / sizeof(*(testCases));
	struct ModifyNumbers * currentStruct = NULL;

	for (i = 0; i < numOfTestCases; i++)
	{
		currentStruct = (*(testCases + i));
		currentStruct->results = currentStruct->mathFunc_ptr(currentStruct->number_one, currentStruct->number_two);
	}

	return 0;
}

int add(int num1, int num2)
{
	return (num1 + num2);
}

int multiply(int num1, int num2)
{
	return (num1 * num2);
}

int subtract(int num1, int num2)
{
	return (num1 - num2);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// PERFORMANCE LAB I.7.A-2 /////////////////////////////////////////////
///////////////////////////////////////////////// ARRAYS OF STRUCTS ////////////////////////////////////////////////
////////////////////////////////////// "Good Order, Discipline, and Structure" /////////////////////////////////////
/////////////////////////////////////////////// Stub Code (bad code) ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reaccomplish (or modify) Performance Lab I.5.a-5 (see below) with the following stipulations:
//     Define a struct to test counting_array() (see below) from Performance Lab I.5.a-5
//     Utilize an array of struct pointers to store all of the structs you create as tests
//     Only Address Arithmetic is permitted
//     Write at least one test to cover every requirement
//     Print the human-readable output
//     Use of the dot operator (.) is expressly FORBIDDEN.  You are only allowed to use the arrow (->) operator
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-5 ////////////////////////////////////////////
//////////////////////////////////////////////////// POINTER ARRAYS ////////////////////////////////////////////////
////////////////////////////////////////////// "Good Order and Discipline" /////////////////////////////////////////
/////////////////////////////////////////////// Stub Code (bad code) ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test counting_array()
// The version of counting_array() in this solution will rarely pass tests, if at all
// The student will write parallel arrays of test parameters for counting_array() which, at a minimum, includes:
//     inputStartingNumbers - A parallel integer array of "starting numbers"
//     inputEndingNumbers - A parallel integer array of "ending numbers"
//     expectedErrorCodes - A parallel integer array of expected "error codes"
//     expectedIntArrays - A parallel array of integer arrays which holds the expected output
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke counting_array() with a starting number, an ending number, and an integer pointer to store
//             the resulting errorCode.
//         2. Test the dereferenced value of the integer pointer against what is expected.
//         3. Test the returned integer pointer against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// 
// TESTING SPECIFICATIONS
// Write one test for each of the following conditions:
// Test #		startingNumber		endingNumber		expectedErrorCode
// 1.			x					y					0
// 2.			a					y					0
// 3.			a					b					0
// 4.			y					x					-2
// 5.			b					a					-2
// 6.			y					a					-2
// NOTE 1:  If a < b < 0 < x < y
// NOTE 2:  The values of a, b, x, and y don't have to be the same each time.  In fact, it's best for testing
//     if they're not always the same.
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  counting_array() has been written with good code *and* bad code so that students can practice both
//     conditions as they write their tests.  This version of counting_array() happens to be the version that 
//     will likely fail all tests as listed.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements 
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.  
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode);

/*
 *  INSERT STRUCT HERE
 */

int main(void)
{
	puts("You still need to write struct pointer arrays to test counting_array()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode)
{
	/* WRITE SOME BAD CODE HERE */
	int * returnValue_ptr = NULL;	// Return value variable
	int randomErrorCode = 0;		// Return error code variable
	int i = 0;						// Iterating variable
//	int j = 0;						// Iterating variable
	int tempArrayDimension = 0;		// Variable which holds the calculated dimension of the int array to return
	int randomAlgorithm = 0;		// Variable which stores randomized algorithm to execute WRT the int array
	int tempIndexNumber = 0;		// Variable used to temporarily store an index number
	/* Attempt to Sleep */
#ifdef _WIN32
	Sleep(1000);
#elif defined(__linux__) || defined(__unix__)
	sleep(1);
#endif

	/* Seed the rand() function */
	srand((unsigned int)time(NULL));

	/* Randomize a 'sign' */
	int sign = (rand() % (2));
	if (!sign)
	{
		sign -= 1;
	}

	/* Randomize an Error Code */
	randomErrorCode = sign * (rand() % (90318 - 1)) + 1; // Randomize an error code

	if (!errorCode)					// If the int pointer is NULL...
	{
		returnValue_ptr = NULL;		// ...set the return value as NULL and...
//		randomErrorCode = -1;		// ...set the error code variable to -1
	}
	if (startingNumber > endingNumber)	// If the start number is greater than the end number...
	{
		returnValue_ptr = NULL;			// ...set the return value as NULL and...
//		randomErrorCode = -2;			// ...set the error code variable to -2
	}
	else // Otherwise, the parameters are fine (so far)
	{
		tempArrayDimension = endingNumber - startingNumber + 1; // Compute the dimension of the int array to return

		/* Paranoid error check */
		if (tempArrayDimension > 0) // If the calculated dimension is valid...
		{
			/* AVAILABLE ALGORITHMS */
			// 1. NULL Pointer; Error Code 0
			// 2. Unitialized Memory; Random Error Code
			// 3. Pointer to appropriately sized memory, zeroized; Random Error Code
			// 4. Pointer to appropriately sized memory, backwards values; Random Error Code
			// 5. Pointer to appropriately sized memory, random values; Random Error Code
			// 6. Pointer to appropriately sized memory, appropriate values (first element is wrong); Error Code 0
			// 7. Pointer to appropriately sized memory, appropriate values (middle element is wrong); Random Error Code
			// 8. Pointer to appropriately sized memory, appropriate values (last element is wrong); Random Error Code
			// 9. Pointer to appropriately sized memory, appropriate values (random element is wrong); Random Error Code
			// 10. Pointer to appropriately sized memory, appropriate values; Random Error Code
			// 11. Pointer to appropriately sized memory, appropriate values; Appropriate Error Code

			/* RESPONSE CONSTRUCTION */
			/* Randomize an algorithm to use */
			randomAlgorithm = (rand() % 11) + 1; // Randomize from 1 to 10

			/* A. Memory Allocation */
			switch (randomAlgorithm) // To allocate or not to allocate?  That is the question.
			{
			case 1:		// Return a NULL pointer regardless
				returnValue_ptr = NULL;
				randomErrorCode = 0;
				break;
			case 2:		// Return a pointer to unitialized memory
				returnValue_ptr = (int *)malloc((sizeof(int) * tempArrayDimension));
				break;
			default:	// Return a pointer to initiailzed memory
				returnValue_ptr = (int *)calloc(tempArrayDimension, sizeof(int)); // Dynamically allocate initialized memory into an appropriately sized int array
				break;
			}

			if (returnValue_ptr)
			{
				/* B. Memory Values */
				switch (randomAlgorithm) // To assign values or not to assign values?  That is the question.
				{
				case 1:		// NULL pointer so... no values to assign
				case 2:		// Leave the memory unitialized
				case 3:		// Leave the memory zeroized
					break;
				case 4:		// Initialize the array with backwards values

					/* ...initialize that int array with the appropriate values */
					for (i = 0; i < tempArrayDimension; i++)
					{
						*(returnValue_ptr + i) = endingNumber - i;
					}

					break;
				case 5:		// Initialize the memory with random values
					/* ...initialize that int array with the appropriate values */
					for (i = 0; i < tempArrayDimension; i++)
					{
						/* Seed the rand() function */
						srand((unsigned int)i);

						/* Feed a random value into the current element */
						*(returnValue_ptr + i) = (rand() % (i + 1)); // (i + 1) to avoid "divide by 0" errors
					}
					break;
				default:	// Properly initialize memory
					/* ...initialize that int array with the appropriate values */
					for (i = 0; i < tempArrayDimension; i++)
					{
						*(returnValue_ptr + i) = (startingNumber + i);
					}
					break;
				}


				/* C. Value Tweaks */
				switch (randomAlgorithm)
				{
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
					break;
				case 6:
					if (tempArrayDimension > 0)
					{
						if (*(returnValue_ptr) != 0xDEADC0DE)
						{
							*(returnValue_ptr) = 0xDEADC0DE;
						}
						else
						{
							*(returnValue_ptr) = 0xC0DEDEAD;
						}

						randomErrorCode = 0;
					}
					break;
				case 7:
					if (tempArrayDimension > 1)
					{
						tempIndexNumber = (int)(tempArrayDimension / 2);
						if (*(returnValue_ptr + tempIndexNumber) != 0xDEADC0DE)
						{
							*(returnValue_ptr + tempIndexNumber) = 0xDEADC0DE;
						}
						else
						{
							*(returnValue_ptr + tempIndexNumber) = 0xC0DEDEAD;
						}
						tempIndexNumber = 0;
					}
					else
					{
						returnValue_ptr = NULL;
						randomErrorCode = -3;
					}
					break;
				case 8: // Last element is mangled; Random error code
					if (tempArrayDimension > 0)
					{
						tempIndexNumber = (tempArrayDimension - 1);
						if (*(returnValue_ptr + tempIndexNumber) != 0xDEADC0DE)
						{
							*(returnValue_ptr + tempIndexNumber) = 0xDEADC0DE;
						}
						else
						{
							*(returnValue_ptr + tempIndexNumber) = 0xC0DEDEAD;
						}
					}
					else
					{
						returnValue_ptr = NULL;
						randomErrorCode = -3;
					}
					tempIndexNumber = 0;
					break;
				case 9: // Random element is mangled; Random error code
					if (tempArrayDimension)
					{
						tempIndexNumber = (rand() % tempArrayDimension);
						if (tempIndexNumber >= 0 && tempIndexNumber < tempArrayDimension)
						{
							if (*(returnValue_ptr + tempIndexNumber) != 0xDEADC0DE)
							{
								*(returnValue_ptr + tempIndexNumber) = 0xDEADC0DE;
							}
							else
							{
								*(returnValue_ptr + tempIndexNumber) = 0xC0DEDEAD;
							}
						}
					}
					tempIndexNumber = 0;
					break;
				case 10: // Normal behavior; Proper int pointer to an int array; Random error code
					break;
				default: // Normal behavior; Proper int pointer to an int array; Error code 0
					randomErrorCode = 0;
					break;
				}

			}
			else // Otherwise, dynamic memory allocation failed so...
			{
				returnValue_ptr = NULL; // ...return NULL and...
				randomErrorCode = -3;	// ...set the error code to -3 (which should be a very rare occurrence)
			}
		}
		else
		{
			returnValue_ptr = NULL;
		}
	}
	
	if (errorCode) // If errorCode is *NOT* NULL...
	{
		*errorCode = randomErrorCode; // ...set the value at that memory address to the error code variable value
	}
	return returnValue_ptr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// PERFORMANCE LAB I.7.A-2 /////////////////////////////////////////////
///////////////////////////////////////////////// ARRAYS OF STRUCTS ////////////////////////////////////////////////
////////////////////////////////////// "Good Order, Discipline, and Structure" /////////////////////////////////////
/////////////////////////////////////////////// Stub Code (good code) //////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reaccomplish (or modify) Performance Lab I.5.a-5 (see below) with the following stipulations:
//     Define a struct to test counting_array() (see below) from Performance Lab I.5.a-5
//     Utilize an array of struct pointers to store all of the structs you create as tests
//     Only Address Arithmetic is permitted
//     Write at least one test to cover every requirement
//     Print the human-readable output
//     Use of the dot operator (.) is expressly FORBIDDEN.  You are only allowed to use the arrow (->) operator
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// PERFORMANCE LAB I.5.A-5 ////////////////////////////////////////////
//////////////////////////////////////////////////// POINTER ARRAYS ////////////////////////////////////////////////
////////////////////////////////////////////// "Good Order and Discipline" /////////////////////////////////////////
/////////////////////////////////////////////// Stub Code (good code) //////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The student is required to write tests in main() that will test counting_array()
// The version of counting_array() in this solution is 100% functional
// The student will write parallel arrays of test parameters for counting_array() which, at a minimum, includes:
//     inputStartingNumbers - A parallel integer array of "starting numbers"
//     inputEndingNumbers - A parallel integer array of "ending numbers"
//     expectedErrorCodes - A parallel integer array of expected "error codes"
//     expectedIntArrays - A parallel array of integer arrays which holds the expected output
// Execution of the testing should be accomplished by looping through the parallel arrays.  Each iteration of the
//     loop should:
//         1. Invoke counting_array() with a starting number, an ending number, and an integer pointer to store
//             the resulting errorCode.
//         2. Test the dereferenced value of the integer pointer against what is expected.
//         3. Test the returned integer pointer against what is expected.
//         4. Report the results:
//             Printing "Pass" (and counting it) is sufficient when a test passes.
//             On a failed test, print the test that failed (e.g., Return Value, errorCode), print "FAIL",
//             print the expected output, and print the value that was found/received.
//         5. Count the number of passes and the number of tests (for a summary)
// At the end of all the testing, print (in a human-readable format) the total number of tests that were run and
//     the total number of tests that passed.
// 
// TESTING SPECIFICATIONS
// Write one test for each of the following conditions:
// Test #		startingNumber		endingNumber		expectedErrorCode
// 1.			x					y					0
// 2.			a					y					0
// 3.			a					b					0
// 4.			y					x					-2
// 5.			b					a					-2
// 6.			y					a					-2
// NOTE 1:  If a < b < 0 < x < y
// NOTE 2:  The values of a, b, x, and y don't have to be the same each time.  In fact, it's best for testing
//     if they're not always the same.
// All reference to arrays and the elements of those arrays *MUST* be accomplished utilizing
//     Address Arithmetic (AKA pointer math).  e.g., *NO* "myArray[i]" is permitted.
//
// NOTE:  counting_array() has been written with good code *and* bad code so that students can practice both
//     conditions as they write their tests.  This version of counting_array() happens to be the version that 
//     passes all tests as listed.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__) || defined(__unix__)
#include <unistd.h>
#endif

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements 
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.  
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode);

/*
 *  INSERT STRUCT HERE
 */

int main(void)
{
	puts("You still need to write struct pointer arrays to test counting_array()"); // Remove this

	return 0;
}

/*
 * FUNCTION:   int * counting_array(int startingNumber, int endingNumber, int * errorCode)
 *
 * ARGUMENTS:  First, it's important to note that successful execution of counting_array() will result
 *                 in an integer array filled with values starting with "startingNumber" and ending in
 *                 "endingNumber".  The dimension of this integer array is determined by these values.
 *                 Successful execution of counting_array() will result a pointer to an integer array
 *                 with a dimension equal to (endingNumber - startingNumber + 1);
 *			   startingNumber indicates the value of index 0 within the integer array mentioned above
 *             endingnumber indicates the value of the last index within the integer array mentioned above
 *             errorCode is an integer pointer to store the errorCode provided by counting_array() (see NOTES)
 *
 * RETURNS:	   On success, integer pointer to an integer array of dimension (endingNumber - startingNumber + 1).
 *                 The values of the integer array found at the integer pointer will be sequential.
 *                 If the return pointer is stored in int * returnArray_ptr, the following statements
 *                 will be true:
 *                     returnArray_ptr[0] == startingNumber;
 *                     returnArray_ptr[endingNumber - startingNumber] == endingNumber;
 *                     returnArray_ptr[0] + 1 == returnArray_ptr[1];
 *             On failure, counting_array() returns NULL.  (see errorCode description for examples of
 *                 potential failures)
 *
 * NOTES:      Error Codes:
 *                 0 on success
 *                 -2 if startingNumber is greater than endingNumber
 *                 -3 for all other errors (this may not be a testable condtion.
 */
int * counting_array(int startingNumber, int endingNumber, int * errorCode)
{
	int * returnValue_ptr = NULL;	// Return value variable
	int returnErrorCode = 0;		// Return error code variable
	int i = 0;						// Iterating variable
	int tempArrayDimension = 0;		// Variable which holds the calculated dimension of the int array to return

	if (!errorCode)					// If the int pointer is NULL...
	{
		returnValue_ptr = NULL;		// ...set the return value as NULL and...
		returnErrorCode = -1;		// ...set the error code variable to -1
	}
	if (startingNumber > endingNumber)	// If the start number is greater than the end number...
	{
		returnValue_ptr = NULL;			// ...set the return value as NULL and...
		returnErrorCode = -2;			// ...set the error code variable to -2
	}
	else // Otherwise, the parameters are fine (so far)
	{
		tempArrayDimension = endingNumber - startingNumber + 1; // Compute the dimension of the int array to return

		/* Paranoid error check */
		if (tempArrayDimension > 0) // If the calculated dimension is valid...
		{
			returnValue_ptr = (int *)calloc(tempArrayDimension, sizeof(int)); // Dynamically allocate initialized memory into an appropriately sized int array

			/* Semi-Paranoid error check */
			if (returnValue_ptr) // If calloc actually returned a pointer to valid memory space...
			{
				/* ...initialize that int array with the appropriate values */
				for (i = 0; i < tempArrayDimension; i++)
				{
					*(returnValue_ptr + i) = (startingNumber + i);
				}
			}
			else // Otherwise, calloc messed up so...
			{
				returnValue_ptr = NULL; // ...return NULL and...
				returnErrorCode = -3;	// ...set the error code to -3 (which should be a very rare occurrence)
			}
		}
	}
	
	if (errorCode) // If errorCode is *NOT* NULL...
	{
		*errorCode = returnErrorCode; // ...set the value at that memory address to the error code variable value
	}
	return returnValue_ptr;
}
#include <stdio.h>

struct LotForSale {
	int lot_number;
	float lot_cost;
	float square_footage;
};

int main(void)
{
	struct LotForSale timberRange = { 8755, 25000, 6534 };

	struct LotForSale martinLutherKing;
	martinLutherKing.lot_number = 2962;
	martinLutherKing.lot_cost = 85900;
	martinLutherKing.square_footage = 7405;

	struct LotForSale * currentLot;
	currentLot = &martinLutherKing;
	currentLot->lot_number = 4672;
	currentLot->lot_cost = 72000;
	currentLot->square_footage = 21344.4;

	struct LotForSale millionaireEstates;
	currentLot = &millionaireEstates;
	currentLot->lot_cost = 1000000;

	return 0;
}
#include <stdio.h>

struct HouseForSale {
	char mailing_address[1024];
	float cost_per_sq_ft;
	float square_footage;
	float total_cost;
};

int main(void)
{
	struct HouseForSale FF4HQ = { "Baxter Building, 42nd Street, Madison Avenue, Manhattan", 107.15, 28000, 0 };
	struct HouseForSale durdenManor = { "420 Paper St. Wilmington, DE 19886", 0.01, 4500, 0 };
	struct HouseForSale flintstonesHome = { "301 Cobblestone Way, Bedrock 70777", 1.23, 2500, 0 };
	struct HouseForSale pineappleUnderTheSea = { "124 Conch Street, Bikini Bottom, Pacific Ocean", 43.21, 2000, 0 };

	/* Array of four HouseForSale structs */
	struct HouseForSale porterRanchHouses[4] = { FF4HQ, durdenManor, flintstonesHome, pineappleUnderTheSea };		

	/* Array of four HouseForSale structs */
	struct HouseForSale * porterRanchHousePointers[4] = { &FF4HQ, &durdenManor, &flintstonesHome, &pineappleUnderTheSea };

	/* Modify individual elements of: an original struct, the array, and the pointer array... then compare */
	// Original struct
	FF4HQ.total_cost = (float)FF4HQ.cost_per_sq_ft * (float)FF4HQ.square_footage; 
	// Array
	porterRanchHouses[1].total_cost = (float)porterRanchHouses[1].cost_per_sq_ft * (float)porterRanchHouses[1].square_footage; 
	// Pointer Array
	porterRanchHousePointers[2]->total_cost = (float)porterRanchHousePointers[2]->cost_per_sq_ft * (float)porterRanchHousePointers[2]->square_footage;

	/* Compare all three total costs */
	struct HouseForSale * tempStruct_ptr = &FF4HQ;
	int i = 0;

	/* 
	 *  DISCLAIMER:  The following section would definitely benefit from a for loop.  The for loop was avoided 
	 *  so that the original structs could be directly referenced.
	 */
	if (tempStruct_ptr->total_cost != porterRanchHouses[i].total_cost || porterRanchHouses[i].total_cost != porterRanchHousePointers[i]->total_cost)
	{
		printf("Not equivalent!\n");
		printf("Original:\t%f\n", tempStruct_ptr->total_cost);
		printf("Array:\t\t%f\n", porterRanchHouses[i].total_cost);
		printf("Pointer:\t%f\n", porterRanchHousePointers[i]->total_cost);
	}

	tempStruct_ptr = &durdenManor;
	i++;
	if (tempStruct_ptr->total_cost != porterRanchHouses[i].total_cost || porterRanchHouses[i].total_cost != porterRanchHousePointers[i]->total_cost)
	{
		printf("Not equivalent!\n");
		printf("Original:\t%f\n", tempStruct_ptr->total_cost);
		printf("Array:\t\t%f\n", porterRanchHouses[i].total_cost);
		printf("Pointer:\t%f\n", porterRanchHousePointers[i]->total_cost);
	}

	tempStruct_ptr = &flintstonesHome;
	i++;
	if (tempStruct_ptr->total_cost != porterRanchHouses[i].total_cost || porterRanchHouses[i].total_cost != porterRanchHousePointers[i]->total_cost)
	{
		printf("Not equivalent!\n");
		printf("Original:\t%f\n", tempStruct_ptr->total_cost);
		printf("Array:\t\t%f\n", porterRanchHouses[i].total_cost);
		printf("Pointer:\t%f\n", porterRanchHousePointers[i]->total_cost);
	}

	tempStruct_ptr = &pineappleUnderTheSea;
	i++;
	if (tempStruct_ptr->total_cost != porterRanchHouses[i].total_cost || porterRanchHouses[i].total_cost != porterRanchHousePointers[i]->total_cost)
	{
		printf("Not equivalent!\n");
		printf("Original:\t%f\n", tempStruct_ptr->total_cost);
		printf("Array:\t\t%f\n", porterRanchHouses[i].total_cost);
		printf("Pointer:\t%f\n", porterRanchHousePointers[i]->total_cost);
	}

	return 0;
}
#include <stdio.h>

struct LinkedRecord{
	struct LinkedRecord * previous_record;
	int unique_id;
	char record_name[20];
	struct LinkedRecord * next_record;
};

int assign_record_pointers(struct LinkedRecord ** record_ptrs, int numOfRecords);

int main(void)
{
//	int tempReturnValue = 0;

	struct LinkedRecord record1 = { NULL, 1, "Record 1", NULL };
	struct LinkedRecord record2 = { NULL, 2, "Record 2", NULL };
	struct LinkedRecord record3 = { NULL, 3, "Record 3", NULL };
	struct LinkedRecord record4 = { NULL, 4, "Record 4", NULL };
	struct LinkedRecord record5 = { NULL, 5, "Record 5", NULL };

	struct LinkedRecord * arrayOfStructPtrs[] = { &record1, &record2, &record3, &record4, &record5 };
	int arrayLen = sizeof(arrayOfStructPtrs) / sizeof(*(arrayOfStructPtrs));

	if (assign_record_pointers(arrayOfStructPtrs, arrayLen) >= 0)
	{
		puts("Good");
	}
	else
	{
		puts("assign_record_pointers() failed.");
		return -1;
	}

	return 0;
}

int assign_record_pointers(struct LinkedRecord ** record_ptrs, int numOfRecords)
{
	int returnValue = -3;
	int i = 0;
	struct LinkedRecord * firstRecord = NULL;
	struct LinkedRecord * currentRecord = NULL;
	struct LinkedRecord * lastRecord = NULL;

	if (!record_ptrs)
	{
		returnValue = -1;
	}
	else if (numOfRecords < 2)
	{
		returnValue = -2;
	}
	else
	{
		firstRecord = *record_ptrs;
		lastRecord = *(record_ptrs + numOfRecords - 1);

		firstRecord->previous_record = lastRecord;	// Array now wraps backward
		lastRecord->next_record = firstRecord;		// Last element now points to the first element

		for (i = 1; i < numOfRecords; i++) 
		{
			(*(record_ptrs + i))->previous_record = *(record_ptrs + i - 1);	// Set current node's previous record to the previous node
			(*(record_ptrs + i - 1))->next_record = *(record_ptrs + i);		// Set previous node's next record to the current node
		}

		returnValue = 0;
	}

	return returnValue;
}
#include <stdio.h>

#define LONG_WAY 1	// Comment this out to enact the EASY WAY

struct Student90COS {
	char student_initials[4];
	int student_number;
	struct MQTStudent * next_node;
};

int main(void)
{
	int i = 0;

	/* INITIALIZE STRUCT VARIABLES */
	struct Student90COS MQT_16_01_Student1 = { "MTA", 1, NULL };		// Head
	struct Student90COS MQT_16_01_Student2 = { "LJB", 2, NULL };		// Node
	struct Student90COS MQT_16_01_Student3 = { "JVC", 3, NULL };		// Node
	struct Student90COS MQT_16_01_Student4 = { "DVF", 4, NULL };		// Node
	struct Student90COS MQT_16_01_Student5 = { "JCF", 5, NULL };		// Node
	struct Student90COS MQT_16_01_Student6 = { "JMH", 6, NULL };		// Node
	struct Student90COS MQT_16_01_Student7 = { "PAP", 7, NULL };		// Node
	struct Student90COS MQT_16_01_Student8 = { "SJS", 8, NULL };		// Node
	struct Student90COS MQT_16_01_Student9 = { "SRW", 9, NULL };		// Node
	struct Student90COS MQT_16_01_Student10 = { "JJW", 10, NULL };		// Tail
	
	/* INITIALIZE AN ARRAY OF STRUCT POINTERS */
	struct Student90COS * MQT_16_01_StudentArray[] = { \
		&MQT_16_01_Student1, &MQT_16_01_Student2, &MQT_16_01_Student3, \
		&MQT_16_01_Student4, &MQT_16_01_Student5, &MQT_16_01_Student6, \
		&MQT_16_01_Student7, &MQT_16_01_Student8, &MQT_16_01_Student9, \
		&MQT_16_01_Student10 
	};

	/* BUILD A LINKED LIST OF STRUCT VARIABLES */
	int numOfStudents = sizeof(MQT_16_01_StudentArray) / sizeof(*(MQT_16_01_StudentArray));

#ifdef LONG_WAY
	// LONG WAY
	MQT_16_01_Student1.next_node = &MQT_16_01_Student2;
	MQT_16_01_Student2.next_node = &MQT_16_01_Student3;
	MQT_16_01_Student3.next_node = &MQT_16_01_Student4;
	MQT_16_01_Student4.next_node = &MQT_16_01_Student5;
	MQT_16_01_Student5.next_node = &MQT_16_01_Student6;
	MQT_16_01_Student6.next_node = &MQT_16_01_Student7;
	MQT_16_01_Student7.next_node = &MQT_16_01_Student8;
	MQT_16_01_Student8.next_node = &MQT_16_01_Student9;
	MQT_16_01_Student9.next_node = &MQT_16_01_Student10;
	MQT_16_01_Student10.next_node = NULL;
#else
	// EASY WAY
	for (i = 0; i < (numOfStudents - 1); i++)
	{
		(*(MQT_16_01_StudentArray + i))->next_node = (*(MQT_16_01_StudentArray + i + 1));
	}
#endif

	return 0;
}
